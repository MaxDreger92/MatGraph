{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory(require(\"layout-base\"));else if (typeof define === 'function' && define.amd) define([\"layout-base\"], factory);else if (typeof exports === 'object') exports[\"coseBase\"] = factory(require(\"layout-base\"));else root[\"coseBase\"] = factory(root[\"layoutBase\"]);\n})(this, function (__WEBPACK_EXTERNAL_MODULE__551__) {\n  return (/******/(() => {\n      // webpackBootstrap\n      /******/\n      \"use strict\";\n\n      /******/\n      var __webpack_modules__ = {\n        /***/45: /***/(module, __unused_webpack_exports, __webpack_require__) => {\n          var coseBase = {};\n          coseBase.layoutBase = __webpack_require__(551);\n          coseBase.CoSEConstants = __webpack_require__(806);\n          coseBase.CoSEEdge = __webpack_require__(767);\n          coseBase.CoSEGraph = __webpack_require__(880);\n          coseBase.CoSEGraphManager = __webpack_require__(578);\n          coseBase.CoSELayout = __webpack_require__(765);\n          coseBase.CoSENode = __webpack_require__(991);\n          coseBase.ConstraintHandler = __webpack_require__(902);\n          module.exports = coseBase;\n\n          /***/\n        },\n\n        /***/806: /***/(module, __unused_webpack_exports, __webpack_require__) => {\n          var FDLayoutConstants = __webpack_require__(551).FDLayoutConstants;\n          function CoSEConstants() {}\n\n          //CoSEConstants inherits static props in FDLayoutConstants\n          for (var prop in FDLayoutConstants) {\n            CoSEConstants[prop] = FDLayoutConstants[prop];\n          }\n          CoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;\n          CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n          CoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;\n          CoSEConstants.TILE = true;\n          CoSEConstants.TILING_PADDING_VERTICAL = 10;\n          CoSEConstants.TILING_PADDING_HORIZONTAL = 10;\n          CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\n          CoSEConstants.ENFORCE_CONSTRAINTS = true;\n          CoSEConstants.APPLY_LAYOUT = true;\n          CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS = true;\n          CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true; // this should be set to false if there will be a constraint\n          // This constant is for differentiating whether actual layout algorithm that uses cose-base wants to apply only incremental layout or \n          // an incremental layout on top of a randomized layout. If it is only incremental layout, then this constant should be true.\n          CoSEConstants.PURE_INCREMENTAL = CoSEConstants.DEFAULT_INCREMENTAL;\n          module.exports = CoSEConstants;\n\n          /***/\n        },\n\n        /***/767: /***/(module, __unused_webpack_exports, __webpack_require__) => {\n          var FDLayoutEdge = __webpack_require__(551).FDLayoutEdge;\n          function CoSEEdge(source, target, vEdge) {\n            FDLayoutEdge.call(this, source, target, vEdge);\n          }\n          CoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);\n          for (var prop in FDLayoutEdge) {\n            CoSEEdge[prop] = FDLayoutEdge[prop];\n          }\n          module.exports = CoSEEdge;\n\n          /***/\n        },\n\n        /***/880: /***/(module, __unused_webpack_exports, __webpack_require__) => {\n          var LGraph = __webpack_require__(551).LGraph;\n          function CoSEGraph(parent, graphMgr, vGraph) {\n            LGraph.call(this, parent, graphMgr, vGraph);\n          }\n          CoSEGraph.prototype = Object.create(LGraph.prototype);\n          for (var prop in LGraph) {\n            CoSEGraph[prop] = LGraph[prop];\n          }\n          module.exports = CoSEGraph;\n\n          /***/\n        },\n\n        /***/578: /***/(module, __unused_webpack_exports, __webpack_require__) => {\n          var LGraphManager = __webpack_require__(551).LGraphManager;\n          function CoSEGraphManager(layout) {\n            LGraphManager.call(this, layout);\n          }\n          CoSEGraphManager.prototype = Object.create(LGraphManager.prototype);\n          for (var prop in LGraphManager) {\n            CoSEGraphManager[prop] = LGraphManager[prop];\n          }\n          module.exports = CoSEGraphManager;\n\n          /***/\n        },\n\n        /***/765: /***/(module, __unused_webpack_exports, __webpack_require__) => {\n          var FDLayout = __webpack_require__(551).FDLayout;\n          var CoSEGraphManager = __webpack_require__(578);\n          var CoSEGraph = __webpack_require__(880);\n          var CoSENode = __webpack_require__(991);\n          var CoSEEdge = __webpack_require__(767);\n          var CoSEConstants = __webpack_require__(806);\n          var ConstraintHandler = __webpack_require__(902);\n          var FDLayoutConstants = __webpack_require__(551).FDLayoutConstants;\n          var LayoutConstants = __webpack_require__(551).LayoutConstants;\n          var Point = __webpack_require__(551).Point;\n          var PointD = __webpack_require__(551).PointD;\n          var DimensionD = __webpack_require__(551).DimensionD;\n          var Layout = __webpack_require__(551).Layout;\n          var Integer = __webpack_require__(551).Integer;\n          var IGeometry = __webpack_require__(551).IGeometry;\n          var LGraph = __webpack_require__(551).LGraph;\n          var Transform = __webpack_require__(551).Transform;\n          var LinkedList = __webpack_require__(551).LinkedList;\n          function CoSELayout() {\n            FDLayout.call(this);\n            this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled\n            this.constraints = {}; // keep layout constraints\n          }\n\n          CoSELayout.prototype = Object.create(FDLayout.prototype);\n          for (var prop in FDLayout) {\n            CoSELayout[prop] = FDLayout[prop];\n          }\n          CoSELayout.prototype.newGraphManager = function () {\n            var gm = new CoSEGraphManager(this);\n            this.graphManager = gm;\n            return gm;\n          };\n          CoSELayout.prototype.newGraph = function (vGraph) {\n            return new CoSEGraph(null, this.graphManager, vGraph);\n          };\n          CoSELayout.prototype.newNode = function (vNode) {\n            return new CoSENode(this.graphManager, vNode);\n          };\n          CoSELayout.prototype.newEdge = function (vEdge) {\n            return new CoSEEdge(null, null, vEdge);\n          };\n          CoSELayout.prototype.initParameters = function () {\n            FDLayout.prototype.initParameters.call(this, arguments);\n            if (!this.isSubLayout) {\n              if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10) {\n                this.idealEdgeLength = 10;\n              } else {\n                this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;\n              }\n              this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n              this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n              this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n              this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n              this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n\n              // variables for tree reduction support\n              this.prunedNodesAll = [];\n              this.growTreeIterations = 0;\n              this.afterGrowthIterations = 0;\n              this.isTreeGrowing = false;\n              this.isGrowthFinished = false;\n            }\n          };\n\n          // This method is used to set CoSE related parameters used by spring embedder.\n          CoSELayout.prototype.initSpringEmbedder = function () {\n            FDLayout.prototype.initSpringEmbedder.call(this);\n\n            // variables for cooling\n            this.coolingCycle = 0;\n            this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;\n            this.finalTemperature = 0.04;\n            this.coolingAdjuster = 1;\n          };\n          CoSELayout.prototype.layout = function () {\n            var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n            if (createBendsAsNeeded) {\n              this.createBendpoints();\n              this.graphManager.resetAllEdges();\n            }\n            this.level = 0;\n            return this.classicLayout();\n          };\n          CoSELayout.prototype.classicLayout = function () {\n            this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();\n            this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);\n            this.calcNoOfChildrenForAllNodes();\n            this.graphManager.calcLowestCommonAncestors();\n            this.graphManager.calcInclusionTreeDepths();\n            this.graphManager.getRoot().calcEstimatedSize();\n            this.calcIdealEdgeLengths();\n            if (!this.incremental) {\n              var forest = this.getFlatForest();\n\n              // The graph associated with this layout is flat and a forest\n              if (forest.length > 0) {\n                this.positionNodesRadially(forest);\n              }\n              // The graph associated with this layout is not flat or a forest\n              else {\n                // Reduce the trees when incremental mode is not enabled and graph is not a forest \n                this.reduceTrees();\n                // Update nodes that gravity will be applied\n                this.graphManager.resetAllNodesToApplyGravitation();\n                var allNodes = new Set(this.getAllNodes());\n                var intersection = this.nodesWithGravity.filter(function (x) {\n                  return allNodes.has(x);\n                });\n                this.graphManager.setAllNodesToApplyGravitation(intersection);\n                this.positionNodesRandomly();\n              }\n            } else {\n              if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {\n                // Reduce the trees in incremental mode if only this constant is set to true \n                this.reduceTrees();\n                // Update nodes that gravity will be applied\n                this.graphManager.resetAllNodesToApplyGravitation();\n                var allNodes = new Set(this.getAllNodes());\n                var intersection = this.nodesWithGravity.filter(function (x) {\n                  return allNodes.has(x);\n                });\n                this.graphManager.setAllNodesToApplyGravitation(intersection);\n              }\n            }\n            if (Object.keys(this.constraints).length > 0) {\n              ConstraintHandler.handleConstraints(this);\n              this.initConstraintVariables();\n            }\n            this.initSpringEmbedder();\n            if (CoSEConstants.APPLY_LAYOUT) {\n              this.runSpringEmbedder();\n            }\n            return true;\n          };\n          CoSELayout.prototype.tick = function () {\n            this.totalIterations++;\n            if (this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) {\n              if (this.prunedNodesAll.length > 0) {\n                this.isTreeGrowing = true;\n              } else {\n                return true;\n              }\n            }\n            if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {\n              if (this.isConverged()) {\n                if (this.prunedNodesAll.length > 0) {\n                  this.isTreeGrowing = true;\n                } else {\n                  return true;\n                }\n              }\n              this.coolingCycle++;\n              if (this.layoutQuality == 0) {\n                // quality - \"draft\"\n                this.coolingAdjuster = this.coolingCycle;\n              } else if (this.layoutQuality == 1) {\n                // quality - \"default\"\n                this.coolingAdjuster = this.coolingCycle / 3;\n              }\n\n              // cooling schedule is based on http://www.btluke.com/simanf1.html -> cooling schedule 3\n              this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);\n              this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));\n            }\n            // Operations while tree is growing again \n            if (this.isTreeGrowing) {\n              if (this.growTreeIterations % 10 == 0) {\n                if (this.prunedNodesAll.length > 0) {\n                  this.graphManager.updateBounds();\n                  this.updateGrid();\n                  this.growTree(this.prunedNodesAll);\n                  // Update nodes that gravity will be applied\n                  this.graphManager.resetAllNodesToApplyGravitation();\n                  var allNodes = new Set(this.getAllNodes());\n                  var intersection = this.nodesWithGravity.filter(function (x) {\n                    return allNodes.has(x);\n                  });\n                  this.graphManager.setAllNodesToApplyGravitation(intersection);\n                  this.graphManager.updateBounds();\n                  this.updateGrid();\n                  if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2;else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n                } else {\n                  this.isTreeGrowing = false;\n                  this.isGrowthFinished = true;\n                }\n              }\n              this.growTreeIterations++;\n            }\n            // Operations after growth is finished\n            if (this.isGrowthFinished) {\n              if (this.isConverged()) {\n                return true;\n              }\n              if (this.afterGrowthIterations % 10 == 0) {\n                this.graphManager.updateBounds();\n                this.updateGrid();\n              }\n              if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2 * ((100 - this.afterGrowthIterations) / 100);else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);\n              this.afterGrowthIterations++;\n            }\n            var gridUpdateAllowed = !this.isTreeGrowing && !this.isGrowthFinished;\n            var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;\n            this.totalDisplacement = 0;\n            this.graphManager.updateBounds();\n            this.calcSpringForces();\n            this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);\n            this.calcGravitationalForces();\n            this.moveNodes();\n            this.animate();\n            return false; // Layout is not ended yet return false\n          };\n\n          CoSELayout.prototype.getPositionsData = function () {\n            var allNodes = this.graphManager.getAllNodes();\n            var pData = {};\n            for (var i = 0; i < allNodes.length; i++) {\n              var rect = allNodes[i].rect;\n              var id = allNodes[i].id;\n              pData[id] = {\n                id: id,\n                x: rect.getCenterX(),\n                y: rect.getCenterY(),\n                w: rect.width,\n                h: rect.height\n              };\n            }\n            return pData;\n          };\n          CoSELayout.prototype.runSpringEmbedder = function () {\n            this.initialAnimationPeriod = 25;\n            this.animationPeriod = this.initialAnimationPeriod;\n            var layoutEnded = false;\n\n            // If aminate option is 'during' signal that layout is supposed to start iterating\n            if (FDLayoutConstants.ANIMATE === 'during') {\n              this.emit('layoutstarted');\n            } else {\n              // If aminate option is 'during' tick() function will be called on index.js\n              while (!layoutEnded) {\n                layoutEnded = this.tick();\n              }\n              this.graphManager.updateBounds();\n            }\n          };\n\n          // overrides moveNodes method in FDLayout\n          CoSELayout.prototype.moveNodes = function () {\n            var lNodes = this.getAllNodes();\n            var node;\n\n            // calculate displacement for each node \n            for (var i = 0; i < lNodes.length; i++) {\n              node = lNodes[i];\n              node.calculateDisplacement();\n            }\n            if (Object.keys(this.constraints).length > 0) {\n              this.updateDisplacements();\n            }\n\n            // move each node\n            for (var i = 0; i < lNodes.length; i++) {\n              node = lNodes[i];\n              node.move();\n            }\n          };\n\n          // constraint related methods: initConstraintVariables and updateDisplacements\n\n          // initialize constraint related variables\n          CoSELayout.prototype.initConstraintVariables = function () {\n            var self = this;\n            this.idToNodeMap = new Map();\n            this.fixedNodeSet = new Set();\n            var allNodes = this.graphManager.getAllNodes();\n\n            // fill idToNodeMap\n            for (var i = 0; i < allNodes.length; i++) {\n              var node = allNodes[i];\n              this.idToNodeMap.set(node.id, node);\n            }\n\n            // calculate fixed node weight for given compound node\n            var calculateCompoundWeight = function calculateCompoundWeight(compoundNode) {\n              var nodes = compoundNode.getChild().getNodes();\n              var node;\n              var fixedNodeWeight = 0;\n              for (var i = 0; i < nodes.length; i++) {\n                node = nodes[i];\n                if (node.getChild() == null) {\n                  if (self.fixedNodeSet.has(node.id)) {\n                    fixedNodeWeight += 100;\n                  }\n                } else {\n                  fixedNodeWeight += calculateCompoundWeight(node);\n                }\n              }\n              return fixedNodeWeight;\n            };\n            if (this.constraints.fixedNodeConstraint) {\n              // fill fixedNodeSet\n              this.constraints.fixedNodeConstraint.forEach(function (nodeData) {\n                self.fixedNodeSet.add(nodeData.nodeId);\n              });\n\n              // assign fixed node weights to compounds if they contain fixed nodes\n              var allNodes = this.graphManager.getAllNodes();\n              var node;\n              for (var i = 0; i < allNodes.length; i++) {\n                node = allNodes[i];\n                if (node.getChild() != null) {\n                  var fixedNodeWeight = calculateCompoundWeight(node);\n                  if (fixedNodeWeight > 0) {\n                    node.fixedNodeWeight = fixedNodeWeight;\n                  }\n                }\n              }\n            }\n            if (this.constraints.relativePlacementConstraint) {\n              var nodeToDummyForVerticalAlignment = new Map();\n              var nodeToDummyForHorizontalAlignment = new Map();\n              this.dummyToNodeForVerticalAlignment = new Map();\n              this.dummyToNodeForHorizontalAlignment = new Map();\n              this.fixedNodesOnHorizontal = new Set();\n              this.fixedNodesOnVertical = new Set();\n\n              // fill maps and sets\n              this.fixedNodeSet.forEach(function (nodeId) {\n                self.fixedNodesOnHorizontal.add(nodeId);\n                self.fixedNodesOnVertical.add(nodeId);\n              });\n              if (this.constraints.alignmentConstraint) {\n                if (this.constraints.alignmentConstraint.vertical) {\n                  var verticalAlignment = this.constraints.alignmentConstraint.vertical;\n                  for (var i = 0; i < verticalAlignment.length; i++) {\n                    this.dummyToNodeForVerticalAlignment.set(\"dummy\" + i, []);\n                    verticalAlignment[i].forEach(function (nodeId) {\n                      nodeToDummyForVerticalAlignment.set(nodeId, \"dummy\" + i);\n                      self.dummyToNodeForVerticalAlignment.get(\"dummy\" + i).push(nodeId);\n                      if (self.fixedNodeSet.has(nodeId)) {\n                        self.fixedNodesOnHorizontal.add(\"dummy\" + i);\n                      }\n                    });\n                  }\n                }\n                if (this.constraints.alignmentConstraint.horizontal) {\n                  var horizontalAlignment = this.constraints.alignmentConstraint.horizontal;\n                  for (var i = 0; i < horizontalAlignment.length; i++) {\n                    this.dummyToNodeForHorizontalAlignment.set(\"dummy\" + i, []);\n                    horizontalAlignment[i].forEach(function (nodeId) {\n                      nodeToDummyForHorizontalAlignment.set(nodeId, \"dummy\" + i);\n                      self.dummyToNodeForHorizontalAlignment.get(\"dummy\" + i).push(nodeId);\n                      if (self.fixedNodeSet.has(nodeId)) {\n                        self.fixedNodesOnVertical.add(\"dummy\" + i);\n                      }\n                    });\n                  }\n                }\n              }\n              if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {\n                this.shuffle = function (array) {\n                  var j, x, i;\n                  for (i = array.length - 1; i >= 2 * array.length / 3; i--) {\n                    j = Math.floor(Math.random() * (i + 1));\n                    x = array[i];\n                    array[i] = array[j];\n                    array[j] = x;\n                  }\n                  return array;\n                };\n                this.nodesInRelativeHorizontal = [];\n                this.nodesInRelativeVertical = [];\n                this.nodeToRelativeConstraintMapHorizontal = new Map();\n                this.nodeToRelativeConstraintMapVertical = new Map();\n                this.nodeToTempPositionMapHorizontal = new Map();\n                this.nodeToTempPositionMapVertical = new Map();\n\n                // fill arrays and maps\n                this.constraints.relativePlacementConstraint.forEach(function (constraint) {\n                  if (constraint.left) {\n                    var nodeIdLeft = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;\n                    var nodeIdRight = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;\n                    if (!self.nodesInRelativeHorizontal.includes(nodeIdLeft)) {\n                      self.nodesInRelativeHorizontal.push(nodeIdLeft);\n                      self.nodeToRelativeConstraintMapHorizontal.set(nodeIdLeft, []);\n                      if (self.dummyToNodeForVerticalAlignment.has(nodeIdLeft)) {\n                        self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdLeft)[0]).getCenterX());\n                      } else {\n                        self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(nodeIdLeft).getCenterX());\n                      }\n                    }\n                    if (!self.nodesInRelativeHorizontal.includes(nodeIdRight)) {\n                      self.nodesInRelativeHorizontal.push(nodeIdRight);\n                      self.nodeToRelativeConstraintMapHorizontal.set(nodeIdRight, []);\n                      if (self.dummyToNodeForVerticalAlignment.has(nodeIdRight)) {\n                        self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdRight)[0]).getCenterX());\n                      } else {\n                        self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(nodeIdRight).getCenterX());\n                      }\n                    }\n                    self.nodeToRelativeConstraintMapHorizontal.get(nodeIdLeft).push({\n                      right: nodeIdRight,\n                      gap: constraint.gap\n                    });\n                    self.nodeToRelativeConstraintMapHorizontal.get(nodeIdRight).push({\n                      left: nodeIdLeft,\n                      gap: constraint.gap\n                    });\n                  } else {\n                    var nodeIdTop = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;\n                    var nodeIdBottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;\n                    if (!self.nodesInRelativeVertical.includes(nodeIdTop)) {\n                      self.nodesInRelativeVertical.push(nodeIdTop);\n                      self.nodeToRelativeConstraintMapVertical.set(nodeIdTop, []);\n                      if (self.dummyToNodeForHorizontalAlignment.has(nodeIdTop)) {\n                        self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdTop)[0]).getCenterY());\n                      } else {\n                        self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(nodeIdTop).getCenterY());\n                      }\n                    }\n                    if (!self.nodesInRelativeVertical.includes(nodeIdBottom)) {\n                      self.nodesInRelativeVertical.push(nodeIdBottom);\n                      self.nodeToRelativeConstraintMapVertical.set(nodeIdBottom, []);\n                      if (self.dummyToNodeForHorizontalAlignment.has(nodeIdBottom)) {\n                        self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdBottom)[0]).getCenterY());\n                      } else {\n                        self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(nodeIdBottom).getCenterY());\n                      }\n                    }\n                    self.nodeToRelativeConstraintMapVertical.get(nodeIdTop).push({\n                      bottom: nodeIdBottom,\n                      gap: constraint.gap\n                    });\n                    self.nodeToRelativeConstraintMapVertical.get(nodeIdBottom).push({\n                      top: nodeIdTop,\n                      gap: constraint.gap\n                    });\n                  }\n                });\n              } else {\n                var subGraphOnHorizontal = new Map(); // subgraph from vertical RP constraints\n                var subGraphOnVertical = new Map(); // subgraph from vertical RP constraints\n\n                // construct subgraphs from relative placement constraints \n                this.constraints.relativePlacementConstraint.forEach(function (constraint) {\n                  if (constraint.left) {\n                    var left = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;\n                    var right = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;\n                    if (subGraphOnHorizontal.has(left)) {\n                      subGraphOnHorizontal.get(left).push(right);\n                    } else {\n                      subGraphOnHorizontal.set(left, [right]);\n                    }\n                    if (subGraphOnHorizontal.has(right)) {\n                      subGraphOnHorizontal.get(right).push(left);\n                    } else {\n                      subGraphOnHorizontal.set(right, [left]);\n                    }\n                  } else {\n                    var top = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;\n                    var bottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;\n                    if (subGraphOnVertical.has(top)) {\n                      subGraphOnVertical.get(top).push(bottom);\n                    } else {\n                      subGraphOnVertical.set(top, [bottom]);\n                    }\n                    if (subGraphOnVertical.has(bottom)) {\n                      subGraphOnVertical.get(bottom).push(top);\n                    } else {\n                      subGraphOnVertical.set(bottom, [top]);\n                    }\n                  }\n                });\n\n                // function to construct components from a given graph \n                // also returns an array that keeps whether each component contains fixed node\n                var constructComponents = function constructComponents(graph, fixedNodes) {\n                  var components = [];\n                  var isFixed = [];\n                  var queue = new LinkedList();\n                  var visited = new Set();\n                  var count = 0;\n                  graph.forEach(function (value, key) {\n                    if (!visited.has(key)) {\n                      components[count] = [];\n                      isFixed[count] = false;\n                      var currentNode = key;\n                      queue.push(currentNode);\n                      visited.add(currentNode);\n                      components[count].push(currentNode);\n                      while (queue.length != 0) {\n                        currentNode = queue.shift();\n                        if (fixedNodes.has(currentNode)) {\n                          isFixed[count] = true;\n                        }\n                        var neighbors = graph.get(currentNode);\n                        neighbors.forEach(function (neighbor) {\n                          if (!visited.has(neighbor)) {\n                            queue.push(neighbor);\n                            visited.add(neighbor);\n                            components[count].push(neighbor);\n                          }\n                        });\n                      }\n                      count++;\n                    }\n                  });\n                  return {\n                    components: components,\n                    isFixed: isFixed\n                  };\n                };\n                var resultOnHorizontal = constructComponents(subGraphOnHorizontal, self.fixedNodesOnHorizontal);\n                this.componentsOnHorizontal = resultOnHorizontal.components;\n                this.fixedComponentsOnHorizontal = resultOnHorizontal.isFixed;\n                var resultOnVertical = constructComponents(subGraphOnVertical, self.fixedNodesOnVertical);\n                this.componentsOnVertical = resultOnVertical.components;\n                this.fixedComponentsOnVertical = resultOnVertical.isFixed;\n              }\n            }\n          };\n\n          // updates node displacements based on constraints\n          CoSELayout.prototype.updateDisplacements = function () {\n            var self = this;\n            if (this.constraints.fixedNodeConstraint) {\n              this.constraints.fixedNodeConstraint.forEach(function (nodeData) {\n                var fixedNode = self.idToNodeMap.get(nodeData.nodeId);\n                fixedNode.displacementX = 0;\n                fixedNode.displacementY = 0;\n              });\n            }\n            if (this.constraints.alignmentConstraint) {\n              if (this.constraints.alignmentConstraint.vertical) {\n                var allVerticalAlignments = this.constraints.alignmentConstraint.vertical;\n                for (var i = 0; i < allVerticalAlignments.length; i++) {\n                  var totalDisplacementX = 0;\n                  for (var j = 0; j < allVerticalAlignments[i].length; j++) {\n                    if (this.fixedNodeSet.has(allVerticalAlignments[i][j])) {\n                      totalDisplacementX = 0;\n                      break;\n                    }\n                    totalDisplacementX += this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX;\n                  }\n                  var averageDisplacementX = totalDisplacementX / allVerticalAlignments[i].length;\n                  for (var j = 0; j < allVerticalAlignments[i].length; j++) {\n                    this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX = averageDisplacementX;\n                  }\n                }\n              }\n              if (this.constraints.alignmentConstraint.horizontal) {\n                var allHorizontalAlignments = this.constraints.alignmentConstraint.horizontal;\n                for (var i = 0; i < allHorizontalAlignments.length; i++) {\n                  var totalDisplacementY = 0;\n                  for (var j = 0; j < allHorizontalAlignments[i].length; j++) {\n                    if (this.fixedNodeSet.has(allHorizontalAlignments[i][j])) {\n                      totalDisplacementY = 0;\n                      break;\n                    }\n                    totalDisplacementY += this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY;\n                  }\n                  var averageDisplacementY = totalDisplacementY / allHorizontalAlignments[i].length;\n                  for (var j = 0; j < allHorizontalAlignments[i].length; j++) {\n                    this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY = averageDisplacementY;\n                  }\n                }\n              }\n            }\n            if (this.constraints.relativePlacementConstraint) {\n              if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {\n                // shuffle array to randomize node processing order\n                if (this.totalIterations % 10 == 0) {\n                  this.shuffle(this.nodesInRelativeHorizontal);\n                  this.shuffle(this.nodesInRelativeVertical);\n                }\n                this.nodesInRelativeHorizontal.forEach(function (nodeId) {\n                  if (!self.fixedNodesOnHorizontal.has(nodeId)) {\n                    var displacement = 0;\n                    if (self.dummyToNodeForVerticalAlignment.has(nodeId)) {\n                      displacement = self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeId)[0]).displacementX;\n                    } else {\n                      displacement = self.idToNodeMap.get(nodeId).displacementX;\n                    }\n                    self.nodeToRelativeConstraintMapHorizontal.get(nodeId).forEach(function (constraint) {\n                      if (constraint.right) {\n                        var diff = self.nodeToTempPositionMapHorizontal.get(constraint.right) - self.nodeToTempPositionMapHorizontal.get(nodeId) - displacement;\n                        if (diff < constraint.gap) {\n                          displacement -= constraint.gap - diff;\n                        }\n                      } else {\n                        var diff = self.nodeToTempPositionMapHorizontal.get(nodeId) - self.nodeToTempPositionMapHorizontal.get(constraint.left) + displacement;\n                        if (diff < constraint.gap) {\n                          displacement += constraint.gap - diff;\n                        }\n                      }\n                    });\n                    self.nodeToTempPositionMapHorizontal.set(nodeId, self.nodeToTempPositionMapHorizontal.get(nodeId) + displacement);\n                    if (self.dummyToNodeForVerticalAlignment.has(nodeId)) {\n                      self.dummyToNodeForVerticalAlignment.get(nodeId).forEach(function (nodeId) {\n                        self.idToNodeMap.get(nodeId).displacementX = displacement;\n                      });\n                    } else {\n                      self.idToNodeMap.get(nodeId).displacementX = displacement;\n                    }\n                  }\n                });\n                this.nodesInRelativeVertical.forEach(function (nodeId) {\n                  if (!self.fixedNodesOnHorizontal.has(nodeId)) {\n                    var displacement = 0;\n                    if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) {\n                      displacement = self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeId)[0]).displacementY;\n                    } else {\n                      displacement = self.idToNodeMap.get(nodeId).displacementY;\n                    }\n                    self.nodeToRelativeConstraintMapVertical.get(nodeId).forEach(function (constraint) {\n                      if (constraint.bottom) {\n                        var diff = self.nodeToTempPositionMapVertical.get(constraint.bottom) - self.nodeToTempPositionMapVertical.get(nodeId) - displacement;\n                        if (diff < constraint.gap) {\n                          displacement -= constraint.gap - diff;\n                        }\n                      } else {\n                        var diff = self.nodeToTempPositionMapVertical.get(nodeId) - self.nodeToTempPositionMapVertical.get(constraint.top) + displacement;\n                        if (diff < constraint.gap) {\n                          displacement += constraint.gap - diff;\n                        }\n                      }\n                    });\n                    self.nodeToTempPositionMapVertical.set(nodeId, self.nodeToTempPositionMapVertical.get(nodeId) + displacement);\n                    if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) {\n                      self.dummyToNodeForHorizontalAlignment.get(nodeId).forEach(function (nodeId) {\n                        self.idToNodeMap.get(nodeId).displacementY = displacement;\n                      });\n                    } else {\n                      self.idToNodeMap.get(nodeId).displacementY = displacement;\n                    }\n                  }\n                });\n              } else {\n                for (var i = 0; i < this.componentsOnHorizontal.length; i++) {\n                  var component = this.componentsOnHorizontal[i];\n                  if (this.fixedComponentsOnHorizontal[i]) {\n                    for (var j = 0; j < component.length; j++) {\n                      if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n                        this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function (nodeId) {\n                          self.idToNodeMap.get(nodeId).displacementX = 0;\n                        });\n                      } else {\n                        this.idToNodeMap.get(component[j]).displacementX = 0;\n                      }\n                    }\n                  } else {\n                    var sum = 0;\n                    var count = 0;\n                    for (var j = 0; j < component.length; j++) {\n                      if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n                        var actualNodes = this.dummyToNodeForVerticalAlignment.get(component[j]);\n                        sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementX;\n                        count += actualNodes.length;\n                      } else {\n                        sum += this.idToNodeMap.get(component[j]).displacementX;\n                        count++;\n                      }\n                    }\n                    var averageDisplacement = sum / count;\n                    for (var j = 0; j < component.length; j++) {\n                      if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n                        this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function (nodeId) {\n                          self.idToNodeMap.get(nodeId).displacementX = averageDisplacement;\n                        });\n                      } else {\n                        this.idToNodeMap.get(component[j]).displacementX = averageDisplacement;\n                      }\n                    }\n                  }\n                }\n                for (var i = 0; i < this.componentsOnVertical.length; i++) {\n                  var component = this.componentsOnVertical[i];\n                  if (this.fixedComponentsOnVertical[i]) {\n                    for (var j = 0; j < component.length; j++) {\n                      if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n                        this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function (nodeId) {\n                          self.idToNodeMap.get(nodeId).displacementY = 0;\n                        });\n                      } else {\n                        this.idToNodeMap.get(component[j]).displacementY = 0;\n                      }\n                    }\n                  } else {\n                    var sum = 0;\n                    var count = 0;\n                    for (var j = 0; j < component.length; j++) {\n                      if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n                        var actualNodes = this.dummyToNodeForHorizontalAlignment.get(component[j]);\n                        sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementY;\n                        count += actualNodes.length;\n                      } else {\n                        sum += this.idToNodeMap.get(component[j]).displacementY;\n                        count++;\n                      }\n                    }\n                    var averageDisplacement = sum / count;\n                    for (var j = 0; j < component.length; j++) {\n                      if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n                        this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function (nodeId) {\n                          self.idToNodeMap.get(nodeId).displacementY = averageDisplacement;\n                        });\n                      } else {\n                        this.idToNodeMap.get(component[j]).displacementY = averageDisplacement;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          };\n          CoSELayout.prototype.calculateNodesToApplyGravitationTo = function () {\n            var nodeList = [];\n            var graph;\n            var graphs = this.graphManager.getGraphs();\n            var size = graphs.length;\n            var i;\n            for (i = 0; i < size; i++) {\n              graph = graphs[i];\n              graph.updateConnected();\n              if (!graph.isConnected) {\n                nodeList = nodeList.concat(graph.getNodes());\n              }\n            }\n            return nodeList;\n          };\n          CoSELayout.prototype.createBendpoints = function () {\n            var edges = [];\n            edges = edges.concat(this.graphManager.getAllEdges());\n            var visited = new Set();\n            var i;\n            for (i = 0; i < edges.length; i++) {\n              var edge = edges[i];\n              if (!visited.has(edge)) {\n                var source = edge.getSource();\n                var target = edge.getTarget();\n                if (source == target) {\n                  edge.getBendpoints().push(new PointD());\n                  edge.getBendpoints().push(new PointD());\n                  this.createDummyNodesForBendpoints(edge);\n                  visited.add(edge);\n                } else {\n                  var edgeList = [];\n                  edgeList = edgeList.concat(source.getEdgeListToNode(target));\n                  edgeList = edgeList.concat(target.getEdgeListToNode(source));\n                  if (!visited.has(edgeList[0])) {\n                    if (edgeList.length > 1) {\n                      var k;\n                      for (k = 0; k < edgeList.length; k++) {\n                        var multiEdge = edgeList[k];\n                        multiEdge.getBendpoints().push(new PointD());\n                        this.createDummyNodesForBendpoints(multiEdge);\n                      }\n                    }\n                    edgeList.forEach(function (edge) {\n                      visited.add(edge);\n                    });\n                  }\n                }\n              }\n              if (visited.size == edges.length) {\n                break;\n              }\n            }\n          };\n          CoSELayout.prototype.positionNodesRadially = function (forest) {\n            // We tile the trees to a grid row by row; first tree starts at (0,0)\n            var currentStartingPoint = new Point(0, 0);\n            var numberOfColumns = Math.ceil(Math.sqrt(forest.length));\n            var height = 0;\n            var currentY = 0;\n            var currentX = 0;\n            var point = new PointD(0, 0);\n            for (var i = 0; i < forest.length; i++) {\n              if (i % numberOfColumns == 0) {\n                // Start of a new row, make the x coordinate 0, increment the\n                // y coordinate with the max height of the previous row\n                currentX = 0;\n                currentY = height;\n                if (i != 0) {\n                  currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;\n                }\n                height = 0;\n              }\n              var tree = forest[i];\n\n              // Find the center of the tree\n              var centerNode = Layout.findCenterOfTree(tree);\n\n              // Set the staring point of the next tree\n              currentStartingPoint.x = currentX;\n              currentStartingPoint.y = currentY;\n\n              // Do a radial layout starting with the center\n              point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);\n              if (point.y > height) {\n                height = Math.floor(point.y);\n              }\n              currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);\n            }\n            this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));\n          };\n          CoSELayout.radialLayout = function (tree, centerNode, startingPoint) {\n            var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);\n            CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);\n            var bounds = LGraph.calculateBounds(tree);\n            var transform = new Transform();\n            transform.setDeviceOrgX(bounds.getMinX());\n            transform.setDeviceOrgY(bounds.getMinY());\n            transform.setWorldOrgX(startingPoint.x);\n            transform.setWorldOrgY(startingPoint.y);\n            for (var i = 0; i < tree.length; i++) {\n              var node = tree[i];\n              node.transform(transform);\n            }\n            var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());\n            return transform.inverseTransformPoint(bottomRight);\n          };\n          CoSELayout.branchRadialLayout = function (node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {\n            // First, position this node by finding its angle.\n            var halfInterval = (endAngle - startAngle + 1) / 2;\n            if (halfInterval < 0) {\n              halfInterval += 180;\n            }\n            var nodeAngle = (halfInterval + startAngle) % 360;\n            var teta = nodeAngle * IGeometry.TWO_PI / 360;\n\n            // Make polar to java cordinate conversion.\n            var cos_teta = Math.cos(teta);\n            var x_ = distance * Math.cos(teta);\n            var y_ = distance * Math.sin(teta);\n            node.setCenter(x_, y_);\n\n            // Traverse all neighbors of this node and recursively call this\n            // function.\n            var neighborEdges = [];\n            neighborEdges = neighborEdges.concat(node.getEdges());\n            var childCount = neighborEdges.length;\n            if (parentOfNode != null) {\n              childCount--;\n            }\n            var branchCount = 0;\n            var incEdgesCount = neighborEdges.length;\n            var startIndex;\n            var edges = node.getEdgesBetween(parentOfNode);\n\n            // If there are multiple edges, prune them until there remains only one\n            // edge.\n            while (edges.length > 1) {\n              //neighborEdges.remove(edges.remove(0));\n              var temp = edges[0];\n              edges.splice(0, 1);\n              var index = neighborEdges.indexOf(temp);\n              if (index >= 0) {\n                neighborEdges.splice(index, 1);\n              }\n              incEdgesCount--;\n              childCount--;\n            }\n            if (parentOfNode != null) {\n              //assert edges.length == 1;\n              startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;\n            } else {\n              startIndex = 0;\n            }\n            var stepAngle = Math.abs(endAngle - startAngle) / childCount;\n            for (var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount) {\n              var currentNeighbor = neighborEdges[i].getOtherEnd(node);\n\n              // Don't back traverse to root node in current tree.\n              if (currentNeighbor == parentOfNode) {\n                continue;\n              }\n              var childStartAngle = (startAngle + branchCount * stepAngle) % 360;\n              var childEndAngle = (childStartAngle + stepAngle) % 360;\n              CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);\n              branchCount++;\n            }\n          };\n          CoSELayout.maxDiagonalInTree = function (tree) {\n            var maxDiagonal = Integer.MIN_VALUE;\n            for (var i = 0; i < tree.length; i++) {\n              var node = tree[i];\n              var diagonal = node.getDiagonal();\n              if (diagonal > maxDiagonal) {\n                maxDiagonal = diagonal;\n              }\n            }\n            return maxDiagonal;\n          };\n          CoSELayout.prototype.calcRepulsionRange = function () {\n            // formula is 2 x (level + 1) x idealEdgeLength\n            return 2 * (this.level + 1) * this.idealEdgeLength;\n          };\n\n          // Tiling methods\n\n          // Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id's\n          CoSELayout.prototype.groupZeroDegreeMembers = function () {\n            var self = this;\n            // array of [parent_id x oneDegreeNode_id]\n            var tempMemberGroups = {}; // A temporary map of parent node and its zero degree members\n            this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled\n            this.idToDummyNode = {}; // A map of id to dummy node \n\n            var zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled\n            var allNodes = this.graphManager.getAllNodes();\n\n            // Fill zero degree list\n            for (var i = 0; i < allNodes.length; i++) {\n              var node = allNodes[i];\n              var parent = node.getParent();\n              // If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list\n              if (this.getNodeDegreeWithChildren(node) === 0 && (parent.id == undefined || !this.getToBeTiled(parent))) {\n                zeroDegree.push(node);\n              }\n            }\n\n            // Create a map of parent node and its zero degree members\n            for (var i = 0; i < zeroDegree.length; i++) {\n              var node = zeroDegree[i]; // Zero degree node itself\n              var p_id = node.getParent().id; // Parent id\n\n              if (typeof tempMemberGroups[p_id] === \"undefined\") tempMemberGroups[p_id] = [];\n              tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups\n            }\n\n            // If there are at least two nodes at a level, create a dummy compound for them\n            Object.keys(tempMemberGroups).forEach(function (p_id) {\n              if (tempMemberGroups[p_id].length > 1) {\n                var dummyCompoundId = \"DummyCompound_\" + p_id; // The id of dummy compound which will be created soon\n                self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups\n\n                var parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound\n\n                // Create a dummy compound with calculated id\n                var dummyCompound = new CoSENode(self.graphManager);\n                dummyCompound.id = dummyCompoundId;\n                dummyCompound.paddingLeft = parent.paddingLeft || 0;\n                dummyCompound.paddingRight = parent.paddingRight || 0;\n                dummyCompound.paddingBottom = parent.paddingBottom || 0;\n                dummyCompound.paddingTop = parent.paddingTop || 0;\n                self.idToDummyNode[dummyCompoundId] = dummyCompound;\n                var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);\n                var parentGraph = parent.getChild();\n\n                // Add dummy compound to parent the graph\n                parentGraph.add(dummyCompound);\n\n                // For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent\n                for (var i = 0; i < tempMemberGroups[p_id].length; i++) {\n                  var node = tempMemberGroups[p_id][i];\n                  parentGraph.remove(node);\n                  dummyParentGraph.add(node);\n                }\n              }\n            });\n          };\n          CoSELayout.prototype.clearCompounds = function () {\n            var childGraphMap = {};\n            var idToNode = {};\n\n            // Get compound ordering by finding the inner one first\n            this.performDFSOnCompounds();\n            for (var i = 0; i < this.compoundOrder.length; i++) {\n              idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];\n              childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes());\n\n              // Remove children of compounds\n              this.graphManager.remove(this.compoundOrder[i].getChild());\n              this.compoundOrder[i].child = null;\n            }\n            this.graphManager.resetAllNodes();\n\n            // Tile the removed children\n            this.tileCompoundMembers(childGraphMap, idToNode);\n          };\n          CoSELayout.prototype.clearZeroDegreeMembers = function () {\n            var self = this;\n            var tiledZeroDegreePack = this.tiledZeroDegreePack = [];\n            Object.keys(this.memberGroups).forEach(function (id) {\n              var compoundNode = self.idToDummyNode[id]; // Get the dummy compound\n\n              tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n              // Set the width and height of the dummy compound as calculated\n              compoundNode.rect.width = tiledZeroDegreePack[id].width;\n              compoundNode.rect.height = tiledZeroDegreePack[id].height;\n              compoundNode.setCenter(tiledZeroDegreePack[id].centerX, tiledZeroDegreePack[id].centerY);\n\n              // compound left and top margings for labels\n              // when node labels are included, these values may be set to different values below and are used in tilingPostLayout,\n              // otherwise they stay as zero\n              compoundNode.labelMarginLeft = 0;\n              compoundNode.labelMarginTop = 0;\n\n              // Update compound bounds considering its label properties and set label margins for left and top\n              if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n                var width = compoundNode.rect.width;\n                var height = compoundNode.rect.height;\n                if (compoundNode.labelWidth) {\n                  if (compoundNode.labelPosHorizontal == \"left\") {\n                    compoundNode.rect.x -= compoundNode.labelWidth;\n                    compoundNode.setWidth(width + compoundNode.labelWidth);\n                    compoundNode.labelMarginLeft = compoundNode.labelWidth;\n                  } else if (compoundNode.labelPosHorizontal == \"center\" && compoundNode.labelWidth > width) {\n                    compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;\n                    compoundNode.setWidth(compoundNode.labelWidth);\n                    compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;\n                  } else if (compoundNode.labelPosHorizontal == \"right\") {\n                    compoundNode.setWidth(width + compoundNode.labelWidth);\n                  }\n                }\n                if (compoundNode.labelHeight) {\n                  if (compoundNode.labelPosVertical == \"top\") {\n                    compoundNode.rect.y -= compoundNode.labelHeight;\n                    compoundNode.setHeight(height + compoundNode.labelHeight);\n                    compoundNode.labelMarginTop = compoundNode.labelHeight;\n                  } else if (compoundNode.labelPosVertical == \"center\" && compoundNode.labelHeight > height) {\n                    compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;\n                    compoundNode.setHeight(compoundNode.labelHeight);\n                    compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;\n                  } else if (compoundNode.labelPosVertical == \"bottom\") {\n                    compoundNode.setHeight(height + compoundNode.labelHeight);\n                  }\n                }\n              }\n            });\n          };\n          CoSELayout.prototype.repopulateCompounds = function () {\n            for (var i = this.compoundOrder.length - 1; i >= 0; i--) {\n              var lCompoundNode = this.compoundOrder[i];\n              var id = lCompoundNode.id;\n              var horizontalMargin = lCompoundNode.paddingLeft;\n              var verticalMargin = lCompoundNode.paddingTop;\n              var labelMarginLeft = lCompoundNode.labelMarginLeft;\n              var labelMarginTop = lCompoundNode.labelMarginTop;\n              this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);\n            }\n          };\n          CoSELayout.prototype.repopulateZeroDegreeMembers = function () {\n            var self = this;\n            var tiledPack = this.tiledZeroDegreePack;\n            Object.keys(tiledPack).forEach(function (id) {\n              var compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id\n              var horizontalMargin = compoundNode.paddingLeft;\n              var verticalMargin = compoundNode.paddingTop;\n              var labelMarginLeft = compoundNode.labelMarginLeft;\n              var labelMarginTop = compoundNode.labelMarginTop;\n\n              // Adjust the positions of nodes wrt its compound\n              self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);\n            });\n          };\n          CoSELayout.prototype.getToBeTiled = function (node) {\n            var id = node.id;\n            //firstly check the previous results\n            if (this.toBeTiled[id] != null) {\n              return this.toBeTiled[id];\n            }\n\n            //only compound nodes are to be tiled\n            var childGraph = node.getChild();\n            if (childGraph == null) {\n              this.toBeTiled[id] = false;\n              return false;\n            }\n            var children = childGraph.getNodes(); // Get the children nodes\n\n            //a compound node is not to be tiled if all of its compound children are not to be tiled\n            for (var i = 0; i < children.length; i++) {\n              var theChild = children[i];\n              if (this.getNodeDegree(theChild) > 0) {\n                this.toBeTiled[id] = false;\n                return false;\n              }\n\n              //pass the children not having the compound structure\n              if (theChild.getChild() == null) {\n                this.toBeTiled[theChild.id] = false;\n                continue;\n              }\n              if (!this.getToBeTiled(theChild)) {\n                this.toBeTiled[id] = false;\n                return false;\n              }\n            }\n            this.toBeTiled[id] = true;\n            return true;\n          };\n\n          // Get degree of a node depending of its edges and independent of its children\n          CoSELayout.prototype.getNodeDegree = function (node) {\n            var id = node.id;\n            var edges = node.getEdges();\n            var degree = 0;\n\n            // For the edges connected\n            for (var i = 0; i < edges.length; i++) {\n              var edge = edges[i];\n              if (edge.getSource().id !== edge.getTarget().id) {\n                degree = degree + 1;\n              }\n            }\n            return degree;\n          };\n\n          // Get degree of a node with its children\n          CoSELayout.prototype.getNodeDegreeWithChildren = function (node) {\n            var degree = this.getNodeDegree(node);\n            if (node.getChild() == null) {\n              return degree;\n            }\n            var children = node.getChild().getNodes();\n            for (var i = 0; i < children.length; i++) {\n              var child = children[i];\n              degree += this.getNodeDegreeWithChildren(child);\n            }\n            return degree;\n          };\n          CoSELayout.prototype.performDFSOnCompounds = function () {\n            this.compoundOrder = [];\n            this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());\n          };\n          CoSELayout.prototype.fillCompexOrderByDFS = function (children) {\n            for (var i = 0; i < children.length; i++) {\n              var child = children[i];\n              if (child.getChild() != null) {\n                this.fillCompexOrderByDFS(child.getChild().getNodes());\n              }\n              if (this.getToBeTiled(child)) {\n                this.compoundOrder.push(child);\n              }\n            }\n          };\n\n          /**\n          * This method places each zero degree member wrt given (x,y) coordinates (top left).\n          */\n          CoSELayout.prototype.adjustLocations = function (organization, x, y, compoundHorizontalMargin, compoundVerticalMargin, compoundLabelMarginLeft, compoundLabelMarginTop) {\n            x += compoundHorizontalMargin + compoundLabelMarginLeft;\n            y += compoundVerticalMargin + compoundLabelMarginTop;\n            var left = x;\n            for (var i = 0; i < organization.rows.length; i++) {\n              var row = organization.rows[i];\n              x = left;\n              var maxHeight = 0;\n              for (var j = 0; j < row.length; j++) {\n                var lnode = row[j];\n                lnode.rect.x = x; // + lnode.rect.width / 2;\n                lnode.rect.y = y; // + lnode.rect.height / 2;\n\n                x += lnode.rect.width + organization.horizontalPadding;\n                if (lnode.rect.height > maxHeight) maxHeight = lnode.rect.height;\n              }\n              y += maxHeight + organization.verticalPadding;\n            }\n          };\n          CoSELayout.prototype.tileCompoundMembers = function (childGraphMap, idToNode) {\n            var self = this;\n            this.tiledMemberPack = [];\n            Object.keys(childGraphMap).forEach(function (id) {\n              // Get the compound node\n              var compoundNode = idToNode[id];\n              self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n              compoundNode.rect.width = self.tiledMemberPack[id].width;\n              compoundNode.rect.height = self.tiledMemberPack[id].height;\n              compoundNode.setCenter(self.tiledMemberPack[id].centerX, self.tiledMemberPack[id].centerY);\n\n              // compound left and top margings for labels\n              // when node labels are included, these values may be set to different values below and are used in tilingPostLayout,\n              // otherwise they stay as zero\n              compoundNode.labelMarginLeft = 0;\n              compoundNode.labelMarginTop = 0;\n\n              // Update compound bounds considering its label properties and set label margins for left and top\n              if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n                var width = compoundNode.rect.width;\n                var height = compoundNode.rect.height;\n                if (compoundNode.labelWidth) {\n                  if (compoundNode.labelPosHorizontal == \"left\") {\n                    compoundNode.rect.x -= compoundNode.labelWidth;\n                    compoundNode.setWidth(width + compoundNode.labelWidth);\n                    compoundNode.labelMarginLeft = compoundNode.labelWidth;\n                  } else if (compoundNode.labelPosHorizontal == \"center\" && compoundNode.labelWidth > width) {\n                    compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;\n                    compoundNode.setWidth(compoundNode.labelWidth);\n                    compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;\n                  } else if (compoundNode.labelPosHorizontal == \"right\") {\n                    compoundNode.setWidth(width + compoundNode.labelWidth);\n                  }\n                }\n                if (compoundNode.labelHeight) {\n                  if (compoundNode.labelPosVertical == \"top\") {\n                    compoundNode.rect.y -= compoundNode.labelHeight;\n                    compoundNode.setHeight(height + compoundNode.labelHeight);\n                    compoundNode.labelMarginTop = compoundNode.labelHeight;\n                  } else if (compoundNode.labelPosVertical == \"center\" && compoundNode.labelHeight > height) {\n                    compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;\n                    compoundNode.setHeight(compoundNode.labelHeight);\n                    compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;\n                  } else if (compoundNode.labelPosVertical == \"bottom\") {\n                    compoundNode.setHeight(height + compoundNode.labelHeight);\n                  }\n                }\n              }\n            });\n          };\n          CoSELayout.prototype.tileNodes = function (nodes, minWidth) {\n            var horizontalOrg = this.tileNodesByFavoringDim(nodes, minWidth, true);\n            var verticalOrg = this.tileNodesByFavoringDim(nodes, minWidth, false);\n            var horizontalRatio = this.getOrgRatio(horizontalOrg);\n            var verticalRatio = this.getOrgRatio(verticalOrg);\n            var bestOrg;\n\n            // the best ratio is the one that is closer to 1 since the ratios are already normalized\n            // and the best organization is the one that has the best ratio\n            if (verticalRatio < horizontalRatio) {\n              bestOrg = verticalOrg;\n            } else {\n              bestOrg = horizontalOrg;\n            }\n            return bestOrg;\n          };\n\n          // get the width/height ratio of the organization that is normalized so that it will not be less than 1\n          CoSELayout.prototype.getOrgRatio = function (organization) {\n            // get dimensions and calculate the initial ratio\n            var width = organization.width;\n            var height = organization.height;\n            var ratio = width / height;\n\n            // if the initial ratio is less then 1 then inverse it\n            if (ratio < 1) {\n              ratio = 1 / ratio;\n            }\n\n            // return the normalized ratio\n            return ratio;\n          };\n\n          /*\n           * Calculates the ideal width for the rows. This method assumes that\n           * each node has the same sizes and calculates the ideal row width that\n           * approximates a square shaped complex accordingly. However, since nodes would\n           * have different sizes some rows would have different sizes and the resulting\n           * shape would not be an exact square.\n           */\n          CoSELayout.prototype.calcIdealRowWidth = function (members, favorHorizontalDim) {\n            // To approximate a square shaped complex we need to make complex width equal to complex height.\n            // To achieve this we need to solve the following equation system for hc:\n            // (x + bx) * hc - bx = (y + by) * vc - by, hc * vc = n\n            // where x is the avarage width of the nodes, y is the avarage height of nodes\n            // bx and by are the buffer sizes in horizontal and vertical dimensions accordingly,\n            // hc and vc are the number of rows in horizontal and vertical dimensions\n            // n is number of members.\n\n            var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n            var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n\n            // number of members\n            var membersSize = members.length;\n\n            // sum of the width of all members\n            var totalWidth = 0;\n\n            // sum of the height of all members\n            var totalHeight = 0;\n            var maxWidth = 0;\n\n            // traverse all members to calculate total width and total height and get the maximum members width\n            members.forEach(function (node) {\n              totalWidth += node.getWidth();\n              totalHeight += node.getHeight();\n              if (node.getWidth() > maxWidth) {\n                maxWidth = node.getWidth();\n              }\n            });\n\n            // average width of the members\n            var averageWidth = totalWidth / membersSize;\n\n            // average height of the members\n            var averageHeight = totalHeight / membersSize;\n\n            // solving the initial equation system for the hc yields the following second degree equation:\n            // hc^2 * (x+bx) + hc * (by - bx) - n * (y + by) = 0\n\n            // the delta value to solve the equation above for hc\n            var delta = Math.pow(verticalPadding - horizontalPadding, 2) + 4 * (averageWidth + horizontalPadding) * (averageHeight + verticalPadding) * membersSize;\n\n            // solve the equation using delta value to calculate the horizontal count\n            // that represents the number of nodes in an ideal row\n            var horizontalCountDouble = (horizontalPadding - verticalPadding + Math.sqrt(delta)) / (2 * (averageWidth + horizontalPadding));\n            // round the calculated horizontal count up or down according to the favored dimension\n            var horizontalCount;\n            if (favorHorizontalDim) {\n              horizontalCount = Math.ceil(horizontalCountDouble);\n              // if horizontalCount count is not a float value then both of rounding to floor and ceil\n              // will yield the same values. Instead of repeating the same calculation try going up\n              // while favoring horizontal dimension in such cases\n              if (horizontalCount == horizontalCountDouble) {\n                horizontalCount++;\n              }\n            } else {\n              horizontalCount = Math.floor(horizontalCountDouble);\n            }\n\n            // ideal width to be calculated\n            var idealWidth = horizontalCount * (averageWidth + horizontalPadding) - horizontalPadding;\n\n            // if max width is bigger than calculated ideal width reset ideal width to it\n            if (maxWidth > idealWidth) {\n              idealWidth = maxWidth;\n            }\n\n            // add the left-right margins to the ideal row width\n            idealWidth += horizontalPadding * 2;\n\n            // return the ideal row width1\n            return idealWidth;\n          };\n          CoSELayout.prototype.tileNodesByFavoringDim = function (nodes, minWidth, favorHorizontalDim) {\n            var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n            var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n            var tilingCompareBy = CoSEConstants.TILING_COMPARE_BY;\n            var organization = {\n              rows: [],\n              rowWidth: [],\n              rowHeight: [],\n              width: 0,\n              height: minWidth,\n              // assume minHeight equals to minWidth\n              verticalPadding: verticalPadding,\n              horizontalPadding: horizontalPadding,\n              centerX: 0,\n              centerY: 0\n            };\n            if (tilingCompareBy) {\n              organization.idealRowWidth = this.calcIdealRowWidth(nodes, favorHorizontalDim);\n            }\n            var getNodeArea = function getNodeArea(n) {\n              return n.rect.width * n.rect.height;\n            };\n            var areaCompareFcn = function areaCompareFcn(n1, n2) {\n              return getNodeArea(n2) - getNodeArea(n1);\n            };\n\n            // Sort the nodes in descending order of their areas\n            nodes.sort(function (n1, n2) {\n              var cmpBy = areaCompareFcn;\n              if (organization.idealRowWidth) {\n                cmpBy = tilingCompareBy;\n                return cmpBy(n1.id, n2.id);\n              }\n              return cmpBy(n1, n2);\n            });\n\n            // Create the organization -> calculate compound center\n            var sumCenterX = 0;\n            var sumCenterY = 0;\n            for (var i = 0; i < nodes.length; i++) {\n              var lNode = nodes[i];\n              sumCenterX += lNode.getCenterX();\n              sumCenterY += lNode.getCenterY();\n            }\n            organization.centerX = sumCenterX / nodes.length;\n            organization.centerY = sumCenterY / nodes.length;\n\n            // Create the organization -> tile members\n            for (var i = 0; i < nodes.length; i++) {\n              var lNode = nodes[i];\n              if (organization.rows.length == 0) {\n                this.insertNodeToRow(organization, lNode, 0, minWidth);\n              } else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {\n                var rowIndex = organization.rows.length - 1;\n                if (!organization.idealRowWidth) {\n                  rowIndex = this.getShortestRowIndex(organization);\n                }\n                this.insertNodeToRow(organization, lNode, rowIndex, minWidth);\n              } else {\n                this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);\n              }\n              this.shiftToLastRow(organization);\n            }\n            return organization;\n          };\n          CoSELayout.prototype.insertNodeToRow = function (organization, node, rowIndex, minWidth) {\n            var minCompoundSize = minWidth;\n\n            // Add new row if needed\n            if (rowIndex == organization.rows.length) {\n              var secondDimension = [];\n              organization.rows.push(secondDimension);\n              organization.rowWidth.push(minCompoundSize);\n              organization.rowHeight.push(0);\n            }\n\n            // Update row width\n            var w = organization.rowWidth[rowIndex] + node.rect.width;\n            if (organization.rows[rowIndex].length > 0) {\n              w += organization.horizontalPadding;\n            }\n            organization.rowWidth[rowIndex] = w;\n            // Update compound width\n            if (organization.width < w) {\n              organization.width = w;\n            }\n\n            // Update height\n            var h = node.rect.height;\n            if (rowIndex > 0) h += organization.verticalPadding;\n            var extraHeight = 0;\n            if (h > organization.rowHeight[rowIndex]) {\n              extraHeight = organization.rowHeight[rowIndex];\n              organization.rowHeight[rowIndex] = h;\n              extraHeight = organization.rowHeight[rowIndex] - extraHeight;\n            }\n            organization.height += extraHeight;\n\n            // Insert node\n            organization.rows[rowIndex].push(node);\n          };\n\n          //Scans the rows of an organization and returns the one with the min width\n          CoSELayout.prototype.getShortestRowIndex = function (organization) {\n            var r = -1;\n            var min = Number.MAX_VALUE;\n            for (var i = 0; i < organization.rows.length; i++) {\n              if (organization.rowWidth[i] < min) {\n                r = i;\n                min = organization.rowWidth[i];\n              }\n            }\n            return r;\n          };\n\n          //Scans the rows of an organization and returns the one with the max width\n          CoSELayout.prototype.getLongestRowIndex = function (organization) {\n            var r = -1;\n            var max = Number.MIN_VALUE;\n            for (var i = 0; i < organization.rows.length; i++) {\n              if (organization.rowWidth[i] > max) {\n                r = i;\n                max = organization.rowWidth[i];\n              }\n            }\n            return r;\n          };\n\n          /**\n          * This method checks whether adding extra width to the organization violates\n          * the aspect ratio(1) or not.\n          */\n          CoSELayout.prototype.canAddHorizontal = function (organization, extraWidth, extraHeight) {\n            // if there is an ideal row width specified use it instead of checking the aspect ratio\n            if (organization.idealRowWidth) {\n              var lastRowIndex = organization.rows.length - 1;\n              var lastRowWidth = organization.rowWidth[lastRowIndex];\n\n              // check and return if ideal row width will be exceed if the node is added to the row\n              return lastRowWidth + extraWidth + organization.horizontalPadding <= organization.idealRowWidth;\n            }\n            var sri = this.getShortestRowIndex(organization);\n            if (sri < 0) {\n              return true;\n            }\n            var min = organization.rowWidth[sri];\n            if (min + organization.horizontalPadding + extraWidth <= organization.width) return true;\n            var hDiff = 0;\n\n            // Adding to an existing row\n            if (organization.rowHeight[sri] < extraHeight) {\n              if (sri > 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];\n            }\n            var add_to_row_ratio;\n            if (organization.width - min >= extraWidth + organization.horizontalPadding) {\n              add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);\n            } else {\n              add_to_row_ratio = (organization.height + hDiff) / organization.width;\n            }\n\n            // Adding a new row for this node\n            hDiff = extraHeight + organization.verticalPadding;\n            var add_new_row_ratio;\n            if (organization.width < extraWidth) {\n              add_new_row_ratio = (organization.height + hDiff) / extraWidth;\n            } else {\n              add_new_row_ratio = (organization.height + hDiff) / organization.width;\n            }\n            if (add_new_row_ratio < 1) add_new_row_ratio = 1 / add_new_row_ratio;\n            if (add_to_row_ratio < 1) add_to_row_ratio = 1 / add_to_row_ratio;\n            return add_to_row_ratio < add_new_row_ratio;\n          };\n\n          //If moving the last node from the longest row and adding it to the last\n          //row makes the bounding box smaller, do it.\n          CoSELayout.prototype.shiftToLastRow = function (organization) {\n            var longest = this.getLongestRowIndex(organization);\n            var last = organization.rowWidth.length - 1;\n            var row = organization.rows[longest];\n            var node = row[row.length - 1];\n            var diff = node.width + organization.horizontalPadding;\n\n            // Check if there is enough space on the last row\n            if (organization.width - organization.rowWidth[last] > diff && longest != last) {\n              // Remove the last element of the longest row\n              row.splice(-1, 1);\n\n              // Push it to the last row\n              organization.rows[last].push(node);\n              organization.rowWidth[longest] = organization.rowWidth[longest] - diff;\n              organization.rowWidth[last] = organization.rowWidth[last] + diff;\n              organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)];\n\n              // Update heights of the organization\n              var maxHeight = Number.MIN_VALUE;\n              for (var i = 0; i < row.length; i++) {\n                if (row[i].height > maxHeight) maxHeight = row[i].height;\n              }\n              if (longest > 0) maxHeight += organization.verticalPadding;\n              var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n              organization.rowHeight[longest] = maxHeight;\n              if (organization.rowHeight[last] < node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;\n              var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n              organization.height += finalTotal - prevTotal;\n              this.shiftToLastRow(organization);\n            }\n          };\n          CoSELayout.prototype.tilingPreLayout = function () {\n            if (CoSEConstants.TILE) {\n              // Find zero degree nodes and create a compound for each level\n              this.groupZeroDegreeMembers();\n              // Tile and clear children of each compound\n              this.clearCompounds();\n              // Separately tile and clear zero degree nodes for each level\n              this.clearZeroDegreeMembers();\n            }\n          };\n          CoSELayout.prototype.tilingPostLayout = function () {\n            if (CoSEConstants.TILE) {\n              this.repopulateZeroDegreeMembers();\n              this.repopulateCompounds();\n            }\n          };\n\n          // -----------------------------------------------------------------------------\n          // Section: Tree Reduction methods\n          // -----------------------------------------------------------------------------\n          // Reduce trees \n          CoSELayout.prototype.reduceTrees = function () {\n            var prunedNodesAll = [];\n            var containsLeaf = true;\n            var node;\n            while (containsLeaf) {\n              var allNodes = this.graphManager.getAllNodes();\n              var prunedNodesInStepTemp = [];\n              containsLeaf = false;\n              for (var i = 0; i < allNodes.length; i++) {\n                node = allNodes[i];\n                if (node.getEdges().length == 1 && !node.getEdges()[0].isInterGraph && node.getChild() == null) {\n                  if (CoSEConstants.PURE_INCREMENTAL) {\n                    var otherEnd = node.getEdges()[0].getOtherEnd(node);\n                    var relativePosition = new DimensionD(node.getCenterX() - otherEnd.getCenterX(), node.getCenterY() - otherEnd.getCenterY());\n                    prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner(), relativePosition]);\n                  } else {\n                    prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner()]);\n                  }\n                  containsLeaf = true;\n                }\n              }\n              if (containsLeaf == true) {\n                var prunedNodesInStep = [];\n                for (var j = 0; j < prunedNodesInStepTemp.length; j++) {\n                  if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {\n                    prunedNodesInStep.push(prunedNodesInStepTemp[j]);\n                    prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);\n                  }\n                }\n                prunedNodesAll.push(prunedNodesInStep);\n                this.graphManager.resetAllNodes();\n                this.graphManager.resetAllEdges();\n              }\n            }\n            this.prunedNodesAll = prunedNodesAll;\n          };\n\n          // Grow tree one step \n          CoSELayout.prototype.growTree = function (prunedNodesAll) {\n            var lengthOfPrunedNodesInStep = prunedNodesAll.length;\n            var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];\n            var nodeData;\n            for (var i = 0; i < prunedNodesInStep.length; i++) {\n              nodeData = prunedNodesInStep[i];\n              this.findPlaceforPrunedNode(nodeData);\n              nodeData[2].add(nodeData[0]);\n              nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);\n            }\n            prunedNodesAll.splice(prunedNodesAll.length - 1, 1);\n            this.graphManager.resetAllNodes();\n            this.graphManager.resetAllEdges();\n          };\n\n          // Find an appropriate position to replace pruned node, this method can be improved\n          CoSELayout.prototype.findPlaceforPrunedNode = function (nodeData) {\n            var gridForPrunedNode;\n            var nodeToConnect;\n            var prunedNode = nodeData[0];\n            if (prunedNode == nodeData[1].source) {\n              nodeToConnect = nodeData[1].target;\n            } else {\n              nodeToConnect = nodeData[1].source;\n            }\n            if (CoSEConstants.PURE_INCREMENTAL) {\n              prunedNode.setCenter(nodeToConnect.getCenterX() + nodeData[3].getWidth(), nodeToConnect.getCenterY() + nodeData[3].getHeight());\n            } else {\n              var startGridX = nodeToConnect.startX;\n              var finishGridX = nodeToConnect.finishX;\n              var startGridY = nodeToConnect.startY;\n              var finishGridY = nodeToConnect.finishY;\n              var upNodeCount = 0;\n              var downNodeCount = 0;\n              var rightNodeCount = 0;\n              var leftNodeCount = 0;\n              var controlRegions = [upNodeCount, rightNodeCount, downNodeCount, leftNodeCount];\n              if (startGridY > 0) {\n                for (var i = startGridX; i <= finishGridX; i++) {\n                  controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;\n                }\n              }\n              if (finishGridX < this.grid.length - 1) {\n                for (var i = startGridY; i <= finishGridY; i++) {\n                  controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;\n                }\n              }\n              if (finishGridY < this.grid[0].length - 1) {\n                for (var i = startGridX; i <= finishGridX; i++) {\n                  controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;\n                }\n              }\n              if (startGridX > 0) {\n                for (var i = startGridY; i <= finishGridY; i++) {\n                  controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;\n                }\n              }\n              var min = Integer.MAX_VALUE;\n              var minCount;\n              var minIndex;\n              for (var j = 0; j < controlRegions.length; j++) {\n                if (controlRegions[j] < min) {\n                  min = controlRegions[j];\n                  minCount = 1;\n                  minIndex = j;\n                } else if (controlRegions[j] == min) {\n                  minCount++;\n                }\n              }\n              if (minCount == 3 && min == 0) {\n                if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[2] == 0) {\n                  gridForPrunedNode = 1;\n                } else if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[3] == 0) {\n                  gridForPrunedNode = 0;\n                } else if (controlRegions[0] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n                  gridForPrunedNode = 3;\n                } else if (controlRegions[1] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n                  gridForPrunedNode = 2;\n                }\n              } else if (minCount == 2 && min == 0) {\n                var random = Math.floor(Math.random() * 2);\n                if (controlRegions[0] == 0 && controlRegions[1] == 0) {\n                  ;\n                  if (random == 0) {\n                    gridForPrunedNode = 0;\n                  } else {\n                    gridForPrunedNode = 1;\n                  }\n                } else if (controlRegions[0] == 0 && controlRegions[2] == 0) {\n                  if (random == 0) {\n                    gridForPrunedNode = 0;\n                  } else {\n                    gridForPrunedNode = 2;\n                  }\n                } else if (controlRegions[0] == 0 && controlRegions[3] == 0) {\n                  if (random == 0) {\n                    gridForPrunedNode = 0;\n                  } else {\n                    gridForPrunedNode = 3;\n                  }\n                } else if (controlRegions[1] == 0 && controlRegions[2] == 0) {\n                  if (random == 0) {\n                    gridForPrunedNode = 1;\n                  } else {\n                    gridForPrunedNode = 2;\n                  }\n                } else if (controlRegions[1] == 0 && controlRegions[3] == 0) {\n                  if (random == 0) {\n                    gridForPrunedNode = 1;\n                  } else {\n                    gridForPrunedNode = 3;\n                  }\n                } else {\n                  if (random == 0) {\n                    gridForPrunedNode = 2;\n                  } else {\n                    gridForPrunedNode = 3;\n                  }\n                }\n              } else if (minCount == 4 && min == 0) {\n                var random = Math.floor(Math.random() * 4);\n                gridForPrunedNode = random;\n              } else {\n                gridForPrunedNode = minIndex;\n              }\n              if (gridForPrunedNode == 0) {\n                prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);\n              } else if (gridForPrunedNode == 1) {\n                prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n              } else if (gridForPrunedNode == 2) {\n                prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);\n              } else {\n                prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n              }\n            }\n          };\n          module.exports = CoSELayout;\n\n          /***/\n        },\n\n        /***/991: /***/(module, __unused_webpack_exports, __webpack_require__) => {\n          var FDLayoutNode = __webpack_require__(551).FDLayoutNode;\n          var IMath = __webpack_require__(551).IMath;\n          function CoSENode(gm, loc, size, vNode) {\n            FDLayoutNode.call(this, gm, loc, size, vNode);\n          }\n          CoSENode.prototype = Object.create(FDLayoutNode.prototype);\n          for (var prop in FDLayoutNode) {\n            CoSENode[prop] = FDLayoutNode[prop];\n          }\n          CoSENode.prototype.calculateDisplacement = function () {\n            var layout = this.graphManager.getLayout();\n            // this check is for compound nodes that contain fixed nodes\n            if (this.getChild() != null && this.fixedNodeWeight) {\n              this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.fixedNodeWeight;\n              this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.fixedNodeWeight;\n            } else {\n              this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;\n              this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;\n            }\n            if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement) {\n              this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);\n            }\n            if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement) {\n              this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);\n            }\n\n            // non-empty compound node, propogate movement to children as well\n            if (this.child && this.child.getNodes().length > 0) {\n              this.propogateDisplacementToChildren(this.displacementX, this.displacementY);\n            }\n          };\n          CoSENode.prototype.propogateDisplacementToChildren = function (dX, dY) {\n            var nodes = this.getChild().getNodes();\n            var node;\n            for (var i = 0; i < nodes.length; i++) {\n              node = nodes[i];\n              if (node.getChild() == null) {\n                node.displacementX += dX;\n                node.displacementY += dY;\n              } else {\n                node.propogateDisplacementToChildren(dX, dY);\n              }\n            }\n          };\n          CoSENode.prototype.move = function () {\n            var layout = this.graphManager.getLayout();\n\n            // a simple node or an empty compound node, move it\n            if (this.child == null || this.child.getNodes().length == 0) {\n              this.moveBy(this.displacementX, this.displacementY);\n              layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);\n            }\n            this.springForceX = 0;\n            this.springForceY = 0;\n            this.repulsionForceX = 0;\n            this.repulsionForceY = 0;\n            this.gravitationForceX = 0;\n            this.gravitationForceY = 0;\n            this.displacementX = 0;\n            this.displacementY = 0;\n          };\n          CoSENode.prototype.setPred1 = function (pred1) {\n            this.pred1 = pred1;\n          };\n          CoSENode.prototype.getPred1 = function () {\n            return pred1;\n          };\n          CoSENode.prototype.getPred2 = function () {\n            return pred2;\n          };\n          CoSENode.prototype.setNext = function (next) {\n            this.next = next;\n          };\n          CoSENode.prototype.getNext = function () {\n            return next;\n          };\n          CoSENode.prototype.setProcessed = function (processed) {\n            this.processed = processed;\n          };\n          CoSENode.prototype.isProcessed = function () {\n            return processed;\n          };\n          module.exports = CoSENode;\n\n          /***/\n        },\n\n        /***/902: /***/(module, __unused_webpack_exports, __webpack_require__) => {\n          function _toConsumableArray(arr) {\n            if (Array.isArray(arr)) {\n              for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n                arr2[i] = arr[i];\n              }\n              return arr2;\n            } else {\n              return Array.from(arr);\n            }\n          }\n          var CoSEConstants = __webpack_require__(806);\n          var LinkedList = __webpack_require__(551).LinkedList;\n          var Matrix = __webpack_require__(551).Matrix;\n          var SVD = __webpack_require__(551).SVD;\n          function ConstraintHandler() {}\n          ConstraintHandler.handleConstraints = function (layout) {\n            //  let layout = this.graphManager.getLayout();\n\n            // get constraints from layout\n            var constraints = {};\n            constraints.fixedNodeConstraint = layout.constraints.fixedNodeConstraint;\n            constraints.alignmentConstraint = layout.constraints.alignmentConstraint;\n            constraints.relativePlacementConstraint = layout.constraints.relativePlacementConstraint;\n            var idToNodeMap = new Map();\n            var nodeIndexes = new Map();\n            var xCoords = [];\n            var yCoords = [];\n            var allNodes = layout.getAllNodes();\n            var index = 0;\n            // fill index map and coordinates\n            for (var i = 0; i < allNodes.length; i++) {\n              var node = allNodes[i];\n              if (node.getChild() == null) {\n                nodeIndexes.set(node.id, index++);\n                xCoords.push(node.getCenterX());\n                yCoords.push(node.getCenterY());\n                idToNodeMap.set(node.id, node);\n              }\n            }\n\n            // if there exists relative placement constraint without gap value, set it to default \n            if (constraints.relativePlacementConstraint) {\n              constraints.relativePlacementConstraint.forEach(function (constraint) {\n                if (!constraint.gap && constraint.gap != 0) {\n                  if (constraint.left) {\n                    constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.left).getWidth() / 2 + idToNodeMap.get(constraint.right).getWidth() / 2;\n                  } else {\n                    constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.top).getHeight() / 2 + idToNodeMap.get(constraint.bottom).getHeight() / 2;\n                  }\n                }\n              });\n            }\n\n            /* auxiliary functions */\n\n            // calculate difference between two position objects\n            var calculatePositionDiff = function calculatePositionDiff(pos1, pos2) {\n              return {\n                x: pos1.x - pos2.x,\n                y: pos1.y - pos2.y\n              };\n            };\n\n            // calculate average position of the nodes\n            var calculateAvgPosition = function calculateAvgPosition(nodeIdSet) {\n              var xPosSum = 0;\n              var yPosSum = 0;\n              nodeIdSet.forEach(function (nodeId) {\n                xPosSum += xCoords[nodeIndexes.get(nodeId)];\n                yPosSum += yCoords[nodeIndexes.get(nodeId)];\n              });\n              return {\n                x: xPosSum / nodeIdSet.size,\n                y: yPosSum / nodeIdSet.size\n              };\n            };\n\n            // find an appropriate positioning for the nodes in a given graph according to relative placement constraints\n            // this function also takes the fixed nodes and alignment constraints into account\n            // graph: dag to be evaluated, direction: \"horizontal\" or \"vertical\", \n            // fixedNodes: set of fixed nodes to consider during evaluation, dummyPositions: appropriate coordinates of the dummy nodes  \n            var findAppropriatePositionForRelativePlacement = function findAppropriatePositionForRelativePlacement(graph, direction, fixedNodes, dummyPositions, componentSources) {\n              // find union of two sets\n              function setUnion(setA, setB) {\n                var union = new Set(setA);\n                var _iteratorNormalCompletion = true;\n                var _didIteratorError = false;\n                var _iteratorError = undefined;\n                try {\n                  for (var _iterator = setB[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var elem = _step.value;\n                    union.add(elem);\n                  }\n                } catch (err) {\n                  _didIteratorError = true;\n                  _iteratorError = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                      _iterator.return();\n                    }\n                  } finally {\n                    if (_didIteratorError) {\n                      throw _iteratorError;\n                    }\n                  }\n                }\n                return union;\n              }\n\n              // find indegree count for each node\n              var inDegrees = new Map();\n              graph.forEach(function (value, key) {\n                inDegrees.set(key, 0);\n              });\n              graph.forEach(function (value, key) {\n                value.forEach(function (adjacent) {\n                  inDegrees.set(adjacent.id, inDegrees.get(adjacent.id) + 1);\n                });\n              });\n              var positionMap = new Map(); // keeps the position for each node\n              var pastMap = new Map(); // keeps the predecessors(past) of a node\n              var queue = new LinkedList();\n              inDegrees.forEach(function (value, key) {\n                if (value == 0) {\n                  queue.push(key);\n                  if (!fixedNodes) {\n                    if (direction == \"horizontal\") {\n                      positionMap.set(key, nodeIndexes.has(key) ? xCoords[nodeIndexes.get(key)] : dummyPositions.get(key));\n                    } else {\n                      positionMap.set(key, nodeIndexes.has(key) ? yCoords[nodeIndexes.get(key)] : dummyPositions.get(key));\n                    }\n                  }\n                } else {\n                  positionMap.set(key, Number.NEGATIVE_INFINITY);\n                }\n                if (fixedNodes) {\n                  pastMap.set(key, new Set([key]));\n                }\n              });\n\n              // align sources of each component in enforcement phase\n              if (fixedNodes) {\n                componentSources.forEach(function (component) {\n                  var fixedIds = [];\n                  component.forEach(function (nodeId) {\n                    if (fixedNodes.has(nodeId)) {\n                      fixedIds.push(nodeId);\n                    }\n                  });\n                  if (fixedIds.length > 0) {\n                    var position = 0;\n                    fixedIds.forEach(function (fixedId) {\n                      if (direction == \"horizontal\") {\n                        positionMap.set(fixedId, nodeIndexes.has(fixedId) ? xCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));\n                        position += positionMap.get(fixedId);\n                      } else {\n                        positionMap.set(fixedId, nodeIndexes.has(fixedId) ? yCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));\n                        position += positionMap.get(fixedId);\n                      }\n                    });\n                    position = position / fixedIds.length;\n                    component.forEach(function (nodeId) {\n                      if (!fixedNodes.has(nodeId)) {\n                        positionMap.set(nodeId, position);\n                      }\n                    });\n                  } else {\n                    var _position = 0;\n                    component.forEach(function (nodeId) {\n                      if (direction == \"horizontal\") {\n                        _position += nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n                      } else {\n                        _position += nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n                      }\n                    });\n                    _position = _position / component.length;\n                    component.forEach(function (nodeId) {\n                      positionMap.set(nodeId, _position);\n                    });\n                  }\n                });\n              }\n\n              // calculate positions of the nodes\n\n              var _loop = function _loop() {\n                var currentNode = queue.shift();\n                var neighbors = graph.get(currentNode);\n                neighbors.forEach(function (neighbor) {\n                  if (positionMap.get(neighbor.id) < positionMap.get(currentNode) + neighbor.gap) {\n                    if (fixedNodes && fixedNodes.has(neighbor.id)) {\n                      var fixedPosition = void 0;\n                      if (direction == \"horizontal\") {\n                        fixedPosition = nodeIndexes.has(neighbor.id) ? xCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);\n                      } else {\n                        fixedPosition = nodeIndexes.has(neighbor.id) ? yCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);\n                      }\n                      positionMap.set(neighbor.id, fixedPosition); // TODO: may do unnecessary work\n                      if (fixedPosition < positionMap.get(currentNode) + neighbor.gap) {\n                        var diff = positionMap.get(currentNode) + neighbor.gap - fixedPosition;\n                        pastMap.get(currentNode).forEach(function (nodeId) {\n                          positionMap.set(nodeId, positionMap.get(nodeId) - diff);\n                        });\n                      }\n                    } else {\n                      positionMap.set(neighbor.id, positionMap.get(currentNode) + neighbor.gap);\n                    }\n                  }\n                  inDegrees.set(neighbor.id, inDegrees.get(neighbor.id) - 1);\n                  if (inDegrees.get(neighbor.id) == 0) {\n                    queue.push(neighbor.id);\n                  }\n                  if (fixedNodes) {\n                    pastMap.set(neighbor.id, setUnion(pastMap.get(currentNode), pastMap.get(neighbor.id)));\n                  }\n                });\n              };\n              while (queue.length != 0) {\n                _loop();\n              }\n\n              // readjust position of the nodes after enforcement\n              if (fixedNodes) {\n                // find indegree count for each node\n                var sinkNodes = new Set();\n                graph.forEach(function (value, key) {\n                  if (value.length == 0) {\n                    sinkNodes.add(key);\n                  }\n                });\n                var _components = [];\n                pastMap.forEach(function (value, key) {\n                  if (sinkNodes.has(key)) {\n                    var isFixedComponent = false;\n                    var _iteratorNormalCompletion2 = true;\n                    var _didIteratorError2 = false;\n                    var _iteratorError2 = undefined;\n                    try {\n                      for (var _iterator2 = value[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                        var nodeId = _step2.value;\n                        if (fixedNodes.has(nodeId)) {\n                          isFixedComponent = true;\n                        }\n                      }\n                    } catch (err) {\n                      _didIteratorError2 = true;\n                      _iteratorError2 = err;\n                    } finally {\n                      try {\n                        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                          _iterator2.return();\n                        }\n                      } finally {\n                        if (_didIteratorError2) {\n                          throw _iteratorError2;\n                        }\n                      }\n                    }\n                    if (!isFixedComponent) {\n                      var isExist = false;\n                      var existAt = void 0;\n                      _components.forEach(function (component, index) {\n                        if (component.has([].concat(_toConsumableArray(value))[0])) {\n                          isExist = true;\n                          existAt = index;\n                        }\n                      });\n                      if (!isExist) {\n                        _components.push(new Set(value));\n                      } else {\n                        value.forEach(function (ele) {\n                          _components[existAt].add(ele);\n                        });\n                      }\n                    }\n                  }\n                });\n                _components.forEach(function (component, index) {\n                  var minBefore = Number.POSITIVE_INFINITY;\n                  var minAfter = Number.POSITIVE_INFINITY;\n                  var maxBefore = Number.NEGATIVE_INFINITY;\n                  var maxAfter = Number.NEGATIVE_INFINITY;\n                  var _iteratorNormalCompletion3 = true;\n                  var _didIteratorError3 = false;\n                  var _iteratorError3 = undefined;\n                  try {\n                    for (var _iterator3 = component[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                      var nodeId = _step3.value;\n                      var posBefore = void 0;\n                      if (direction == \"horizontal\") {\n                        posBefore = nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n                      } else {\n                        posBefore = nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n                      }\n                      var posAfter = positionMap.get(nodeId);\n                      if (posBefore < minBefore) {\n                        minBefore = posBefore;\n                      }\n                      if (posBefore > maxBefore) {\n                        maxBefore = posBefore;\n                      }\n                      if (posAfter < minAfter) {\n                        minAfter = posAfter;\n                      }\n                      if (posAfter > maxAfter) {\n                        maxAfter = posAfter;\n                      }\n                    }\n                  } catch (err) {\n                    _didIteratorError3 = true;\n                    _iteratorError3 = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                      }\n                    } finally {\n                      if (_didIteratorError3) {\n                        throw _iteratorError3;\n                      }\n                    }\n                  }\n                  var diff = (minBefore + maxBefore) / 2 - (minAfter + maxAfter) / 2;\n                  var _iteratorNormalCompletion4 = true;\n                  var _didIteratorError4 = false;\n                  var _iteratorError4 = undefined;\n                  try {\n                    for (var _iterator4 = component[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                      var _nodeId = _step4.value;\n                      positionMap.set(_nodeId, positionMap.get(_nodeId) + diff);\n                    }\n                  } catch (err) {\n                    _didIteratorError4 = true;\n                    _iteratorError4 = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                        _iterator4.return();\n                      }\n                    } finally {\n                      if (_didIteratorError4) {\n                        throw _iteratorError4;\n                      }\n                    }\n                  }\n                });\n              }\n              return positionMap;\n            };\n\n            // find transformation based on rel. placement constraints if there are both alignment and rel. placement constraints\n            // or if there are only rel. placement contraints where the largest component isn't sufficiently large\n            var applyReflectionForRelativePlacement = function applyReflectionForRelativePlacement(relativePlacementConstraints) {\n              // variables to count votes\n              var reflectOnY = 0,\n                notReflectOnY = 0;\n              var reflectOnX = 0,\n                notReflectOnX = 0;\n              relativePlacementConstraints.forEach(function (constraint) {\n                if (constraint.left) {\n                  xCoords[nodeIndexes.get(constraint.left)] - xCoords[nodeIndexes.get(constraint.right)] >= 0 ? reflectOnY++ : notReflectOnY++;\n                } else {\n                  yCoords[nodeIndexes.get(constraint.top)] - yCoords[nodeIndexes.get(constraint.bottom)] >= 0 ? reflectOnX++ : notReflectOnX++;\n                }\n              });\n              if (reflectOnY > notReflectOnY && reflectOnX > notReflectOnX) {\n                for (var _i = 0; _i < nodeIndexes.size; _i++) {\n                  xCoords[_i] = -1 * xCoords[_i];\n                  yCoords[_i] = -1 * yCoords[_i];\n                }\n              } else if (reflectOnY > notReflectOnY) {\n                for (var _i2 = 0; _i2 < nodeIndexes.size; _i2++) {\n                  xCoords[_i2] = -1 * xCoords[_i2];\n                }\n              } else if (reflectOnX > notReflectOnX) {\n                for (var _i3 = 0; _i3 < nodeIndexes.size; _i3++) {\n                  yCoords[_i3] = -1 * yCoords[_i3];\n                }\n              }\n            };\n\n            // find weakly connected components in undirected graph\n            var findComponents = function findComponents(graph) {\n              // find weakly connected components in dag\n              var components = [];\n              var queue = new LinkedList();\n              var visited = new Set();\n              var count = 0;\n              graph.forEach(function (value, key) {\n                if (!visited.has(key)) {\n                  components[count] = [];\n                  var _currentNode = key;\n                  queue.push(_currentNode);\n                  visited.add(_currentNode);\n                  components[count].push(_currentNode);\n                  while (queue.length != 0) {\n                    _currentNode = queue.shift();\n                    var neighbors = graph.get(_currentNode);\n                    neighbors.forEach(function (neighbor) {\n                      if (!visited.has(neighbor.id)) {\n                        queue.push(neighbor.id);\n                        visited.add(neighbor.id);\n                        components[count].push(neighbor.id);\n                      }\n                    });\n                  }\n                  count++;\n                }\n              });\n              return components;\n            };\n\n            // return undirected version of given dag\n            var dagToUndirected = function dagToUndirected(dag) {\n              var undirected = new Map();\n              dag.forEach(function (value, key) {\n                undirected.set(key, []);\n              });\n              dag.forEach(function (value, key) {\n                value.forEach(function (adjacent) {\n                  undirected.get(key).push(adjacent);\n                  undirected.get(adjacent.id).push({\n                    id: key,\n                    gap: adjacent.gap,\n                    direction: adjacent.direction\n                  });\n                });\n              });\n              return undirected;\n            };\n\n            // return reversed (directions inverted) version of given dag\n            var dagToReversed = function dagToReversed(dag) {\n              var reversed = new Map();\n              dag.forEach(function (value, key) {\n                reversed.set(key, []);\n              });\n              dag.forEach(function (value, key) {\n                value.forEach(function (adjacent) {\n                  reversed.get(adjacent.id).push({\n                    id: key,\n                    gap: adjacent.gap,\n                    direction: adjacent.direction\n                  });\n                });\n              });\n              return reversed;\n            };\n\n            /****  apply transformation to the initial draft layout to better align with constrained nodes ****/\n            // solve the Orthogonal Procrustean Problem to rotate and/or reflect initial draft layout\n            // here we follow the solution in Chapter 20.2 of Borg, I. & Groenen, P. (2005) Modern Multidimensional Scaling: Theory and Applications \n\n            /* construct source and target configurations */\n\n            var targetMatrix = []; // A - target configuration\n            var sourceMatrix = []; // B - source configuration \n            var standardTransformation = false; // false for no transformation, true for standart (Procrustes) transformation (rotation and/or reflection)\n            var reflectionType = false; // false/true for reflection check, 'reflectOnX', 'reflectOnY' or 'reflectOnBoth' for reflection type if necessary\n            var fixedNodes = new Set();\n            var dag = new Map(); // adjacency list to keep directed acyclic graph (dag) that consists of relative placement constraints\n            var dagUndirected = new Map(); // undirected version of the dag\n            var components = []; // weakly connected components\n\n            // fill fixedNodes collection to use later\n            if (constraints.fixedNodeConstraint) {\n              constraints.fixedNodeConstraint.forEach(function (nodeData) {\n                fixedNodes.add(nodeData.nodeId);\n              });\n            }\n\n            // construct dag from relative placement constraints \n            if (constraints.relativePlacementConstraint) {\n              // construct both directed and undirected version of the dag\n              constraints.relativePlacementConstraint.forEach(function (constraint) {\n                if (constraint.left) {\n                  if (dag.has(constraint.left)) {\n                    dag.get(constraint.left).push({\n                      id: constraint.right,\n                      gap: constraint.gap,\n                      direction: \"horizontal\"\n                    });\n                  } else {\n                    dag.set(constraint.left, [{\n                      id: constraint.right,\n                      gap: constraint.gap,\n                      direction: \"horizontal\"\n                    }]);\n                  }\n                  if (!dag.has(constraint.right)) {\n                    dag.set(constraint.right, []);\n                  }\n                } else {\n                  if (dag.has(constraint.top)) {\n                    dag.get(constraint.top).push({\n                      id: constraint.bottom,\n                      gap: constraint.gap,\n                      direction: \"vertical\"\n                    });\n                  } else {\n                    dag.set(constraint.top, [{\n                      id: constraint.bottom,\n                      gap: constraint.gap,\n                      direction: \"vertical\"\n                    }]);\n                  }\n                  if (!dag.has(constraint.bottom)) {\n                    dag.set(constraint.bottom, []);\n                  }\n                }\n              });\n              dagUndirected = dagToUndirected(dag);\n              components = findComponents(dagUndirected);\n            }\n            if (CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING) {\n              // first check fixed node constraint\n              if (constraints.fixedNodeConstraint && constraints.fixedNodeConstraint.length > 1) {\n                constraints.fixedNodeConstraint.forEach(function (nodeData, i) {\n                  targetMatrix[i] = [nodeData.position.x, nodeData.position.y];\n                  sourceMatrix[i] = [xCoords[nodeIndexes.get(nodeData.nodeId)], yCoords[nodeIndexes.get(nodeData.nodeId)]];\n                });\n                standardTransformation = true;\n              } else if (constraints.alignmentConstraint) {\n                (function () {\n                  // then check alignment constraint\n                  var count = 0;\n                  if (constraints.alignmentConstraint.vertical) {\n                    var verticalAlign = constraints.alignmentConstraint.vertical;\n                    var _loop2 = function _loop2(_i4) {\n                      var alignmentSet = new Set();\n                      verticalAlign[_i4].forEach(function (nodeId) {\n                        alignmentSet.add(nodeId);\n                      });\n                      var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n                        return fixedNodes.has(x);\n                      }));\n                      var xPos = void 0;\n                      if (intersection.size > 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else xPos = calculateAvgPosition(alignmentSet).x;\n                      verticalAlign[_i4].forEach(function (nodeId) {\n                        targetMatrix[count] = [xPos, yCoords[nodeIndexes.get(nodeId)]];\n                        sourceMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n                        count++;\n                      });\n                    };\n                    for (var _i4 = 0; _i4 < verticalAlign.length; _i4++) {\n                      _loop2(_i4);\n                    }\n                    standardTransformation = true;\n                  }\n                  if (constraints.alignmentConstraint.horizontal) {\n                    var horizontalAlign = constraints.alignmentConstraint.horizontal;\n                    var _loop3 = function _loop3(_i5) {\n                      var alignmentSet = new Set();\n                      horizontalAlign[_i5].forEach(function (nodeId) {\n                        alignmentSet.add(nodeId);\n                      });\n                      var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n                        return fixedNodes.has(x);\n                      }));\n                      var yPos = void 0;\n                      if (intersection.size > 0) yPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else yPos = calculateAvgPosition(alignmentSet).y;\n                      horizontalAlign[_i5].forEach(function (nodeId) {\n                        targetMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yPos];\n                        sourceMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n                        count++;\n                      });\n                    };\n                    for (var _i5 = 0; _i5 < horizontalAlign.length; _i5++) {\n                      _loop3(_i5);\n                    }\n                    standardTransformation = true;\n                  }\n                  if (constraints.relativePlacementConstraint) {\n                    reflectionType = true;\n                  }\n                })();\n              } else if (constraints.relativePlacementConstraint) {\n                // finally check relative placement constraint\n                // find largest component in dag\n                var largestComponentSize = 0;\n                var largestComponentIndex = 0;\n                for (var _i6 = 0; _i6 < components.length; _i6++) {\n                  if (components[_i6].length > largestComponentSize) {\n                    largestComponentSize = components[_i6].length;\n                    largestComponentIndex = _i6;\n                  }\n                }\n                // if largest component isn't dominant, then take the votes for reflection\n                if (largestComponentSize < dagUndirected.size / 2) {\n                  applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);\n                  standardTransformation = false;\n                  reflectionType = false;\n                } else {\n                  // use largest component for transformation\n                  // construct horizontal and vertical subgraphs in the largest component\n                  var subGraphOnHorizontal = new Map();\n                  var subGraphOnVertical = new Map();\n                  var constraintsInlargestComponent = [];\n                  components[largestComponentIndex].forEach(function (nodeId) {\n                    dag.get(nodeId).forEach(function (adjacent) {\n                      if (adjacent.direction == \"horizontal\") {\n                        if (subGraphOnHorizontal.has(nodeId)) {\n                          subGraphOnHorizontal.get(nodeId).push(adjacent);\n                        } else {\n                          subGraphOnHorizontal.set(nodeId, [adjacent]);\n                        }\n                        if (!subGraphOnHorizontal.has(adjacent.id)) {\n                          subGraphOnHorizontal.set(adjacent.id, []);\n                        }\n                        constraintsInlargestComponent.push({\n                          left: nodeId,\n                          right: adjacent.id\n                        });\n                      } else {\n                        if (subGraphOnVertical.has(nodeId)) {\n                          subGraphOnVertical.get(nodeId).push(adjacent);\n                        } else {\n                          subGraphOnVertical.set(nodeId, [adjacent]);\n                        }\n                        if (!subGraphOnVertical.has(adjacent.id)) {\n                          subGraphOnVertical.set(adjacent.id, []);\n                        }\n                        constraintsInlargestComponent.push({\n                          top: nodeId,\n                          bottom: adjacent.id\n                        });\n                      }\n                    });\n                  });\n                  applyReflectionForRelativePlacement(constraintsInlargestComponent);\n                  reflectionType = false;\n\n                  // calculate appropriate positioning for subgraphs\n                  var positionMapHorizontal = findAppropriatePositionForRelativePlacement(subGraphOnHorizontal, \"horizontal\");\n                  var positionMapVertical = findAppropriatePositionForRelativePlacement(subGraphOnVertical, \"vertical\");\n\n                  // construct source and target configuration\n                  components[largestComponentIndex].forEach(function (nodeId, i) {\n                    sourceMatrix[i] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n                    targetMatrix[i] = [];\n                    if (positionMapHorizontal.has(nodeId)) {\n                      targetMatrix[i][0] = positionMapHorizontal.get(nodeId);\n                    } else {\n                      targetMatrix[i][0] = xCoords[nodeIndexes.get(nodeId)];\n                    }\n                    if (positionMapVertical.has(nodeId)) {\n                      targetMatrix[i][1] = positionMapVertical.get(nodeId);\n                    } else {\n                      targetMatrix[i][1] = yCoords[nodeIndexes.get(nodeId)];\n                    }\n                  });\n                  standardTransformation = true;\n                }\n              }\n\n              // if transformation is required, then calculate and apply transformation matrix\n              if (standardTransformation) {\n                /* calculate transformation matrix */\n                var transformationMatrix = void 0;\n                var targetMatrixTranspose = Matrix.transpose(targetMatrix); // A'\n                var sourceMatrixTranspose = Matrix.transpose(sourceMatrix); // B'\n\n                // centralize transpose matrices\n                for (var _i7 = 0; _i7 < targetMatrixTranspose.length; _i7++) {\n                  targetMatrixTranspose[_i7] = Matrix.multGamma(targetMatrixTranspose[_i7]);\n                  sourceMatrixTranspose[_i7] = Matrix.multGamma(sourceMatrixTranspose[_i7]);\n                }\n\n                // do actual calculation for transformation matrix\n                var tempMatrix = Matrix.multMat(targetMatrixTranspose, Matrix.transpose(sourceMatrixTranspose)); // tempMatrix = A'B\n                var SVDResult = SVD.svd(tempMatrix); // SVD(A'B) = USV', svd function returns U, S and V \n                transformationMatrix = Matrix.multMat(SVDResult.V, Matrix.transpose(SVDResult.U)); // transformationMatrix = T = VU'\n\n                /* apply found transformation matrix to obtain final draft layout */\n                for (var _i8 = 0; _i8 < nodeIndexes.size; _i8++) {\n                  var temp1 = [xCoords[_i8], yCoords[_i8]];\n                  var temp2 = [transformationMatrix[0][0], transformationMatrix[1][0]];\n                  var temp3 = [transformationMatrix[0][1], transformationMatrix[1][1]];\n                  xCoords[_i8] = Matrix.dotProduct(temp1, temp2);\n                  yCoords[_i8] = Matrix.dotProduct(temp1, temp3);\n                }\n\n                // applied only both alignment and rel. placement constraints exist\n                if (reflectionType) {\n                  applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);\n                }\n              }\n            }\n            if (CoSEConstants.ENFORCE_CONSTRAINTS) {\n              /****  enforce constraints on the transformed draft layout ****/\n\n              /* first enforce fixed node constraint */\n\n              if (constraints.fixedNodeConstraint && constraints.fixedNodeConstraint.length > 0) {\n                var translationAmount = {\n                  x: 0,\n                  y: 0\n                };\n                constraints.fixedNodeConstraint.forEach(function (nodeData, i) {\n                  var posInTheory = {\n                    x: xCoords[nodeIndexes.get(nodeData.nodeId)],\n                    y: yCoords[nodeIndexes.get(nodeData.nodeId)]\n                  };\n                  var posDesired = nodeData.position;\n                  var posDiff = calculatePositionDiff(posDesired, posInTheory);\n                  translationAmount.x += posDiff.x;\n                  translationAmount.y += posDiff.y;\n                });\n                translationAmount.x /= constraints.fixedNodeConstraint.length;\n                translationAmount.y /= constraints.fixedNodeConstraint.length;\n                xCoords.forEach(function (value, i) {\n                  xCoords[i] += translationAmount.x;\n                });\n                yCoords.forEach(function (value, i) {\n                  yCoords[i] += translationAmount.y;\n                });\n                constraints.fixedNodeConstraint.forEach(function (nodeData) {\n                  xCoords[nodeIndexes.get(nodeData.nodeId)] = nodeData.position.x;\n                  yCoords[nodeIndexes.get(nodeData.nodeId)] = nodeData.position.y;\n                });\n              }\n\n              /* then enforce alignment constraint */\n\n              if (constraints.alignmentConstraint) {\n                if (constraints.alignmentConstraint.vertical) {\n                  var xAlign = constraints.alignmentConstraint.vertical;\n                  var _loop4 = function _loop4(_i9) {\n                    var alignmentSet = new Set();\n                    xAlign[_i9].forEach(function (nodeId) {\n                      alignmentSet.add(nodeId);\n                    });\n                    var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n                      return fixedNodes.has(x);\n                    }));\n                    var xPos = void 0;\n                    if (intersection.size > 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else xPos = calculateAvgPosition(alignmentSet).x;\n                    alignmentSet.forEach(function (nodeId) {\n                      if (!fixedNodes.has(nodeId)) xCoords[nodeIndexes.get(nodeId)] = xPos;\n                    });\n                  };\n                  for (var _i9 = 0; _i9 < xAlign.length; _i9++) {\n                    _loop4(_i9);\n                  }\n                }\n                if (constraints.alignmentConstraint.horizontal) {\n                  var yAlign = constraints.alignmentConstraint.horizontal;\n                  var _loop5 = function _loop5(_i10) {\n                    var alignmentSet = new Set();\n                    yAlign[_i10].forEach(function (nodeId) {\n                      alignmentSet.add(nodeId);\n                    });\n                    var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n                      return fixedNodes.has(x);\n                    }));\n                    var yPos = void 0;\n                    if (intersection.size > 0) yPos = yCoords[nodeIndexes.get(intersection.values().next().value)];else yPos = calculateAvgPosition(alignmentSet).y;\n                    alignmentSet.forEach(function (nodeId) {\n                      if (!fixedNodes.has(nodeId)) yCoords[nodeIndexes.get(nodeId)] = yPos;\n                    });\n                  };\n                  for (var _i10 = 0; _i10 < yAlign.length; _i10++) {\n                    _loop5(_i10);\n                  }\n                }\n              }\n\n              /* finally enforce relative placement constraint */\n\n              if (constraints.relativePlacementConstraint) {\n                (function () {\n                  var nodeToDummyForVerticalAlignment = new Map();\n                  var nodeToDummyForHorizontalAlignment = new Map();\n                  var dummyToNodeForVerticalAlignment = new Map();\n                  var dummyToNodeForHorizontalAlignment = new Map();\n                  var dummyPositionsForVerticalAlignment = new Map();\n                  var dummyPositionsForHorizontalAlignment = new Map();\n                  var fixedNodesOnHorizontal = new Set();\n                  var fixedNodesOnVertical = new Set();\n\n                  // fill maps and sets      \n                  fixedNodes.forEach(function (nodeId) {\n                    fixedNodesOnHorizontal.add(nodeId);\n                    fixedNodesOnVertical.add(nodeId);\n                  });\n                  if (constraints.alignmentConstraint) {\n                    if (constraints.alignmentConstraint.vertical) {\n                      var verticalAlignment = constraints.alignmentConstraint.vertical;\n                      var _loop6 = function _loop6(_i11) {\n                        dummyToNodeForVerticalAlignment.set(\"dummy\" + _i11, []);\n                        verticalAlignment[_i11].forEach(function (nodeId) {\n                          nodeToDummyForVerticalAlignment.set(nodeId, \"dummy\" + _i11);\n                          dummyToNodeForVerticalAlignment.get(\"dummy\" + _i11).push(nodeId);\n                          if (fixedNodes.has(nodeId)) {\n                            fixedNodesOnHorizontal.add(\"dummy\" + _i11);\n                          }\n                        });\n                        dummyPositionsForVerticalAlignment.set(\"dummy\" + _i11, xCoords[nodeIndexes.get(verticalAlignment[_i11][0])]);\n                      };\n                      for (var _i11 = 0; _i11 < verticalAlignment.length; _i11++) {\n                        _loop6(_i11);\n                      }\n                    }\n                    if (constraints.alignmentConstraint.horizontal) {\n                      var horizontalAlignment = constraints.alignmentConstraint.horizontal;\n                      var _loop7 = function _loop7(_i12) {\n                        dummyToNodeForHorizontalAlignment.set(\"dummy\" + _i12, []);\n                        horizontalAlignment[_i12].forEach(function (nodeId) {\n                          nodeToDummyForHorizontalAlignment.set(nodeId, \"dummy\" + _i12);\n                          dummyToNodeForHorizontalAlignment.get(\"dummy\" + _i12).push(nodeId);\n                          if (fixedNodes.has(nodeId)) {\n                            fixedNodesOnVertical.add(\"dummy\" + _i12);\n                          }\n                        });\n                        dummyPositionsForHorizontalAlignment.set(\"dummy\" + _i12, yCoords[nodeIndexes.get(horizontalAlignment[_i12][0])]);\n                      };\n                      for (var _i12 = 0; _i12 < horizontalAlignment.length; _i12++) {\n                        _loop7(_i12);\n                      }\n                    }\n                  }\n\n                  // construct horizontal and vertical dags (subgraphs) from overall dag\n                  var dagOnHorizontal = new Map();\n                  var dagOnVertical = new Map();\n                  var _loop8 = function _loop8(nodeId) {\n                    dag.get(nodeId).forEach(function (adjacent) {\n                      var sourceId = void 0;\n                      var targetNode = void 0;\n                      if (adjacent[\"direction\"] == \"horizontal\") {\n                        sourceId = nodeToDummyForVerticalAlignment.get(nodeId) ? nodeToDummyForVerticalAlignment.get(nodeId) : nodeId;\n                        if (nodeToDummyForVerticalAlignment.get(adjacent.id)) {\n                          targetNode = {\n                            id: nodeToDummyForVerticalAlignment.get(adjacent.id),\n                            gap: adjacent.gap,\n                            direction: adjacent.direction\n                          };\n                        } else {\n                          targetNode = adjacent;\n                        }\n                        if (dagOnHorizontal.has(sourceId)) {\n                          dagOnHorizontal.get(sourceId).push(targetNode);\n                        } else {\n                          dagOnHorizontal.set(sourceId, [targetNode]);\n                        }\n                        if (!dagOnHorizontal.has(targetNode.id)) {\n                          dagOnHorizontal.set(targetNode.id, []);\n                        }\n                      } else {\n                        sourceId = nodeToDummyForHorizontalAlignment.get(nodeId) ? nodeToDummyForHorizontalAlignment.get(nodeId) : nodeId;\n                        if (nodeToDummyForHorizontalAlignment.get(adjacent.id)) {\n                          targetNode = {\n                            id: nodeToDummyForHorizontalAlignment.get(adjacent.id),\n                            gap: adjacent.gap,\n                            direction: adjacent.direction\n                          };\n                        } else {\n                          targetNode = adjacent;\n                        }\n                        if (dagOnVertical.has(sourceId)) {\n                          dagOnVertical.get(sourceId).push(targetNode);\n                        } else {\n                          dagOnVertical.set(sourceId, [targetNode]);\n                        }\n                        if (!dagOnVertical.has(targetNode.id)) {\n                          dagOnVertical.set(targetNode.id, []);\n                        }\n                      }\n                    });\n                  };\n                  var _iteratorNormalCompletion5 = true;\n                  var _didIteratorError5 = false;\n                  var _iteratorError5 = undefined;\n                  try {\n                    for (var _iterator5 = dag.keys()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                      var nodeId = _step5.value;\n                      _loop8(nodeId);\n                    }\n\n                    // find source nodes of each component in horizontal and vertical dags\n                  } catch (err) {\n                    _didIteratorError5 = true;\n                    _iteratorError5 = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                        _iterator5.return();\n                      }\n                    } finally {\n                      if (_didIteratorError5) {\n                        throw _iteratorError5;\n                      }\n                    }\n                  }\n                  var undirectedOnHorizontal = dagToUndirected(dagOnHorizontal);\n                  var undirectedOnVertical = dagToUndirected(dagOnVertical);\n                  var componentsOnHorizontal = findComponents(undirectedOnHorizontal);\n                  var componentsOnVertical = findComponents(undirectedOnVertical);\n                  var reversedDagOnHorizontal = dagToReversed(dagOnHorizontal);\n                  var reversedDagOnVertical = dagToReversed(dagOnVertical);\n                  var componentSourcesOnHorizontal = [];\n                  var componentSourcesOnVertical = [];\n                  componentsOnHorizontal.forEach(function (component, index) {\n                    componentSourcesOnHorizontal[index] = [];\n                    component.forEach(function (nodeId) {\n                      if (reversedDagOnHorizontal.get(nodeId).length == 0) {\n                        componentSourcesOnHorizontal[index].push(nodeId);\n                      }\n                    });\n                  });\n                  componentsOnVertical.forEach(function (component, index) {\n                    componentSourcesOnVertical[index] = [];\n                    component.forEach(function (nodeId) {\n                      if (reversedDagOnVertical.get(nodeId).length == 0) {\n                        componentSourcesOnVertical[index].push(nodeId);\n                      }\n                    });\n                  });\n\n                  // calculate appropriate positioning for subgraphs\n                  var positionMapHorizontal = findAppropriatePositionForRelativePlacement(dagOnHorizontal, \"horizontal\", fixedNodesOnHorizontal, dummyPositionsForVerticalAlignment, componentSourcesOnHorizontal);\n                  var positionMapVertical = findAppropriatePositionForRelativePlacement(dagOnVertical, \"vertical\", fixedNodesOnVertical, dummyPositionsForHorizontalAlignment, componentSourcesOnVertical);\n\n                  // update positions of the nodes based on relative placement constraints\n\n                  var _loop9 = function _loop9(key) {\n                    if (dummyToNodeForVerticalAlignment.get(key)) {\n                      dummyToNodeForVerticalAlignment.get(key).forEach(function (nodeId) {\n                        xCoords[nodeIndexes.get(nodeId)] = positionMapHorizontal.get(key);\n                      });\n                    } else {\n                      xCoords[nodeIndexes.get(key)] = positionMapHorizontal.get(key);\n                    }\n                  };\n                  var _iteratorNormalCompletion6 = true;\n                  var _didIteratorError6 = false;\n                  var _iteratorError6 = undefined;\n                  try {\n                    for (var _iterator6 = positionMapHorizontal.keys()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                      var key = _step6.value;\n                      _loop9(key);\n                    }\n                  } catch (err) {\n                    _didIteratorError6 = true;\n                    _iteratorError6 = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                        _iterator6.return();\n                      }\n                    } finally {\n                      if (_didIteratorError6) {\n                        throw _iteratorError6;\n                      }\n                    }\n                  }\n                  var _loop10 = function _loop10(key) {\n                    if (dummyToNodeForHorizontalAlignment.get(key)) {\n                      dummyToNodeForHorizontalAlignment.get(key).forEach(function (nodeId) {\n                        yCoords[nodeIndexes.get(nodeId)] = positionMapVertical.get(key);\n                      });\n                    } else {\n                      yCoords[nodeIndexes.get(key)] = positionMapVertical.get(key);\n                    }\n                  };\n                  var _iteratorNormalCompletion7 = true;\n                  var _didIteratorError7 = false;\n                  var _iteratorError7 = undefined;\n                  try {\n                    for (var _iterator7 = positionMapVertical.keys()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                      var key = _step7.value;\n                      _loop10(key);\n                    }\n                  } catch (err) {\n                    _didIteratorError7 = true;\n                    _iteratorError7 = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                        _iterator7.return();\n                      }\n                    } finally {\n                      if (_didIteratorError7) {\n                        throw _iteratorError7;\n                      }\n                    }\n                  }\n                })();\n              }\n            }\n\n            // assign new coordinates to nodes after constraint handling\n            for (var _i13 = 0; _i13 < allNodes.length; _i13++) {\n              var _node = allNodes[_i13];\n              if (_node.getChild() == null) {\n                _node.setCenter(xCoords[nodeIndexes.get(_node.id)], yCoords[nodeIndexes.get(_node.id)]);\n              }\n            }\n          };\n          module.exports = ConstraintHandler;\n\n          /***/\n        },\n\n        /***/551: /***/module => {\n          module.exports = __WEBPACK_EXTERNAL_MODULE__551__;\n\n          /***/\n        }\n\n        /******/\n      };\n      /************************************************************************/\n      /******/ // The module cache\n      /******/\n      var __webpack_module_cache__ = {};\n      /******/\n      /******/ // The require function\n      /******/\n      function __webpack_require__(moduleId) {\n        /******/ // Check if module is in cache\n        /******/var cachedModule = __webpack_module_cache__[moduleId];\n        /******/\n        if (cachedModule !== undefined) {\n          /******/return cachedModule.exports;\n          /******/\n        }\n        /******/ // Create a new module (and put it into the cache)\n        /******/\n        var module = __webpack_module_cache__[moduleId] = {\n          /******/ // no module.id needed\n          /******/ // no module.loaded needed\n          /******/exports: {}\n          /******/\n        };\n        /******/\n        /******/ // Execute the module function\n        /******/\n        __webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n        /******/\n        /******/ // Return the exports of the module\n        /******/\n        return module.exports;\n        /******/\n      }\n      /******/\n      /************************************************************************/\n      /******/\n      /******/ // startup\n      /******/ // Load entry module and return exports\n      /******/ // This entry module is referenced by other modules so it can't be inlined\n      /******/\n      var __webpack_exports__ = __webpack_require__(45);\n      /******/\n      /******/\n      return __webpack_exports__;\n      /******/\n    })()\n  );\n});","map":{"version":3,"names":["webpackUniversalModuleDefinition","root","factory","exports","module","require","define","amd","__WEBPACK_EXTERNAL_MODULE__551__","__webpack_modules__","__unused_webpack_exports","__webpack_require__","coseBase","layoutBase","CoSEConstants","CoSEEdge","CoSEGraph","CoSEGraphManager","CoSELayout","CoSENode","ConstraintHandler","FDLayoutConstants","prop","DEFAULT_USE_MULTI_LEVEL_SCALING","DEFAULT_RADIAL_SEPARATION","DEFAULT_EDGE_LENGTH","DEFAULT_COMPONENT_SEPERATION","TILE","TILING_PADDING_VERTICAL","TILING_PADDING_HORIZONTAL","TRANSFORM_ON_CONSTRAINT_HANDLING","ENFORCE_CONSTRAINTS","APPLY_LAYOUT","RELAX_MOVEMENT_ON_CONSTRAINTS","TREE_REDUCTION_ON_INCREMENTAL","PURE_INCREMENTAL","DEFAULT_INCREMENTAL","FDLayoutEdge","source","target","vEdge","call","prototype","Object","create","LGraph","parent","graphMgr","vGraph","LGraphManager","layout","FDLayout","LayoutConstants","Point","PointD","DimensionD","Layout","Integer","IGeometry","Transform","LinkedList","toBeTiled","constraints","newGraphManager","gm","graphManager","newGraph","newNode","vNode","newEdge","initParameters","arguments","isSubLayout","idealEdgeLength","useSmartIdealEdgeLengthCalculation","DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION","gravityConstant","DEFAULT_GRAVITY_STRENGTH","compoundGravityConstant","DEFAULT_COMPOUND_GRAVITY_STRENGTH","gravityRangeFactor","DEFAULT_GRAVITY_RANGE_FACTOR","compoundGravityRangeFactor","DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR","prunedNodesAll","growTreeIterations","afterGrowthIterations","isTreeGrowing","isGrowthFinished","initSpringEmbedder","coolingCycle","maxCoolingCycle","maxIterations","CONVERGENCE_CHECK_PERIOD","finalTemperature","coolingAdjuster","createBendsAsNeeded","DEFAULT_CREATE_BENDS_AS_NEEDED","createBendpoints","resetAllEdges","level","classicLayout","nodesWithGravity","calculateNodesToApplyGravitationTo","setAllNodesToApplyGravitation","calcNoOfChildrenForAllNodes","calcLowestCommonAncestors","calcInclusionTreeDepths","getRoot","calcEstimatedSize","calcIdealEdgeLengths","incremental","forest","getFlatForest","length","positionNodesRadially","reduceTrees","resetAllNodesToApplyGravitation","allNodes","Set","getAllNodes","intersection","filter","x","has","positionNodesRandomly","keys","handleConstraints","initConstraintVariables","runSpringEmbedder","tick","totalIterations","isConverged","layoutQuality","coolingFactor","Math","max","initialCoolingFactor","pow","log","animationPeriod","ceil","initialAnimationPeriod","sqrt","updateBounds","updateGrid","growTree","DEFAULT_COOLING_FACTOR_INCREMENTAL","gridUpdateAllowed","forceToNodeSurroundingUpdate","totalDisplacement","calcSpringForces","calcRepulsionForces","calcGravitationalForces","moveNodes","animate","getPositionsData","pData","i","rect","id","getCenterX","y","getCenterY","w","width","h","height","layoutEnded","ANIMATE","emit","lNodes","node","calculateDisplacement","updateDisplacements","move","self","idToNodeMap","Map","fixedNodeSet","set","calculateCompoundWeight","compoundNode","nodes","getChild","getNodes","fixedNodeWeight","fixedNodeConstraint","forEach","nodeData","add","nodeId","relativePlacementConstraint","nodeToDummyForVerticalAlignment","nodeToDummyForHorizontalAlignment","dummyToNodeForVerticalAlignment","dummyToNodeForHorizontalAlignment","fixedNodesOnHorizontal","fixedNodesOnVertical","alignmentConstraint","vertical","verticalAlignment","get","push","horizontal","horizontalAlignment","shuffle","array","j","floor","random","nodesInRelativeHorizontal","nodesInRelativeVertical","nodeToRelativeConstraintMapHorizontal","nodeToRelativeConstraintMapVertical","nodeToTempPositionMapHorizontal","nodeToTempPositionMapVertical","constraint","left","nodeIdLeft","nodeIdRight","right","includes","gap","nodeIdTop","top","nodeIdBottom","bottom","subGraphOnHorizontal","subGraphOnVertical","constructComponents","graph","fixedNodes","components","isFixed","queue","visited","count","value","key","currentNode","shift","neighbors","neighbor","resultOnHorizontal","componentsOnHorizontal","fixedComponentsOnHorizontal","resultOnVertical","componentsOnVertical","fixedComponentsOnVertical","fixedNode","displacementX","displacementY","allVerticalAlignments","totalDisplacementX","averageDisplacementX","allHorizontalAlignments","totalDisplacementY","averageDisplacementY","displacement","diff","component","sum","actualNodes","averageDisplacement","nodeList","graphs","getGraphs","size","updateConnected","isConnected","concat","edges","getAllEdges","edge","getSource","getTarget","getBendpoints","createDummyNodesForBendpoints","edgeList","getEdgeListToNode","k","multiEdge","currentStartingPoint","numberOfColumns","currentY","currentX","point","tree","centerNode","findCenterOfTree","radialLayout","transform","WORLD_CENTER_X","WORLD_CENTER_Y","startingPoint","radialSep","maxDiagonalInTree","branchRadialLayout","bounds","calculateBounds","setDeviceOrgX","getMinX","setDeviceOrgY","getMinY","setWorldOrgX","setWorldOrgY","bottomRight","getMaxX","getMaxY","inverseTransformPoint","parentOfNode","startAngle","endAngle","distance","radialSeparation","halfInterval","nodeAngle","teta","TWO_PI","cos_teta","cos","x_","y_","sin","setCenter","neighborEdges","getEdges","childCount","branchCount","incEdgesCount","startIndex","getEdgesBetween","temp","splice","index","indexOf","stepAngle","abs","currentNeighbor","getOtherEnd","childStartAngle","childEndAngle","maxDiagonal","MIN_VALUE","diagonal","getDiagonal","calcRepulsionRange","groupZeroDegreeMembers","tempMemberGroups","memberGroups","idToDummyNode","zeroDegree","getParent","getNodeDegreeWithChildren","undefined","getToBeTiled","p_id","dummyCompoundId","dummyCompound","paddingLeft","paddingRight","paddingBottom","paddingTop","dummyParentGraph","getGraphManager","parentGraph","remove","clearCompounds","childGraphMap","idToNode","performDFSOnCompounds","compoundOrder","child","resetAllNodes","tileCompoundMembers","clearZeroDegreeMembers","tiledZeroDegreePack","tileNodes","centerX","centerY","labelMarginLeft","labelMarginTop","NODE_DIMENSIONS_INCLUDE_LABELS","labelWidth","labelPosHorizontal","setWidth","labelHeight","labelPosVertical","setHeight","repopulateCompounds","lCompoundNode","horizontalMargin","verticalMargin","adjustLocations","tiledMemberPack","repopulateZeroDegreeMembers","tiledPack","childGraph","children","theChild","getNodeDegree","degree","fillCompexOrderByDFS","organization","compoundHorizontalMargin","compoundVerticalMargin","compoundLabelMarginLeft","compoundLabelMarginTop","rows","row","maxHeight","lnode","horizontalPadding","verticalPadding","minWidth","horizontalOrg","tileNodesByFavoringDim","verticalOrg","horizontalRatio","getOrgRatio","verticalRatio","bestOrg","ratio","calcIdealRowWidth","members","favorHorizontalDim","membersSize","totalWidth","totalHeight","maxWidth","getWidth","getHeight","averageWidth","averageHeight","delta","horizontalCountDouble","horizontalCount","idealWidth","tilingCompareBy","TILING_COMPARE_BY","rowWidth","rowHeight","idealRowWidth","getNodeArea","n","areaCompareFcn","n1","n2","sort","cmpBy","sumCenterX","sumCenterY","lNode","insertNodeToRow","canAddHorizontal","rowIndex","getShortestRowIndex","shiftToLastRow","minCompoundSize","secondDimension","extraHeight","r","min","Number","MAX_VALUE","getLongestRowIndex","extraWidth","lastRowIndex","lastRowWidth","sri","hDiff","add_to_row_ratio","add_new_row_ratio","longest","last","instance","prevTotal","finalTotal","tilingPreLayout","tilingPostLayout","containsLeaf","prunedNodesInStepTemp","isInterGraph","otherEnd","relativePosition","getOwner","prunedNodesInStep","lengthOfPrunedNodesInStep","findPlaceforPrunedNode","gridForPrunedNode","nodeToConnect","prunedNode","startGridX","startX","finishGridX","finishX","startGridY","startY","finishGridY","finishY","upNodeCount","downNodeCount","rightNodeCount","leftNodeCount","controlRegions","grid","minCount","minIndex","FDLayoutNode","IMath","loc","getLayout","springForceX","repulsionForceX","gravitationForceX","springForceY","repulsionForceY","gravitationForceY","noOfChildren","maxNodeDisplacement","sign","propogateDisplacementToChildren","dX","dY","moveBy","setPred1","pred1","getPred1","getPred2","pred2","setNext","next","getNext","setProcessed","processed","isProcessed","_toConsumableArray","arr","Array","isArray","arr2","from","Matrix","SVD","nodeIndexes","xCoords","yCoords","calculatePositionDiff","pos1","pos2","calculateAvgPosition","nodeIdSet","xPosSum","yPosSum","findAppropriatePositionForRelativePlacement","direction","dummyPositions","componentSources","setUnion","setA","setB","union","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","Symbol","iterator","_step","done","elem","err","return","inDegrees","adjacent","positionMap","pastMap","NEGATIVE_INFINITY","fixedIds","position","fixedId","_position","_loop","fixedPosition","sinkNodes","_components","isFixedComponent","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","isExist","existAt","ele","minBefore","POSITIVE_INFINITY","minAfter","maxBefore","maxAfter","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","_step3","posBefore","posAfter","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_iterator4","_step4","_nodeId","applyReflectionForRelativePlacement","relativePlacementConstraints","reflectOnY","notReflectOnY","reflectOnX","notReflectOnX","_i","_i2","_i3","findComponents","_currentNode","dagToUndirected","dag","undirected","dagToReversed","reversed","targetMatrix","sourceMatrix","standardTransformation","reflectionType","dagUndirected","verticalAlign","_loop2","_i4","alignmentSet","xPos","values","horizontalAlign","_loop3","_i5","yPos","largestComponentSize","largestComponentIndex","_i6","constraintsInlargestComponent","positionMapHorizontal","positionMapVertical","transformationMatrix","targetMatrixTranspose","transpose","sourceMatrixTranspose","_i7","multGamma","tempMatrix","multMat","SVDResult","svd","V","U","_i8","temp1","temp2","temp3","dotProduct","translationAmount","posInTheory","posDesired","posDiff","xAlign","_loop4","_i9","yAlign","_loop5","_i10","dummyPositionsForVerticalAlignment","dummyPositionsForHorizontalAlignment","_loop6","_i11","_loop7","_i12","dagOnHorizontal","dagOnVertical","_loop8","sourceId","targetNode","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_iterator5","_step5","undirectedOnHorizontal","undirectedOnVertical","reversedDagOnHorizontal","reversedDagOnVertical","componentSourcesOnHorizontal","componentSourcesOnVertical","_loop9","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_iterator6","_step6","_loop10","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_iterator7","_step7","_i13","_node","__webpack_module_cache__","moduleId","cachedModule","__webpack_exports__"],"sources":["/home/mdreger/Documents/MatGraphAI/MatGraphAI/frontend/node_modules/cose-base/cose-base.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"layout-base\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"layout-base\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"coseBase\"] = factory(require(\"layout-base\"));\n\telse\n\t\troot[\"coseBase\"] = factory(root[\"layoutBase\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__551__) {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 45:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\nvar coseBase = {};\n\ncoseBase.layoutBase = __webpack_require__(551);\ncoseBase.CoSEConstants = __webpack_require__(806);\ncoseBase.CoSEEdge = __webpack_require__(767);\ncoseBase.CoSEGraph = __webpack_require__(880);\ncoseBase.CoSEGraphManager = __webpack_require__(578);\ncoseBase.CoSELayout = __webpack_require__(765);\ncoseBase.CoSENode = __webpack_require__(991);\ncoseBase.ConstraintHandler = __webpack_require__(902);\n\nmodule.exports = coseBase;\n\n/***/ }),\n\n/***/ 806:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\nvar FDLayoutConstants = __webpack_require__(551).FDLayoutConstants;\n\nfunction CoSEConstants() {}\n\n//CoSEConstants inherits static props in FDLayoutConstants\nfor (var prop in FDLayoutConstants) {\n  CoSEConstants[prop] = FDLayoutConstants[prop];\n}\n\nCoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;\nCoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\nCoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;\nCoSEConstants.TILE = true;\nCoSEConstants.TILING_PADDING_VERTICAL = 10;\nCoSEConstants.TILING_PADDING_HORIZONTAL = 10;\nCoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\nCoSEConstants.ENFORCE_CONSTRAINTS = true;\nCoSEConstants.APPLY_LAYOUT = true;\nCoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS = true;\nCoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true; // this should be set to false if there will be a constraint\n// This constant is for differentiating whether actual layout algorithm that uses cose-base wants to apply only incremental layout or \n// an incremental layout on top of a randomized layout. If it is only incremental layout, then this constant should be true.\nCoSEConstants.PURE_INCREMENTAL = CoSEConstants.DEFAULT_INCREMENTAL;\n\nmodule.exports = CoSEConstants;\n\n/***/ }),\n\n/***/ 767:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\nvar FDLayoutEdge = __webpack_require__(551).FDLayoutEdge;\n\nfunction CoSEEdge(source, target, vEdge) {\n  FDLayoutEdge.call(this, source, target, vEdge);\n}\n\nCoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);\nfor (var prop in FDLayoutEdge) {\n  CoSEEdge[prop] = FDLayoutEdge[prop];\n}\n\nmodule.exports = CoSEEdge;\n\n/***/ }),\n\n/***/ 880:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\nvar LGraph = __webpack_require__(551).LGraph;\n\nfunction CoSEGraph(parent, graphMgr, vGraph) {\n  LGraph.call(this, parent, graphMgr, vGraph);\n}\n\nCoSEGraph.prototype = Object.create(LGraph.prototype);\nfor (var prop in LGraph) {\n  CoSEGraph[prop] = LGraph[prop];\n}\n\nmodule.exports = CoSEGraph;\n\n/***/ }),\n\n/***/ 578:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\nvar LGraphManager = __webpack_require__(551).LGraphManager;\n\nfunction CoSEGraphManager(layout) {\n  LGraphManager.call(this, layout);\n}\n\nCoSEGraphManager.prototype = Object.create(LGraphManager.prototype);\nfor (var prop in LGraphManager) {\n  CoSEGraphManager[prop] = LGraphManager[prop];\n}\n\nmodule.exports = CoSEGraphManager;\n\n/***/ }),\n\n/***/ 765:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\nvar FDLayout = __webpack_require__(551).FDLayout;\nvar CoSEGraphManager = __webpack_require__(578);\nvar CoSEGraph = __webpack_require__(880);\nvar CoSENode = __webpack_require__(991);\nvar CoSEEdge = __webpack_require__(767);\nvar CoSEConstants = __webpack_require__(806);\nvar ConstraintHandler = __webpack_require__(902);\nvar FDLayoutConstants = __webpack_require__(551).FDLayoutConstants;\nvar LayoutConstants = __webpack_require__(551).LayoutConstants;\nvar Point = __webpack_require__(551).Point;\nvar PointD = __webpack_require__(551).PointD;\nvar DimensionD = __webpack_require__(551).DimensionD;\nvar Layout = __webpack_require__(551).Layout;\nvar Integer = __webpack_require__(551).Integer;\nvar IGeometry = __webpack_require__(551).IGeometry;\nvar LGraph = __webpack_require__(551).LGraph;\nvar Transform = __webpack_require__(551).Transform;\nvar LinkedList = __webpack_require__(551).LinkedList;\n\nfunction CoSELayout() {\n  FDLayout.call(this);\n\n  this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled\n  this.constraints = {}; // keep layout constraints\n}\n\nCoSELayout.prototype = Object.create(FDLayout.prototype);\n\nfor (var prop in FDLayout) {\n  CoSELayout[prop] = FDLayout[prop];\n}\n\nCoSELayout.prototype.newGraphManager = function () {\n  var gm = new CoSEGraphManager(this);\n  this.graphManager = gm;\n  return gm;\n};\n\nCoSELayout.prototype.newGraph = function (vGraph) {\n  return new CoSEGraph(null, this.graphManager, vGraph);\n};\n\nCoSELayout.prototype.newNode = function (vNode) {\n  return new CoSENode(this.graphManager, vNode);\n};\n\nCoSELayout.prototype.newEdge = function (vEdge) {\n  return new CoSEEdge(null, null, vEdge);\n};\n\nCoSELayout.prototype.initParameters = function () {\n  FDLayout.prototype.initParameters.call(this, arguments);\n  if (!this.isSubLayout) {\n    if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10) {\n      this.idealEdgeLength = 10;\n    } else {\n      this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;\n    }\n\n    this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n    this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n    this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n    this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n    this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n\n    // variables for tree reduction support\n    this.prunedNodesAll = [];\n    this.growTreeIterations = 0;\n    this.afterGrowthIterations = 0;\n    this.isTreeGrowing = false;\n    this.isGrowthFinished = false;\n  }\n};\n\n// This method is used to set CoSE related parameters used by spring embedder.\nCoSELayout.prototype.initSpringEmbedder = function () {\n  FDLayout.prototype.initSpringEmbedder.call(this);\n\n  // variables for cooling\n  this.coolingCycle = 0;\n  this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;\n  this.finalTemperature = 0.04;\n  this.coolingAdjuster = 1;\n};\n\nCoSELayout.prototype.layout = function () {\n  var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n  if (createBendsAsNeeded) {\n    this.createBendpoints();\n    this.graphManager.resetAllEdges();\n  }\n\n  this.level = 0;\n  return this.classicLayout();\n};\n\nCoSELayout.prototype.classicLayout = function () {\n  this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();\n  this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);\n  this.calcNoOfChildrenForAllNodes();\n  this.graphManager.calcLowestCommonAncestors();\n  this.graphManager.calcInclusionTreeDepths();\n  this.graphManager.getRoot().calcEstimatedSize();\n  this.calcIdealEdgeLengths();\n\n  if (!this.incremental) {\n    var forest = this.getFlatForest();\n\n    // The graph associated with this layout is flat and a forest\n    if (forest.length > 0) {\n      this.positionNodesRadially(forest);\n    }\n    // The graph associated with this layout is not flat or a forest\n    else {\n        // Reduce the trees when incremental mode is not enabled and graph is not a forest \n        this.reduceTrees();\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.positionNodesRandomly();\n      }\n  } else {\n    if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {\n      // Reduce the trees in incremental mode if only this constant is set to true \n      this.reduceTrees();\n      // Update nodes that gravity will be applied\n      this.graphManager.resetAllNodesToApplyGravitation();\n      var allNodes = new Set(this.getAllNodes());\n      var intersection = this.nodesWithGravity.filter(function (x) {\n        return allNodes.has(x);\n      });\n      this.graphManager.setAllNodesToApplyGravitation(intersection);\n    }\n  }\n\n  if (Object.keys(this.constraints).length > 0) {\n    ConstraintHandler.handleConstraints(this);\n    this.initConstraintVariables();\n  }\n\n  this.initSpringEmbedder();\n  if (CoSEConstants.APPLY_LAYOUT) {\n    this.runSpringEmbedder();\n  }\n\n  return true;\n};\n\nCoSELayout.prototype.tick = function () {\n  this.totalIterations++;\n\n  if (this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.prunedNodesAll.length > 0) {\n      this.isTreeGrowing = true;\n    } else {\n      return true;\n    }\n  }\n\n  if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.isConverged()) {\n      if (this.prunedNodesAll.length > 0) {\n        this.isTreeGrowing = true;\n      } else {\n        return true;\n      }\n    }\n\n    this.coolingCycle++;\n\n    if (this.layoutQuality == 0) {\n      // quality - \"draft\"\n      this.coolingAdjuster = this.coolingCycle;\n    } else if (this.layoutQuality == 1) {\n      // quality - \"default\"\n      this.coolingAdjuster = this.coolingCycle / 3;\n    }\n\n    // cooling schedule is based on http://www.btluke.com/simanf1.html -> cooling schedule 3\n    this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);\n    this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));\n  }\n  // Operations while tree is growing again \n  if (this.isTreeGrowing) {\n    if (this.growTreeIterations % 10 == 0) {\n      if (this.prunedNodesAll.length > 0) {\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        this.growTree(this.prunedNodesAll);\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2;else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n      } else {\n        this.isTreeGrowing = false;\n        this.isGrowthFinished = true;\n      }\n    }\n    this.growTreeIterations++;\n  }\n  // Operations after growth is finished\n  if (this.isGrowthFinished) {\n    if (this.isConverged()) {\n      return true;\n    }\n    if (this.afterGrowthIterations % 10 == 0) {\n      this.graphManager.updateBounds();\n      this.updateGrid();\n    }\n    if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2 * ((100 - this.afterGrowthIterations) / 100);else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);\n    this.afterGrowthIterations++;\n  }\n\n  var gridUpdateAllowed = !this.isTreeGrowing && !this.isGrowthFinished;\n  var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;\n\n  this.totalDisplacement = 0;\n  this.graphManager.updateBounds();\n  this.calcSpringForces();\n  this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);\n  this.calcGravitationalForces();\n  this.moveNodes();\n  this.animate();\n\n  return false; // Layout is not ended yet return false\n};\n\nCoSELayout.prototype.getPositionsData = function () {\n  var allNodes = this.graphManager.getAllNodes();\n  var pData = {};\n  for (var i = 0; i < allNodes.length; i++) {\n    var rect = allNodes[i].rect;\n    var id = allNodes[i].id;\n    pData[id] = {\n      id: id,\n      x: rect.getCenterX(),\n      y: rect.getCenterY(),\n      w: rect.width,\n      h: rect.height\n    };\n  }\n\n  return pData;\n};\n\nCoSELayout.prototype.runSpringEmbedder = function () {\n  this.initialAnimationPeriod = 25;\n  this.animationPeriod = this.initialAnimationPeriod;\n  var layoutEnded = false;\n\n  // If aminate option is 'during' signal that layout is supposed to start iterating\n  if (FDLayoutConstants.ANIMATE === 'during') {\n    this.emit('layoutstarted');\n  } else {\n    // If aminate option is 'during' tick() function will be called on index.js\n    while (!layoutEnded) {\n      layoutEnded = this.tick();\n    }\n\n    this.graphManager.updateBounds();\n  }\n};\n\n// overrides moveNodes method in FDLayout\nCoSELayout.prototype.moveNodes = function () {\n  var lNodes = this.getAllNodes();\n  var node;\n\n  // calculate displacement for each node \n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    node.calculateDisplacement();\n  }\n\n  if (Object.keys(this.constraints).length > 0) {\n    this.updateDisplacements();\n  }\n\n  // move each node\n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    node.move();\n  }\n};\n\n// constraint related methods: initConstraintVariables and updateDisplacements\n\n// initialize constraint related variables\nCoSELayout.prototype.initConstraintVariables = function () {\n  var self = this;\n  this.idToNodeMap = new Map();\n  this.fixedNodeSet = new Set();\n\n  var allNodes = this.graphManager.getAllNodes();\n\n  // fill idToNodeMap\n  for (var i = 0; i < allNodes.length; i++) {\n    var node = allNodes[i];\n    this.idToNodeMap.set(node.id, node);\n  }\n\n  // calculate fixed node weight for given compound node\n  var calculateCompoundWeight = function calculateCompoundWeight(compoundNode) {\n    var nodes = compoundNode.getChild().getNodes();\n    var node;\n    var fixedNodeWeight = 0;\n    for (var i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n      if (node.getChild() == null) {\n        if (self.fixedNodeSet.has(node.id)) {\n          fixedNodeWeight += 100;\n        }\n      } else {\n        fixedNodeWeight += calculateCompoundWeight(node);\n      }\n    }\n    return fixedNodeWeight;\n  };\n\n  if (this.constraints.fixedNodeConstraint) {\n    // fill fixedNodeSet\n    this.constraints.fixedNodeConstraint.forEach(function (nodeData) {\n      self.fixedNodeSet.add(nodeData.nodeId);\n    });\n\n    // assign fixed node weights to compounds if they contain fixed nodes\n    var allNodes = this.graphManager.getAllNodes();\n    var node;\n\n    for (var i = 0; i < allNodes.length; i++) {\n      node = allNodes[i];\n      if (node.getChild() != null) {\n        var fixedNodeWeight = calculateCompoundWeight(node);\n        if (fixedNodeWeight > 0) {\n          node.fixedNodeWeight = fixedNodeWeight;\n        }\n      }\n    }\n  }\n\n  if (this.constraints.relativePlacementConstraint) {\n    var nodeToDummyForVerticalAlignment = new Map();\n    var nodeToDummyForHorizontalAlignment = new Map();\n    this.dummyToNodeForVerticalAlignment = new Map();\n    this.dummyToNodeForHorizontalAlignment = new Map();\n    this.fixedNodesOnHorizontal = new Set();\n    this.fixedNodesOnVertical = new Set();\n\n    // fill maps and sets\n    this.fixedNodeSet.forEach(function (nodeId) {\n      self.fixedNodesOnHorizontal.add(nodeId);\n      self.fixedNodesOnVertical.add(nodeId);\n    });\n\n    if (this.constraints.alignmentConstraint) {\n      if (this.constraints.alignmentConstraint.vertical) {\n        var verticalAlignment = this.constraints.alignmentConstraint.vertical;\n        for (var i = 0; i < verticalAlignment.length; i++) {\n          this.dummyToNodeForVerticalAlignment.set(\"dummy\" + i, []);\n          verticalAlignment[i].forEach(function (nodeId) {\n            nodeToDummyForVerticalAlignment.set(nodeId, \"dummy\" + i);\n            self.dummyToNodeForVerticalAlignment.get(\"dummy\" + i).push(nodeId);\n            if (self.fixedNodeSet.has(nodeId)) {\n              self.fixedNodesOnHorizontal.add(\"dummy\" + i);\n            }\n          });\n        }\n      }\n      if (this.constraints.alignmentConstraint.horizontal) {\n        var horizontalAlignment = this.constraints.alignmentConstraint.horizontal;\n        for (var i = 0; i < horizontalAlignment.length; i++) {\n          this.dummyToNodeForHorizontalAlignment.set(\"dummy\" + i, []);\n          horizontalAlignment[i].forEach(function (nodeId) {\n            nodeToDummyForHorizontalAlignment.set(nodeId, \"dummy\" + i);\n            self.dummyToNodeForHorizontalAlignment.get(\"dummy\" + i).push(nodeId);\n            if (self.fixedNodeSet.has(nodeId)) {\n              self.fixedNodesOnVertical.add(\"dummy\" + i);\n            }\n          });\n        }\n      }\n    }\n\n    if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {\n\n      this.shuffle = function (array) {\n        var j, x, i;\n        for (i = array.length - 1; i >= 2 * array.length / 3; i--) {\n          j = Math.floor(Math.random() * (i + 1));\n          x = array[i];\n          array[i] = array[j];\n          array[j] = x;\n        }\n        return array;\n      };\n\n      this.nodesInRelativeHorizontal = [];\n      this.nodesInRelativeVertical = [];\n      this.nodeToRelativeConstraintMapHorizontal = new Map();\n      this.nodeToRelativeConstraintMapVertical = new Map();\n      this.nodeToTempPositionMapHorizontal = new Map();\n      this.nodeToTempPositionMapVertical = new Map();\n\n      // fill arrays and maps\n      this.constraints.relativePlacementConstraint.forEach(function (constraint) {\n        if (constraint.left) {\n          var nodeIdLeft = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;\n          var nodeIdRight = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;\n\n          if (!self.nodesInRelativeHorizontal.includes(nodeIdLeft)) {\n            self.nodesInRelativeHorizontal.push(nodeIdLeft);\n            self.nodeToRelativeConstraintMapHorizontal.set(nodeIdLeft, []);\n            if (self.dummyToNodeForVerticalAlignment.has(nodeIdLeft)) {\n              self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdLeft)[0]).getCenterX());\n            } else {\n              self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(nodeIdLeft).getCenterX());\n            }\n          }\n          if (!self.nodesInRelativeHorizontal.includes(nodeIdRight)) {\n            self.nodesInRelativeHorizontal.push(nodeIdRight);\n            self.nodeToRelativeConstraintMapHorizontal.set(nodeIdRight, []);\n            if (self.dummyToNodeForVerticalAlignment.has(nodeIdRight)) {\n              self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdRight)[0]).getCenterX());\n            } else {\n              self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(nodeIdRight).getCenterX());\n            }\n          }\n\n          self.nodeToRelativeConstraintMapHorizontal.get(nodeIdLeft).push({ right: nodeIdRight, gap: constraint.gap });\n          self.nodeToRelativeConstraintMapHorizontal.get(nodeIdRight).push({ left: nodeIdLeft, gap: constraint.gap });\n        } else {\n          var nodeIdTop = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;\n          var nodeIdBottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;\n\n          if (!self.nodesInRelativeVertical.includes(nodeIdTop)) {\n            self.nodesInRelativeVertical.push(nodeIdTop);\n            self.nodeToRelativeConstraintMapVertical.set(nodeIdTop, []);\n            if (self.dummyToNodeForHorizontalAlignment.has(nodeIdTop)) {\n              self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdTop)[0]).getCenterY());\n            } else {\n              self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(nodeIdTop).getCenterY());\n            }\n          }\n          if (!self.nodesInRelativeVertical.includes(nodeIdBottom)) {\n            self.nodesInRelativeVertical.push(nodeIdBottom);\n            self.nodeToRelativeConstraintMapVertical.set(nodeIdBottom, []);\n            if (self.dummyToNodeForHorizontalAlignment.has(nodeIdBottom)) {\n              self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdBottom)[0]).getCenterY());\n            } else {\n              self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(nodeIdBottom).getCenterY());\n            }\n          }\n          self.nodeToRelativeConstraintMapVertical.get(nodeIdTop).push({ bottom: nodeIdBottom, gap: constraint.gap });\n          self.nodeToRelativeConstraintMapVertical.get(nodeIdBottom).push({ top: nodeIdTop, gap: constraint.gap });\n        }\n      });\n    } else {\n      var subGraphOnHorizontal = new Map(); // subgraph from vertical RP constraints\n      var subGraphOnVertical = new Map(); // subgraph from vertical RP constraints\n\n      // construct subgraphs from relative placement constraints \n      this.constraints.relativePlacementConstraint.forEach(function (constraint) {\n        if (constraint.left) {\n          var left = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;\n          var right = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;\n          if (subGraphOnHorizontal.has(left)) {\n            subGraphOnHorizontal.get(left).push(right);\n          } else {\n            subGraphOnHorizontal.set(left, [right]);\n          }\n          if (subGraphOnHorizontal.has(right)) {\n            subGraphOnHorizontal.get(right).push(left);\n          } else {\n            subGraphOnHorizontal.set(right, [left]);\n          }\n        } else {\n          var top = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;\n          var bottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;\n          if (subGraphOnVertical.has(top)) {\n            subGraphOnVertical.get(top).push(bottom);\n          } else {\n            subGraphOnVertical.set(top, [bottom]);\n          }\n          if (subGraphOnVertical.has(bottom)) {\n            subGraphOnVertical.get(bottom).push(top);\n          } else {\n            subGraphOnVertical.set(bottom, [top]);\n          }\n        }\n      });\n\n      // function to construct components from a given graph \n      // also returns an array that keeps whether each component contains fixed node\n      var constructComponents = function constructComponents(graph, fixedNodes) {\n        var components = [];\n        var isFixed = [];\n        var queue = new LinkedList();\n        var visited = new Set();\n        var count = 0;\n\n        graph.forEach(function (value, key) {\n          if (!visited.has(key)) {\n            components[count] = [];\n            isFixed[count] = false;\n            var currentNode = key;\n            queue.push(currentNode);\n            visited.add(currentNode);\n            components[count].push(currentNode);\n\n            while (queue.length != 0) {\n              currentNode = queue.shift();\n              if (fixedNodes.has(currentNode)) {\n                isFixed[count] = true;\n              }\n              var neighbors = graph.get(currentNode);\n              neighbors.forEach(function (neighbor) {\n                if (!visited.has(neighbor)) {\n                  queue.push(neighbor);\n                  visited.add(neighbor);\n                  components[count].push(neighbor);\n                }\n              });\n            }\n            count++;\n          }\n        });\n\n        return { components: components, isFixed: isFixed };\n      };\n\n      var resultOnHorizontal = constructComponents(subGraphOnHorizontal, self.fixedNodesOnHorizontal);\n      this.componentsOnHorizontal = resultOnHorizontal.components;\n      this.fixedComponentsOnHorizontal = resultOnHorizontal.isFixed;\n      var resultOnVertical = constructComponents(subGraphOnVertical, self.fixedNodesOnVertical);\n      this.componentsOnVertical = resultOnVertical.components;\n      this.fixedComponentsOnVertical = resultOnVertical.isFixed;\n    }\n  }\n};\n\n// updates node displacements based on constraints\nCoSELayout.prototype.updateDisplacements = function () {\n  var self = this;\n  if (this.constraints.fixedNodeConstraint) {\n    this.constraints.fixedNodeConstraint.forEach(function (nodeData) {\n      var fixedNode = self.idToNodeMap.get(nodeData.nodeId);\n      fixedNode.displacementX = 0;\n      fixedNode.displacementY = 0;\n    });\n  }\n\n  if (this.constraints.alignmentConstraint) {\n    if (this.constraints.alignmentConstraint.vertical) {\n      var allVerticalAlignments = this.constraints.alignmentConstraint.vertical;\n      for (var i = 0; i < allVerticalAlignments.length; i++) {\n        var totalDisplacementX = 0;\n        for (var j = 0; j < allVerticalAlignments[i].length; j++) {\n          if (this.fixedNodeSet.has(allVerticalAlignments[i][j])) {\n            totalDisplacementX = 0;\n            break;\n          }\n          totalDisplacementX += this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX;\n        }\n        var averageDisplacementX = totalDisplacementX / allVerticalAlignments[i].length;\n        for (var j = 0; j < allVerticalAlignments[i].length; j++) {\n          this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX = averageDisplacementX;\n        }\n      }\n    }\n    if (this.constraints.alignmentConstraint.horizontal) {\n      var allHorizontalAlignments = this.constraints.alignmentConstraint.horizontal;\n      for (var i = 0; i < allHorizontalAlignments.length; i++) {\n        var totalDisplacementY = 0;\n        for (var j = 0; j < allHorizontalAlignments[i].length; j++) {\n          if (this.fixedNodeSet.has(allHorizontalAlignments[i][j])) {\n            totalDisplacementY = 0;\n            break;\n          }\n          totalDisplacementY += this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY;\n        }\n        var averageDisplacementY = totalDisplacementY / allHorizontalAlignments[i].length;\n        for (var j = 0; j < allHorizontalAlignments[i].length; j++) {\n          this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY = averageDisplacementY;\n        }\n      }\n    }\n  }\n\n  if (this.constraints.relativePlacementConstraint) {\n\n    if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {\n      // shuffle array to randomize node processing order\n      if (this.totalIterations % 10 == 0) {\n        this.shuffle(this.nodesInRelativeHorizontal);\n        this.shuffle(this.nodesInRelativeVertical);\n      }\n\n      this.nodesInRelativeHorizontal.forEach(function (nodeId) {\n        if (!self.fixedNodesOnHorizontal.has(nodeId)) {\n          var displacement = 0;\n          if (self.dummyToNodeForVerticalAlignment.has(nodeId)) {\n            displacement = self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeId)[0]).displacementX;\n          } else {\n            displacement = self.idToNodeMap.get(nodeId).displacementX;\n          }\n          self.nodeToRelativeConstraintMapHorizontal.get(nodeId).forEach(function (constraint) {\n            if (constraint.right) {\n              var diff = self.nodeToTempPositionMapHorizontal.get(constraint.right) - self.nodeToTempPositionMapHorizontal.get(nodeId) - displacement;\n              if (diff < constraint.gap) {\n                displacement -= constraint.gap - diff;\n              }\n            } else {\n              var diff = self.nodeToTempPositionMapHorizontal.get(nodeId) - self.nodeToTempPositionMapHorizontal.get(constraint.left) + displacement;\n              if (diff < constraint.gap) {\n                displacement += constraint.gap - diff;\n              }\n            }\n          });\n          self.nodeToTempPositionMapHorizontal.set(nodeId, self.nodeToTempPositionMapHorizontal.get(nodeId) + displacement);\n          if (self.dummyToNodeForVerticalAlignment.has(nodeId)) {\n            self.dummyToNodeForVerticalAlignment.get(nodeId).forEach(function (nodeId) {\n              self.idToNodeMap.get(nodeId).displacementX = displacement;\n            });\n          } else {\n            self.idToNodeMap.get(nodeId).displacementX = displacement;\n          }\n        }\n      });\n\n      this.nodesInRelativeVertical.forEach(function (nodeId) {\n        if (!self.fixedNodesOnHorizontal.has(nodeId)) {\n          var displacement = 0;\n          if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) {\n            displacement = self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeId)[0]).displacementY;\n          } else {\n            displacement = self.idToNodeMap.get(nodeId).displacementY;\n          }\n          self.nodeToRelativeConstraintMapVertical.get(nodeId).forEach(function (constraint) {\n            if (constraint.bottom) {\n              var diff = self.nodeToTempPositionMapVertical.get(constraint.bottom) - self.nodeToTempPositionMapVertical.get(nodeId) - displacement;\n              if (diff < constraint.gap) {\n                displacement -= constraint.gap - diff;\n              }\n            } else {\n              var diff = self.nodeToTempPositionMapVertical.get(nodeId) - self.nodeToTempPositionMapVertical.get(constraint.top) + displacement;\n              if (diff < constraint.gap) {\n                displacement += constraint.gap - diff;\n              }\n            }\n          });\n          self.nodeToTempPositionMapVertical.set(nodeId, self.nodeToTempPositionMapVertical.get(nodeId) + displacement);\n          if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) {\n            self.dummyToNodeForHorizontalAlignment.get(nodeId).forEach(function (nodeId) {\n              self.idToNodeMap.get(nodeId).displacementY = displacement;\n            });\n          } else {\n            self.idToNodeMap.get(nodeId).displacementY = displacement;\n          }\n        }\n      });\n    } else {\n      for (var i = 0; i < this.componentsOnHorizontal.length; i++) {\n        var component = this.componentsOnHorizontal[i];\n        if (this.fixedComponentsOnHorizontal[i]) {\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n              this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function (nodeId) {\n                self.idToNodeMap.get(nodeId).displacementX = 0;\n              });\n            } else {\n              this.idToNodeMap.get(component[j]).displacementX = 0;\n            }\n          }\n        } else {\n          var sum = 0;\n          var count = 0;\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n              var actualNodes = this.dummyToNodeForVerticalAlignment.get(component[j]);\n              sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementX;\n              count += actualNodes.length;\n            } else {\n              sum += this.idToNodeMap.get(component[j]).displacementX;\n              count++;\n            }\n          }\n          var averageDisplacement = sum / count;\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n              this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function (nodeId) {\n                self.idToNodeMap.get(nodeId).displacementX = averageDisplacement;\n              });\n            } else {\n              this.idToNodeMap.get(component[j]).displacementX = averageDisplacement;\n            }\n          }\n        }\n      }\n\n      for (var i = 0; i < this.componentsOnVertical.length; i++) {\n        var component = this.componentsOnVertical[i];\n        if (this.fixedComponentsOnVertical[i]) {\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n              this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function (nodeId) {\n                self.idToNodeMap.get(nodeId).displacementY = 0;\n              });\n            } else {\n              this.idToNodeMap.get(component[j]).displacementY = 0;\n            }\n          }\n        } else {\n          var sum = 0;\n          var count = 0;\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n              var actualNodes = this.dummyToNodeForHorizontalAlignment.get(component[j]);\n              sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementY;\n              count += actualNodes.length;\n            } else {\n              sum += this.idToNodeMap.get(component[j]).displacementY;\n              count++;\n            }\n          }\n          var averageDisplacement = sum / count;\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n              this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function (nodeId) {\n                self.idToNodeMap.get(nodeId).displacementY = averageDisplacement;\n              });\n            } else {\n              this.idToNodeMap.get(component[j]).displacementY = averageDisplacement;\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nCoSELayout.prototype.calculateNodesToApplyGravitationTo = function () {\n  var nodeList = [];\n  var graph;\n\n  var graphs = this.graphManager.getGraphs();\n  var size = graphs.length;\n  var i;\n  for (i = 0; i < size; i++) {\n    graph = graphs[i];\n\n    graph.updateConnected();\n\n    if (!graph.isConnected) {\n      nodeList = nodeList.concat(graph.getNodes());\n    }\n  }\n\n  return nodeList;\n};\n\nCoSELayout.prototype.createBendpoints = function () {\n  var edges = [];\n  edges = edges.concat(this.graphManager.getAllEdges());\n  var visited = new Set();\n  var i;\n  for (i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n\n    if (!visited.has(edge)) {\n      var source = edge.getSource();\n      var target = edge.getTarget();\n\n      if (source == target) {\n        edge.getBendpoints().push(new PointD());\n        edge.getBendpoints().push(new PointD());\n        this.createDummyNodesForBendpoints(edge);\n        visited.add(edge);\n      } else {\n        var edgeList = [];\n\n        edgeList = edgeList.concat(source.getEdgeListToNode(target));\n        edgeList = edgeList.concat(target.getEdgeListToNode(source));\n\n        if (!visited.has(edgeList[0])) {\n          if (edgeList.length > 1) {\n            var k;\n            for (k = 0; k < edgeList.length; k++) {\n              var multiEdge = edgeList[k];\n              multiEdge.getBendpoints().push(new PointD());\n              this.createDummyNodesForBendpoints(multiEdge);\n            }\n          }\n          edgeList.forEach(function (edge) {\n            visited.add(edge);\n          });\n        }\n      }\n    }\n\n    if (visited.size == edges.length) {\n      break;\n    }\n  }\n};\n\nCoSELayout.prototype.positionNodesRadially = function (forest) {\n  // We tile the trees to a grid row by row; first tree starts at (0,0)\n  var currentStartingPoint = new Point(0, 0);\n  var numberOfColumns = Math.ceil(Math.sqrt(forest.length));\n  var height = 0;\n  var currentY = 0;\n  var currentX = 0;\n  var point = new PointD(0, 0);\n\n  for (var i = 0; i < forest.length; i++) {\n    if (i % numberOfColumns == 0) {\n      // Start of a new row, make the x coordinate 0, increment the\n      // y coordinate with the max height of the previous row\n      currentX = 0;\n      currentY = height;\n\n      if (i != 0) {\n        currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;\n      }\n\n      height = 0;\n    }\n\n    var tree = forest[i];\n\n    // Find the center of the tree\n    var centerNode = Layout.findCenterOfTree(tree);\n\n    // Set the staring point of the next tree\n    currentStartingPoint.x = currentX;\n    currentStartingPoint.y = currentY;\n\n    // Do a radial layout starting with the center\n    point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);\n\n    if (point.y > height) {\n      height = Math.floor(point.y);\n    }\n\n    currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);\n  }\n\n  this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));\n};\n\nCoSELayout.radialLayout = function (tree, centerNode, startingPoint) {\n  var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);\n  CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);\n  var bounds = LGraph.calculateBounds(tree);\n\n  var transform = new Transform();\n  transform.setDeviceOrgX(bounds.getMinX());\n  transform.setDeviceOrgY(bounds.getMinY());\n  transform.setWorldOrgX(startingPoint.x);\n  transform.setWorldOrgY(startingPoint.y);\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    node.transform(transform);\n  }\n\n  var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());\n\n  return transform.inverseTransformPoint(bottomRight);\n};\n\nCoSELayout.branchRadialLayout = function (node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {\n  // First, position this node by finding its angle.\n  var halfInterval = (endAngle - startAngle + 1) / 2;\n\n  if (halfInterval < 0) {\n    halfInterval += 180;\n  }\n\n  var nodeAngle = (halfInterval + startAngle) % 360;\n  var teta = nodeAngle * IGeometry.TWO_PI / 360;\n\n  // Make polar to java cordinate conversion.\n  var cos_teta = Math.cos(teta);\n  var x_ = distance * Math.cos(teta);\n  var y_ = distance * Math.sin(teta);\n\n  node.setCenter(x_, y_);\n\n  // Traverse all neighbors of this node and recursively call this\n  // function.\n  var neighborEdges = [];\n  neighborEdges = neighborEdges.concat(node.getEdges());\n  var childCount = neighborEdges.length;\n\n  if (parentOfNode != null) {\n    childCount--;\n  }\n\n  var branchCount = 0;\n\n  var incEdgesCount = neighborEdges.length;\n  var startIndex;\n\n  var edges = node.getEdgesBetween(parentOfNode);\n\n  // If there are multiple edges, prune them until there remains only one\n  // edge.\n  while (edges.length > 1) {\n    //neighborEdges.remove(edges.remove(0));\n    var temp = edges[0];\n    edges.splice(0, 1);\n    var index = neighborEdges.indexOf(temp);\n    if (index >= 0) {\n      neighborEdges.splice(index, 1);\n    }\n    incEdgesCount--;\n    childCount--;\n  }\n\n  if (parentOfNode != null) {\n    //assert edges.length == 1;\n    startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;\n  } else {\n    startIndex = 0;\n  }\n\n  var stepAngle = Math.abs(endAngle - startAngle) / childCount;\n\n  for (var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount) {\n    var currentNeighbor = neighborEdges[i].getOtherEnd(node);\n\n    // Don't back traverse to root node in current tree.\n    if (currentNeighbor == parentOfNode) {\n      continue;\n    }\n\n    var childStartAngle = (startAngle + branchCount * stepAngle) % 360;\n    var childEndAngle = (childStartAngle + stepAngle) % 360;\n\n    CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);\n\n    branchCount++;\n  }\n};\n\nCoSELayout.maxDiagonalInTree = function (tree) {\n  var maxDiagonal = Integer.MIN_VALUE;\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    var diagonal = node.getDiagonal();\n\n    if (diagonal > maxDiagonal) {\n      maxDiagonal = diagonal;\n    }\n  }\n\n  return maxDiagonal;\n};\n\nCoSELayout.prototype.calcRepulsionRange = function () {\n  // formula is 2 x (level + 1) x idealEdgeLength\n  return 2 * (this.level + 1) * this.idealEdgeLength;\n};\n\n// Tiling methods\n\n// Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id's\nCoSELayout.prototype.groupZeroDegreeMembers = function () {\n  var self = this;\n  // array of [parent_id x oneDegreeNode_id]\n  var tempMemberGroups = {}; // A temporary map of parent node and its zero degree members\n  this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled\n  this.idToDummyNode = {}; // A map of id to dummy node \n\n  var zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled\n  var allNodes = this.graphManager.getAllNodes();\n\n  // Fill zero degree list\n  for (var i = 0; i < allNodes.length; i++) {\n    var node = allNodes[i];\n    var parent = node.getParent();\n    // If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list\n    if (this.getNodeDegreeWithChildren(node) === 0 && (parent.id == undefined || !this.getToBeTiled(parent))) {\n      zeroDegree.push(node);\n    }\n  }\n\n  // Create a map of parent node and its zero degree members\n  for (var i = 0; i < zeroDegree.length; i++) {\n    var node = zeroDegree[i]; // Zero degree node itself\n    var p_id = node.getParent().id; // Parent id\n\n    if (typeof tempMemberGroups[p_id] === \"undefined\") tempMemberGroups[p_id] = [];\n\n    tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups\n  }\n\n  // If there are at least two nodes at a level, create a dummy compound for them\n  Object.keys(tempMemberGroups).forEach(function (p_id) {\n    if (tempMemberGroups[p_id].length > 1) {\n      var dummyCompoundId = \"DummyCompound_\" + p_id; // The id of dummy compound which will be created soon\n      self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups\n\n      var parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound\n\n      // Create a dummy compound with calculated id\n      var dummyCompound = new CoSENode(self.graphManager);\n      dummyCompound.id = dummyCompoundId;\n      dummyCompound.paddingLeft = parent.paddingLeft || 0;\n      dummyCompound.paddingRight = parent.paddingRight || 0;\n      dummyCompound.paddingBottom = parent.paddingBottom || 0;\n      dummyCompound.paddingTop = parent.paddingTop || 0;\n\n      self.idToDummyNode[dummyCompoundId] = dummyCompound;\n\n      var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);\n      var parentGraph = parent.getChild();\n\n      // Add dummy compound to parent the graph\n      parentGraph.add(dummyCompound);\n\n      // For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent\n      for (var i = 0; i < tempMemberGroups[p_id].length; i++) {\n        var node = tempMemberGroups[p_id][i];\n\n        parentGraph.remove(node);\n        dummyParentGraph.add(node);\n      }\n    }\n  });\n};\n\nCoSELayout.prototype.clearCompounds = function () {\n  var childGraphMap = {};\n  var idToNode = {};\n\n  // Get compound ordering by finding the inner one first\n  this.performDFSOnCompounds();\n\n  for (var i = 0; i < this.compoundOrder.length; i++) {\n\n    idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];\n    childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes());\n\n    // Remove children of compounds\n    this.graphManager.remove(this.compoundOrder[i].getChild());\n    this.compoundOrder[i].child = null;\n  }\n\n  this.graphManager.resetAllNodes();\n\n  // Tile the removed children\n  this.tileCompoundMembers(childGraphMap, idToNode);\n};\n\nCoSELayout.prototype.clearZeroDegreeMembers = function () {\n  var self = this;\n  var tiledZeroDegreePack = this.tiledZeroDegreePack = [];\n\n  Object.keys(this.memberGroups).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound\n\n    tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    // Set the width and height of the dummy compound as calculated\n    compoundNode.rect.width = tiledZeroDegreePack[id].width;\n    compoundNode.rect.height = tiledZeroDegreePack[id].height;\n    compoundNode.setCenter(tiledZeroDegreePack[id].centerX, tiledZeroDegreePack[id].centerY);\n\n    // compound left and top margings for labels\n    // when node labels are included, these values may be set to different values below and are used in tilingPostLayout,\n    // otherwise they stay as zero\n    compoundNode.labelMarginLeft = 0;\n    compoundNode.labelMarginTop = 0;\n\n    // Update compound bounds considering its label properties and set label margins for left and top\n    if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n\n      var width = compoundNode.rect.width;\n      var height = compoundNode.rect.height;\n\n      if (compoundNode.labelWidth) {\n        if (compoundNode.labelPosHorizontal == \"left\") {\n          compoundNode.rect.x -= compoundNode.labelWidth;\n          compoundNode.setWidth(width + compoundNode.labelWidth);\n          compoundNode.labelMarginLeft = compoundNode.labelWidth;\n        } else if (compoundNode.labelPosHorizontal == \"center\" && compoundNode.labelWidth > width) {\n          compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;\n          compoundNode.setWidth(compoundNode.labelWidth);\n          compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;\n        } else if (compoundNode.labelPosHorizontal == \"right\") {\n          compoundNode.setWidth(width + compoundNode.labelWidth);\n        }\n      }\n\n      if (compoundNode.labelHeight) {\n        if (compoundNode.labelPosVertical == \"top\") {\n          compoundNode.rect.y -= compoundNode.labelHeight;\n          compoundNode.setHeight(height + compoundNode.labelHeight);\n          compoundNode.labelMarginTop = compoundNode.labelHeight;\n        } else if (compoundNode.labelPosVertical == \"center\" && compoundNode.labelHeight > height) {\n          compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;\n          compoundNode.setHeight(compoundNode.labelHeight);\n          compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;\n        } else if (compoundNode.labelPosVertical == \"bottom\") {\n          compoundNode.setHeight(height + compoundNode.labelHeight);\n        }\n      }\n    }\n  });\n};\n\nCoSELayout.prototype.repopulateCompounds = function () {\n  for (var i = this.compoundOrder.length - 1; i >= 0; i--) {\n    var lCompoundNode = this.compoundOrder[i];\n    var id = lCompoundNode.id;\n    var horizontalMargin = lCompoundNode.paddingLeft;\n    var verticalMargin = lCompoundNode.paddingTop;\n    var labelMarginLeft = lCompoundNode.labelMarginLeft;\n    var labelMarginTop = lCompoundNode.labelMarginTop;\n\n    this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);\n  }\n};\n\nCoSELayout.prototype.repopulateZeroDegreeMembers = function () {\n  var self = this;\n  var tiledPack = this.tiledZeroDegreePack;\n\n  Object.keys(tiledPack).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id\n    var horizontalMargin = compoundNode.paddingLeft;\n    var verticalMargin = compoundNode.paddingTop;\n    var labelMarginLeft = compoundNode.labelMarginLeft;\n    var labelMarginTop = compoundNode.labelMarginTop;\n\n    // Adjust the positions of nodes wrt its compound\n    self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);\n  });\n};\n\nCoSELayout.prototype.getToBeTiled = function (node) {\n  var id = node.id;\n  //firstly check the previous results\n  if (this.toBeTiled[id] != null) {\n    return this.toBeTiled[id];\n  }\n\n  //only compound nodes are to be tiled\n  var childGraph = node.getChild();\n  if (childGraph == null) {\n    this.toBeTiled[id] = false;\n    return false;\n  }\n\n  var children = childGraph.getNodes(); // Get the children nodes\n\n  //a compound node is not to be tiled if all of its compound children are not to be tiled\n  for (var i = 0; i < children.length; i++) {\n    var theChild = children[i];\n\n    if (this.getNodeDegree(theChild) > 0) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n\n    //pass the children not having the compound structure\n    if (theChild.getChild() == null) {\n      this.toBeTiled[theChild.id] = false;\n      continue;\n    }\n\n    if (!this.getToBeTiled(theChild)) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n  }\n  this.toBeTiled[id] = true;\n  return true;\n};\n\n// Get degree of a node depending of its edges and independent of its children\nCoSELayout.prototype.getNodeDegree = function (node) {\n  var id = node.id;\n  var edges = node.getEdges();\n  var degree = 0;\n\n  // For the edges connected\n  for (var i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n    if (edge.getSource().id !== edge.getTarget().id) {\n      degree = degree + 1;\n    }\n  }\n  return degree;\n};\n\n// Get degree of a node with its children\nCoSELayout.prototype.getNodeDegreeWithChildren = function (node) {\n  var degree = this.getNodeDegree(node);\n  if (node.getChild() == null) {\n    return degree;\n  }\n  var children = node.getChild().getNodes();\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    degree += this.getNodeDegreeWithChildren(child);\n  }\n  return degree;\n};\n\nCoSELayout.prototype.performDFSOnCompounds = function () {\n  this.compoundOrder = [];\n  this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());\n};\n\nCoSELayout.prototype.fillCompexOrderByDFS = function (children) {\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    if (child.getChild() != null) {\n      this.fillCompexOrderByDFS(child.getChild().getNodes());\n    }\n    if (this.getToBeTiled(child)) {\n      this.compoundOrder.push(child);\n    }\n  }\n};\n\n/**\n* This method places each zero degree member wrt given (x,y) coordinates (top left).\n*/\nCoSELayout.prototype.adjustLocations = function (organization, x, y, compoundHorizontalMargin, compoundVerticalMargin, compoundLabelMarginLeft, compoundLabelMarginTop) {\n  x += compoundHorizontalMargin + compoundLabelMarginLeft;\n  y += compoundVerticalMargin + compoundLabelMarginTop;\n\n  var left = x;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    var row = organization.rows[i];\n    x = left;\n    var maxHeight = 0;\n\n    for (var j = 0; j < row.length; j++) {\n      var lnode = row[j];\n\n      lnode.rect.x = x; // + lnode.rect.width / 2;\n      lnode.rect.y = y; // + lnode.rect.height / 2;\n\n      x += lnode.rect.width + organization.horizontalPadding;\n\n      if (lnode.rect.height > maxHeight) maxHeight = lnode.rect.height;\n    }\n\n    y += maxHeight + organization.verticalPadding;\n  }\n};\n\nCoSELayout.prototype.tileCompoundMembers = function (childGraphMap, idToNode) {\n  var self = this;\n  this.tiledMemberPack = [];\n\n  Object.keys(childGraphMap).forEach(function (id) {\n    // Get the compound node\n    var compoundNode = idToNode[id];\n\n    self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    compoundNode.rect.width = self.tiledMemberPack[id].width;\n    compoundNode.rect.height = self.tiledMemberPack[id].height;\n    compoundNode.setCenter(self.tiledMemberPack[id].centerX, self.tiledMemberPack[id].centerY);\n\n    // compound left and top margings for labels\n    // when node labels are included, these values may be set to different values below and are used in tilingPostLayout,\n    // otherwise they stay as zero\n    compoundNode.labelMarginLeft = 0;\n    compoundNode.labelMarginTop = 0;\n\n    // Update compound bounds considering its label properties and set label margins for left and top\n    if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n\n      var width = compoundNode.rect.width;\n      var height = compoundNode.rect.height;\n\n      if (compoundNode.labelWidth) {\n        if (compoundNode.labelPosHorizontal == \"left\") {\n          compoundNode.rect.x -= compoundNode.labelWidth;\n          compoundNode.setWidth(width + compoundNode.labelWidth);\n          compoundNode.labelMarginLeft = compoundNode.labelWidth;\n        } else if (compoundNode.labelPosHorizontal == \"center\" && compoundNode.labelWidth > width) {\n          compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;\n          compoundNode.setWidth(compoundNode.labelWidth);\n          compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;\n        } else if (compoundNode.labelPosHorizontal == \"right\") {\n          compoundNode.setWidth(width + compoundNode.labelWidth);\n        }\n      }\n\n      if (compoundNode.labelHeight) {\n        if (compoundNode.labelPosVertical == \"top\") {\n          compoundNode.rect.y -= compoundNode.labelHeight;\n          compoundNode.setHeight(height + compoundNode.labelHeight);\n          compoundNode.labelMarginTop = compoundNode.labelHeight;\n        } else if (compoundNode.labelPosVertical == \"center\" && compoundNode.labelHeight > height) {\n          compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;\n          compoundNode.setHeight(compoundNode.labelHeight);\n          compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;\n        } else if (compoundNode.labelPosVertical == \"bottom\") {\n          compoundNode.setHeight(height + compoundNode.labelHeight);\n        }\n      }\n    }\n  });\n};\n\nCoSELayout.prototype.tileNodes = function (nodes, minWidth) {\n  var horizontalOrg = this.tileNodesByFavoringDim(nodes, minWidth, true);\n  var verticalOrg = this.tileNodesByFavoringDim(nodes, minWidth, false);\n\n  var horizontalRatio = this.getOrgRatio(horizontalOrg);\n  var verticalRatio = this.getOrgRatio(verticalOrg);\n  var bestOrg;\n\n  // the best ratio is the one that is closer to 1 since the ratios are already normalized\n  // and the best organization is the one that has the best ratio\n  if (verticalRatio < horizontalRatio) {\n    bestOrg = verticalOrg;\n  } else {\n    bestOrg = horizontalOrg;\n  }\n\n  return bestOrg;\n};\n\n// get the width/height ratio of the organization that is normalized so that it will not be less than 1\nCoSELayout.prototype.getOrgRatio = function (organization) {\n  // get dimensions and calculate the initial ratio\n  var width = organization.width;\n  var height = organization.height;\n  var ratio = width / height;\n\n  // if the initial ratio is less then 1 then inverse it\n  if (ratio < 1) {\n    ratio = 1 / ratio;\n  }\n\n  // return the normalized ratio\n  return ratio;\n};\n\n/*\n * Calculates the ideal width for the rows. This method assumes that\n * each node has the same sizes and calculates the ideal row width that\n * approximates a square shaped complex accordingly. However, since nodes would\n * have different sizes some rows would have different sizes and the resulting\n * shape would not be an exact square.\n */\nCoSELayout.prototype.calcIdealRowWidth = function (members, favorHorizontalDim) {\n  // To approximate a square shaped complex we need to make complex width equal to complex height.\n  // To achieve this we need to solve the following equation system for hc:\n  // (x + bx) * hc - bx = (y + by) * vc - by, hc * vc = n\n  // where x is the avarage width of the nodes, y is the avarage height of nodes\n  // bx and by are the buffer sizes in horizontal and vertical dimensions accordingly,\n  // hc and vc are the number of rows in horizontal and vertical dimensions\n  // n is number of members.\n\n  var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n  var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n\n  // number of members\n  var membersSize = members.length;\n\n  // sum of the width of all members\n  var totalWidth = 0;\n\n  // sum of the height of all members\n  var totalHeight = 0;\n\n  var maxWidth = 0;\n\n  // traverse all members to calculate total width and total height and get the maximum members width\n  members.forEach(function (node) {\n    totalWidth += node.getWidth();\n    totalHeight += node.getHeight();\n\n    if (node.getWidth() > maxWidth) {\n      maxWidth = node.getWidth();\n    }\n  });\n\n  // average width of the members\n  var averageWidth = totalWidth / membersSize;\n\n  // average height of the members\n  var averageHeight = totalHeight / membersSize;\n\n  // solving the initial equation system for the hc yields the following second degree equation:\n  // hc^2 * (x+bx) + hc * (by - bx) - n * (y + by) = 0\n\n  // the delta value to solve the equation above for hc\n  var delta = Math.pow(verticalPadding - horizontalPadding, 2) + 4 * (averageWidth + horizontalPadding) * (averageHeight + verticalPadding) * membersSize;\n\n  // solve the equation using delta value to calculate the horizontal count\n  // that represents the number of nodes in an ideal row\n  var horizontalCountDouble = (horizontalPadding - verticalPadding + Math.sqrt(delta)) / (2 * (averageWidth + horizontalPadding));\n  // round the calculated horizontal count up or down according to the favored dimension\n  var horizontalCount;\n\n  if (favorHorizontalDim) {\n    horizontalCount = Math.ceil(horizontalCountDouble);\n    // if horizontalCount count is not a float value then both of rounding to floor and ceil\n    // will yield the same values. Instead of repeating the same calculation try going up\n    // while favoring horizontal dimension in such cases\n    if (horizontalCount == horizontalCountDouble) {\n      horizontalCount++;\n    }\n  } else {\n    horizontalCount = Math.floor(horizontalCountDouble);\n  }\n\n  // ideal width to be calculated\n  var idealWidth = horizontalCount * (averageWidth + horizontalPadding) - horizontalPadding;\n\n  // if max width is bigger than calculated ideal width reset ideal width to it\n  if (maxWidth > idealWidth) {\n    idealWidth = maxWidth;\n  }\n\n  // add the left-right margins to the ideal row width\n  idealWidth += horizontalPadding * 2;\n\n  // return the ideal row width1\n  return idealWidth;\n};\n\nCoSELayout.prototype.tileNodesByFavoringDim = function (nodes, minWidth, favorHorizontalDim) {\n  var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n  var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n  var tilingCompareBy = CoSEConstants.TILING_COMPARE_BY;\n  var organization = {\n    rows: [],\n    rowWidth: [],\n    rowHeight: [],\n    width: 0,\n    height: minWidth, // assume minHeight equals to minWidth\n    verticalPadding: verticalPadding,\n    horizontalPadding: horizontalPadding,\n    centerX: 0,\n    centerY: 0\n  };\n\n  if (tilingCompareBy) {\n    organization.idealRowWidth = this.calcIdealRowWidth(nodes, favorHorizontalDim);\n  }\n\n  var getNodeArea = function getNodeArea(n) {\n    return n.rect.width * n.rect.height;\n  };\n\n  var areaCompareFcn = function areaCompareFcn(n1, n2) {\n    return getNodeArea(n2) - getNodeArea(n1);\n  };\n\n  // Sort the nodes in descending order of their areas\n  nodes.sort(function (n1, n2) {\n    var cmpBy = areaCompareFcn;\n    if (organization.idealRowWidth) {\n      cmpBy = tilingCompareBy;\n      return cmpBy(n1.id, n2.id);\n    }\n    return cmpBy(n1, n2);\n  });\n\n  // Create the organization -> calculate compound center\n  var sumCenterX = 0;\n  var sumCenterY = 0;\n  for (var i = 0; i < nodes.length; i++) {\n    var lNode = nodes[i];\n\n    sumCenterX += lNode.getCenterX();\n    sumCenterY += lNode.getCenterY();\n  }\n\n  organization.centerX = sumCenterX / nodes.length;\n  organization.centerY = sumCenterY / nodes.length;\n\n  // Create the organization -> tile members\n  for (var i = 0; i < nodes.length; i++) {\n    var lNode = nodes[i];\n\n    if (organization.rows.length == 0) {\n      this.insertNodeToRow(organization, lNode, 0, minWidth);\n    } else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {\n      var rowIndex = organization.rows.length - 1;\n      if (!organization.idealRowWidth) {\n        rowIndex = this.getShortestRowIndex(organization);\n      }\n      this.insertNodeToRow(organization, lNode, rowIndex, minWidth);\n    } else {\n      this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);\n    }\n\n    this.shiftToLastRow(organization);\n  }\n\n  return organization;\n};\n\nCoSELayout.prototype.insertNodeToRow = function (organization, node, rowIndex, minWidth) {\n  var minCompoundSize = minWidth;\n\n  // Add new row if needed\n  if (rowIndex == organization.rows.length) {\n    var secondDimension = [];\n\n    organization.rows.push(secondDimension);\n    organization.rowWidth.push(minCompoundSize);\n    organization.rowHeight.push(0);\n  }\n\n  // Update row width\n  var w = organization.rowWidth[rowIndex] + node.rect.width;\n\n  if (organization.rows[rowIndex].length > 0) {\n    w += organization.horizontalPadding;\n  }\n\n  organization.rowWidth[rowIndex] = w;\n  // Update compound width\n  if (organization.width < w) {\n    organization.width = w;\n  }\n\n  // Update height\n  var h = node.rect.height;\n  if (rowIndex > 0) h += organization.verticalPadding;\n\n  var extraHeight = 0;\n  if (h > organization.rowHeight[rowIndex]) {\n    extraHeight = organization.rowHeight[rowIndex];\n    organization.rowHeight[rowIndex] = h;\n    extraHeight = organization.rowHeight[rowIndex] - extraHeight;\n  }\n\n  organization.height += extraHeight;\n\n  // Insert node\n  organization.rows[rowIndex].push(node);\n};\n\n//Scans the rows of an organization and returns the one with the min width\nCoSELayout.prototype.getShortestRowIndex = function (organization) {\n  var r = -1;\n  var min = Number.MAX_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    if (organization.rowWidth[i] < min) {\n      r = i;\n      min = organization.rowWidth[i];\n    }\n  }\n  return r;\n};\n\n//Scans the rows of an organization and returns the one with the max width\nCoSELayout.prototype.getLongestRowIndex = function (organization) {\n  var r = -1;\n  var max = Number.MIN_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n\n    if (organization.rowWidth[i] > max) {\n      r = i;\n      max = organization.rowWidth[i];\n    }\n  }\n\n  return r;\n};\n\n/**\n* This method checks whether adding extra width to the organization violates\n* the aspect ratio(1) or not.\n*/\nCoSELayout.prototype.canAddHorizontal = function (organization, extraWidth, extraHeight) {\n\n  // if there is an ideal row width specified use it instead of checking the aspect ratio\n  if (organization.idealRowWidth) {\n    var lastRowIndex = organization.rows.length - 1;\n    var lastRowWidth = organization.rowWidth[lastRowIndex];\n\n    // check and return if ideal row width will be exceed if the node is added to the row\n    return lastRowWidth + extraWidth + organization.horizontalPadding <= organization.idealRowWidth;\n  }\n\n  var sri = this.getShortestRowIndex(organization);\n\n  if (sri < 0) {\n    return true;\n  }\n\n  var min = organization.rowWidth[sri];\n\n  if (min + organization.horizontalPadding + extraWidth <= organization.width) return true;\n\n  var hDiff = 0;\n\n  // Adding to an existing row\n  if (organization.rowHeight[sri] < extraHeight) {\n    if (sri > 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];\n  }\n\n  var add_to_row_ratio;\n  if (organization.width - min >= extraWidth + organization.horizontalPadding) {\n    add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);\n  } else {\n    add_to_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  // Adding a new row for this node\n  hDiff = extraHeight + organization.verticalPadding;\n  var add_new_row_ratio;\n  if (organization.width < extraWidth) {\n    add_new_row_ratio = (organization.height + hDiff) / extraWidth;\n  } else {\n    add_new_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  if (add_new_row_ratio < 1) add_new_row_ratio = 1 / add_new_row_ratio;\n\n  if (add_to_row_ratio < 1) add_to_row_ratio = 1 / add_to_row_ratio;\n\n  return add_to_row_ratio < add_new_row_ratio;\n};\n\n//If moving the last node from the longest row and adding it to the last\n//row makes the bounding box smaller, do it.\nCoSELayout.prototype.shiftToLastRow = function (organization) {\n  var longest = this.getLongestRowIndex(organization);\n  var last = organization.rowWidth.length - 1;\n  var row = organization.rows[longest];\n  var node = row[row.length - 1];\n\n  var diff = node.width + organization.horizontalPadding;\n\n  // Check if there is enough space on the last row\n  if (organization.width - organization.rowWidth[last] > diff && longest != last) {\n    // Remove the last element of the longest row\n    row.splice(-1, 1);\n\n    // Push it to the last row\n    organization.rows[last].push(node);\n\n    organization.rowWidth[longest] = organization.rowWidth[longest] - diff;\n    organization.rowWidth[last] = organization.rowWidth[last] + diff;\n    organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)];\n\n    // Update heights of the organization\n    var maxHeight = Number.MIN_VALUE;\n    for (var i = 0; i < row.length; i++) {\n      if (row[i].height > maxHeight) maxHeight = row[i].height;\n    }\n    if (longest > 0) maxHeight += organization.verticalPadding;\n\n    var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n\n    organization.rowHeight[longest] = maxHeight;\n    if (organization.rowHeight[last] < node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;\n\n    var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n    organization.height += finalTotal - prevTotal;\n\n    this.shiftToLastRow(organization);\n  }\n};\n\nCoSELayout.prototype.tilingPreLayout = function () {\n  if (CoSEConstants.TILE) {\n    // Find zero degree nodes and create a compound for each level\n    this.groupZeroDegreeMembers();\n    // Tile and clear children of each compound\n    this.clearCompounds();\n    // Separately tile and clear zero degree nodes for each level\n    this.clearZeroDegreeMembers();\n  }\n};\n\nCoSELayout.prototype.tilingPostLayout = function () {\n  if (CoSEConstants.TILE) {\n    this.repopulateZeroDegreeMembers();\n    this.repopulateCompounds();\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: Tree Reduction methods\n// -----------------------------------------------------------------------------\n// Reduce trees \nCoSELayout.prototype.reduceTrees = function () {\n  var prunedNodesAll = [];\n  var containsLeaf = true;\n  var node;\n\n  while (containsLeaf) {\n    var allNodes = this.graphManager.getAllNodes();\n    var prunedNodesInStepTemp = [];\n    containsLeaf = false;\n\n    for (var i = 0; i < allNodes.length; i++) {\n      node = allNodes[i];\n      if (node.getEdges().length == 1 && !node.getEdges()[0].isInterGraph && node.getChild() == null) {\n        if (CoSEConstants.PURE_INCREMENTAL) {\n          var otherEnd = node.getEdges()[0].getOtherEnd(node);\n          var relativePosition = new DimensionD(node.getCenterX() - otherEnd.getCenterX(), node.getCenterY() - otherEnd.getCenterY());\n          prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner(), relativePosition]);\n        } else {\n          prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner()]);\n        }\n        containsLeaf = true;\n      }\n    }\n    if (containsLeaf == true) {\n      var prunedNodesInStep = [];\n      for (var j = 0; j < prunedNodesInStepTemp.length; j++) {\n        if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {\n          prunedNodesInStep.push(prunedNodesInStepTemp[j]);\n          prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);\n        }\n      }\n      prunedNodesAll.push(prunedNodesInStep);\n      this.graphManager.resetAllNodes();\n      this.graphManager.resetAllEdges();\n    }\n  }\n  this.prunedNodesAll = prunedNodesAll;\n};\n\n// Grow tree one step \nCoSELayout.prototype.growTree = function (prunedNodesAll) {\n  var lengthOfPrunedNodesInStep = prunedNodesAll.length;\n  var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];\n\n  var nodeData;\n  for (var i = 0; i < prunedNodesInStep.length; i++) {\n    nodeData = prunedNodesInStep[i];\n\n    this.findPlaceforPrunedNode(nodeData);\n\n    nodeData[2].add(nodeData[0]);\n    nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);\n  }\n\n  prunedNodesAll.splice(prunedNodesAll.length - 1, 1);\n  this.graphManager.resetAllNodes();\n  this.graphManager.resetAllEdges();\n};\n\n// Find an appropriate position to replace pruned node, this method can be improved\nCoSELayout.prototype.findPlaceforPrunedNode = function (nodeData) {\n\n  var gridForPrunedNode;\n  var nodeToConnect;\n  var prunedNode = nodeData[0];\n  if (prunedNode == nodeData[1].source) {\n    nodeToConnect = nodeData[1].target;\n  } else {\n    nodeToConnect = nodeData[1].source;\n  }\n\n  if (CoSEConstants.PURE_INCREMENTAL) {\n    prunedNode.setCenter(nodeToConnect.getCenterX() + nodeData[3].getWidth(), nodeToConnect.getCenterY() + nodeData[3].getHeight());\n  } else {\n    var startGridX = nodeToConnect.startX;\n    var finishGridX = nodeToConnect.finishX;\n    var startGridY = nodeToConnect.startY;\n    var finishGridY = nodeToConnect.finishY;\n\n    var upNodeCount = 0;\n    var downNodeCount = 0;\n    var rightNodeCount = 0;\n    var leftNodeCount = 0;\n    var controlRegions = [upNodeCount, rightNodeCount, downNodeCount, leftNodeCount];\n\n    if (startGridY > 0) {\n      for (var i = startGridX; i <= finishGridX; i++) {\n        controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;\n      }\n    }\n    if (finishGridX < this.grid.length - 1) {\n      for (var i = startGridY; i <= finishGridY; i++) {\n        controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;\n      }\n    }\n    if (finishGridY < this.grid[0].length - 1) {\n      for (var i = startGridX; i <= finishGridX; i++) {\n        controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;\n      }\n    }\n    if (startGridX > 0) {\n      for (var i = startGridY; i <= finishGridY; i++) {\n        controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;\n      }\n    }\n    var min = Integer.MAX_VALUE;\n    var minCount;\n    var minIndex;\n    for (var j = 0; j < controlRegions.length; j++) {\n      if (controlRegions[j] < min) {\n        min = controlRegions[j];\n        minCount = 1;\n        minIndex = j;\n      } else if (controlRegions[j] == min) {\n        minCount++;\n      }\n    }\n\n    if (minCount == 3 && min == 0) {\n      if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[2] == 0) {\n        gridForPrunedNode = 1;\n      } else if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[3] == 0) {\n        gridForPrunedNode = 0;\n      } else if (controlRegions[0] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n        gridForPrunedNode = 3;\n      } else if (controlRegions[1] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n        gridForPrunedNode = 2;\n      }\n    } else if (minCount == 2 && min == 0) {\n      var random = Math.floor(Math.random() * 2);\n      if (controlRegions[0] == 0 && controlRegions[1] == 0) {\n        ;\n        if (random == 0) {\n          gridForPrunedNode = 0;\n        } else {\n          gridForPrunedNode = 1;\n        }\n      } else if (controlRegions[0] == 0 && controlRegions[2] == 0) {\n        if (random == 0) {\n          gridForPrunedNode = 0;\n        } else {\n          gridForPrunedNode = 2;\n        }\n      } else if (controlRegions[0] == 0 && controlRegions[3] == 0) {\n        if (random == 0) {\n          gridForPrunedNode = 0;\n        } else {\n          gridForPrunedNode = 3;\n        }\n      } else if (controlRegions[1] == 0 && controlRegions[2] == 0) {\n        if (random == 0) {\n          gridForPrunedNode = 1;\n        } else {\n          gridForPrunedNode = 2;\n        }\n      } else if (controlRegions[1] == 0 && controlRegions[3] == 0) {\n        if (random == 0) {\n          gridForPrunedNode = 1;\n        } else {\n          gridForPrunedNode = 3;\n        }\n      } else {\n        if (random == 0) {\n          gridForPrunedNode = 2;\n        } else {\n          gridForPrunedNode = 3;\n        }\n      }\n    } else if (minCount == 4 && min == 0) {\n      var random = Math.floor(Math.random() * 4);\n      gridForPrunedNode = random;\n    } else {\n      gridForPrunedNode = minIndex;\n    }\n\n    if (gridForPrunedNode == 0) {\n      prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);\n    } else if (gridForPrunedNode == 1) {\n      prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n    } else if (gridForPrunedNode == 2) {\n      prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);\n    } else {\n      prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n    }\n  }\n};\n\nmodule.exports = CoSELayout;\n\n/***/ }),\n\n/***/ 991:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\nvar FDLayoutNode = __webpack_require__(551).FDLayoutNode;\nvar IMath = __webpack_require__(551).IMath;\n\nfunction CoSENode(gm, loc, size, vNode) {\n  FDLayoutNode.call(this, gm, loc, size, vNode);\n}\n\nCoSENode.prototype = Object.create(FDLayoutNode.prototype);\nfor (var prop in FDLayoutNode) {\n  CoSENode[prop] = FDLayoutNode[prop];\n}\n\nCoSENode.prototype.calculateDisplacement = function () {\n  var layout = this.graphManager.getLayout();\n  // this check is for compound nodes that contain fixed nodes\n  if (this.getChild() != null && this.fixedNodeWeight) {\n    this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.fixedNodeWeight;\n    this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.fixedNodeWeight;\n  } else {\n    this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;\n    this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;\n  }\n\n  if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);\n  }\n\n  if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);\n  }\n\n  // non-empty compound node, propogate movement to children as well\n  if (this.child && this.child.getNodes().length > 0) {\n    this.propogateDisplacementToChildren(this.displacementX, this.displacementY);\n  }\n};\n\nCoSENode.prototype.propogateDisplacementToChildren = function (dX, dY) {\n  var nodes = this.getChild().getNodes();\n  var node;\n  for (var i = 0; i < nodes.length; i++) {\n    node = nodes[i];\n    if (node.getChild() == null) {\n      node.displacementX += dX;\n      node.displacementY += dY;\n    } else {\n      node.propogateDisplacementToChildren(dX, dY);\n    }\n  }\n};\n\nCoSENode.prototype.move = function () {\n  var layout = this.graphManager.getLayout();\n\n  // a simple node or an empty compound node, move it\n  if (this.child == null || this.child.getNodes().length == 0) {\n    this.moveBy(this.displacementX, this.displacementY);\n\n    layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);\n  }\n\n  this.springForceX = 0;\n  this.springForceY = 0;\n  this.repulsionForceX = 0;\n  this.repulsionForceY = 0;\n  this.gravitationForceX = 0;\n  this.gravitationForceY = 0;\n  this.displacementX = 0;\n  this.displacementY = 0;\n};\n\nCoSENode.prototype.setPred1 = function (pred1) {\n  this.pred1 = pred1;\n};\n\nCoSENode.prototype.getPred1 = function () {\n  return pred1;\n};\n\nCoSENode.prototype.getPred2 = function () {\n  return pred2;\n};\n\nCoSENode.prototype.setNext = function (next) {\n  this.next = next;\n};\n\nCoSENode.prototype.getNext = function () {\n  return next;\n};\n\nCoSENode.prototype.setProcessed = function (processed) {\n  this.processed = processed;\n};\n\nCoSENode.prototype.isProcessed = function () {\n  return processed;\n};\n\nmodule.exports = CoSENode;\n\n/***/ }),\n\n/***/ 902:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar CoSEConstants = __webpack_require__(806);\nvar LinkedList = __webpack_require__(551).LinkedList;\nvar Matrix = __webpack_require__(551).Matrix;\nvar SVD = __webpack_require__(551).SVD;\n\nfunction ConstraintHandler() {}\n\nConstraintHandler.handleConstraints = function (layout) {\n  //  let layout = this.graphManager.getLayout();\n\n  // get constraints from layout\n  var constraints = {};\n  constraints.fixedNodeConstraint = layout.constraints.fixedNodeConstraint;\n  constraints.alignmentConstraint = layout.constraints.alignmentConstraint;\n  constraints.relativePlacementConstraint = layout.constraints.relativePlacementConstraint;\n\n  var idToNodeMap = new Map();\n  var nodeIndexes = new Map();\n  var xCoords = [];\n  var yCoords = [];\n\n  var allNodes = layout.getAllNodes();\n  var index = 0;\n  // fill index map and coordinates\n  for (var i = 0; i < allNodes.length; i++) {\n    var node = allNodes[i];\n    if (node.getChild() == null) {\n      nodeIndexes.set(node.id, index++);\n      xCoords.push(node.getCenterX());\n      yCoords.push(node.getCenterY());\n      idToNodeMap.set(node.id, node);\n    }\n  }\n\n  // if there exists relative placement constraint without gap value, set it to default \n  if (constraints.relativePlacementConstraint) {\n    constraints.relativePlacementConstraint.forEach(function (constraint) {\n      if (!constraint.gap && constraint.gap != 0) {\n        if (constraint.left) {\n          constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.left).getWidth() / 2 + idToNodeMap.get(constraint.right).getWidth() / 2;\n        } else {\n          constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.top).getHeight() / 2 + idToNodeMap.get(constraint.bottom).getHeight() / 2;\n        }\n      }\n    });\n  }\n\n  /* auxiliary functions */\n\n  // calculate difference between two position objects\n  var calculatePositionDiff = function calculatePositionDiff(pos1, pos2) {\n    return { x: pos1.x - pos2.x, y: pos1.y - pos2.y };\n  };\n\n  // calculate average position of the nodes\n  var calculateAvgPosition = function calculateAvgPosition(nodeIdSet) {\n    var xPosSum = 0;\n    var yPosSum = 0;\n    nodeIdSet.forEach(function (nodeId) {\n      xPosSum += xCoords[nodeIndexes.get(nodeId)];\n      yPosSum += yCoords[nodeIndexes.get(nodeId)];\n    });\n\n    return { x: xPosSum / nodeIdSet.size, y: yPosSum / nodeIdSet.size };\n  };\n\n  // find an appropriate positioning for the nodes in a given graph according to relative placement constraints\n  // this function also takes the fixed nodes and alignment constraints into account\n  // graph: dag to be evaluated, direction: \"horizontal\" or \"vertical\", \n  // fixedNodes: set of fixed nodes to consider during evaluation, dummyPositions: appropriate coordinates of the dummy nodes  \n  var findAppropriatePositionForRelativePlacement = function findAppropriatePositionForRelativePlacement(graph, direction, fixedNodes, dummyPositions, componentSources) {\n\n    // find union of two sets\n    function setUnion(setA, setB) {\n      var union = new Set(setA);\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = setB[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var elem = _step.value;\n\n          union.add(elem);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return union;\n    }\n\n    // find indegree count for each node\n    var inDegrees = new Map();\n\n    graph.forEach(function (value, key) {\n      inDegrees.set(key, 0);\n    });\n    graph.forEach(function (value, key) {\n      value.forEach(function (adjacent) {\n        inDegrees.set(adjacent.id, inDegrees.get(adjacent.id) + 1);\n      });\n    });\n\n    var positionMap = new Map(); // keeps the position for each node\n    var pastMap = new Map(); // keeps the predecessors(past) of a node\n    var queue = new LinkedList();\n    inDegrees.forEach(function (value, key) {\n      if (value == 0) {\n        queue.push(key);\n        if (!fixedNodes) {\n          if (direction == \"horizontal\") {\n            positionMap.set(key, nodeIndexes.has(key) ? xCoords[nodeIndexes.get(key)] : dummyPositions.get(key));\n          } else {\n            positionMap.set(key, nodeIndexes.has(key) ? yCoords[nodeIndexes.get(key)] : dummyPositions.get(key));\n          }\n        }\n      } else {\n        positionMap.set(key, Number.NEGATIVE_INFINITY);\n      }\n      if (fixedNodes) {\n        pastMap.set(key, new Set([key]));\n      }\n    });\n\n    // align sources of each component in enforcement phase\n    if (fixedNodes) {\n      componentSources.forEach(function (component) {\n        var fixedIds = [];\n        component.forEach(function (nodeId) {\n          if (fixedNodes.has(nodeId)) {\n            fixedIds.push(nodeId);\n          }\n        });\n        if (fixedIds.length > 0) {\n          var position = 0;\n          fixedIds.forEach(function (fixedId) {\n            if (direction == \"horizontal\") {\n              positionMap.set(fixedId, nodeIndexes.has(fixedId) ? xCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));\n              position += positionMap.get(fixedId);\n            } else {\n              positionMap.set(fixedId, nodeIndexes.has(fixedId) ? yCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));\n              position += positionMap.get(fixedId);\n            }\n          });\n          position = position / fixedIds.length;\n          component.forEach(function (nodeId) {\n            if (!fixedNodes.has(nodeId)) {\n              positionMap.set(nodeId, position);\n            }\n          });\n        } else {\n          var _position = 0;\n          component.forEach(function (nodeId) {\n            if (direction == \"horizontal\") {\n              _position += nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n            } else {\n              _position += nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n            }\n          });\n          _position = _position / component.length;\n          component.forEach(function (nodeId) {\n            positionMap.set(nodeId, _position);\n          });\n        }\n      });\n    }\n\n    // calculate positions of the nodes\n\n    var _loop = function _loop() {\n      var currentNode = queue.shift();\n      var neighbors = graph.get(currentNode);\n      neighbors.forEach(function (neighbor) {\n        if (positionMap.get(neighbor.id) < positionMap.get(currentNode) + neighbor.gap) {\n          if (fixedNodes && fixedNodes.has(neighbor.id)) {\n            var fixedPosition = void 0;\n            if (direction == \"horizontal\") {\n              fixedPosition = nodeIndexes.has(neighbor.id) ? xCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);\n            } else {\n              fixedPosition = nodeIndexes.has(neighbor.id) ? yCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);\n            }\n            positionMap.set(neighbor.id, fixedPosition); // TODO: may do unnecessary work\n            if (fixedPosition < positionMap.get(currentNode) + neighbor.gap) {\n              var diff = positionMap.get(currentNode) + neighbor.gap - fixedPosition;\n              pastMap.get(currentNode).forEach(function (nodeId) {\n                positionMap.set(nodeId, positionMap.get(nodeId) - diff);\n              });\n            }\n          } else {\n            positionMap.set(neighbor.id, positionMap.get(currentNode) + neighbor.gap);\n          }\n        }\n        inDegrees.set(neighbor.id, inDegrees.get(neighbor.id) - 1);\n        if (inDegrees.get(neighbor.id) == 0) {\n          queue.push(neighbor.id);\n        }\n        if (fixedNodes) {\n          pastMap.set(neighbor.id, setUnion(pastMap.get(currentNode), pastMap.get(neighbor.id)));\n        }\n      });\n    };\n\n    while (queue.length != 0) {\n      _loop();\n    }\n\n    // readjust position of the nodes after enforcement\n    if (fixedNodes) {\n      // find indegree count for each node\n      var sinkNodes = new Set();\n\n      graph.forEach(function (value, key) {\n        if (value.length == 0) {\n          sinkNodes.add(key);\n        }\n      });\n\n      var _components = [];\n      pastMap.forEach(function (value, key) {\n        if (sinkNodes.has(key)) {\n          var isFixedComponent = false;\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = value[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var nodeId = _step2.value;\n\n              if (fixedNodes.has(nodeId)) {\n                isFixedComponent = true;\n              }\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n\n          if (!isFixedComponent) {\n            var isExist = false;\n            var existAt = void 0;\n            _components.forEach(function (component, index) {\n              if (component.has([].concat(_toConsumableArray(value))[0])) {\n                isExist = true;\n                existAt = index;\n              }\n            });\n            if (!isExist) {\n              _components.push(new Set(value));\n            } else {\n              value.forEach(function (ele) {\n                _components[existAt].add(ele);\n              });\n            }\n          }\n        }\n      });\n\n      _components.forEach(function (component, index) {\n        var minBefore = Number.POSITIVE_INFINITY;\n        var minAfter = Number.POSITIVE_INFINITY;\n        var maxBefore = Number.NEGATIVE_INFINITY;\n        var maxAfter = Number.NEGATIVE_INFINITY;\n\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = component[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var nodeId = _step3.value;\n\n            var posBefore = void 0;\n            if (direction == \"horizontal\") {\n              posBefore = nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n            } else {\n              posBefore = nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n            }\n            var posAfter = positionMap.get(nodeId);\n            if (posBefore < minBefore) {\n              minBefore = posBefore;\n            }\n            if (posBefore > maxBefore) {\n              maxBefore = posBefore;\n            }\n            if (posAfter < minAfter) {\n              minAfter = posAfter;\n            }\n            if (posAfter > maxAfter) {\n              maxAfter = posAfter;\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n\n        var diff = (minBefore + maxBefore) / 2 - (minAfter + maxAfter) / 2;\n\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = component[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var _nodeId = _step4.value;\n\n            positionMap.set(_nodeId, positionMap.get(_nodeId) + diff);\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      });\n    }\n\n    return positionMap;\n  };\n\n  // find transformation based on rel. placement constraints if there are both alignment and rel. placement constraints\n  // or if there are only rel. placement contraints where the largest component isn't sufficiently large\n  var applyReflectionForRelativePlacement = function applyReflectionForRelativePlacement(relativePlacementConstraints) {\n    // variables to count votes\n    var reflectOnY = 0,\n        notReflectOnY = 0;\n    var reflectOnX = 0,\n        notReflectOnX = 0;\n\n    relativePlacementConstraints.forEach(function (constraint) {\n      if (constraint.left) {\n        xCoords[nodeIndexes.get(constraint.left)] - xCoords[nodeIndexes.get(constraint.right)] >= 0 ? reflectOnY++ : notReflectOnY++;\n      } else {\n        yCoords[nodeIndexes.get(constraint.top)] - yCoords[nodeIndexes.get(constraint.bottom)] >= 0 ? reflectOnX++ : notReflectOnX++;\n      }\n    });\n\n    if (reflectOnY > notReflectOnY && reflectOnX > notReflectOnX) {\n      for (var _i = 0; _i < nodeIndexes.size; _i++) {\n        xCoords[_i] = -1 * xCoords[_i];\n        yCoords[_i] = -1 * yCoords[_i];\n      }\n    } else if (reflectOnY > notReflectOnY) {\n      for (var _i2 = 0; _i2 < nodeIndexes.size; _i2++) {\n        xCoords[_i2] = -1 * xCoords[_i2];\n      }\n    } else if (reflectOnX > notReflectOnX) {\n      for (var _i3 = 0; _i3 < nodeIndexes.size; _i3++) {\n        yCoords[_i3] = -1 * yCoords[_i3];\n      }\n    }\n  };\n\n  // find weakly connected components in undirected graph\n  var findComponents = function findComponents(graph) {\n    // find weakly connected components in dag\n    var components = [];\n    var queue = new LinkedList();\n    var visited = new Set();\n    var count = 0;\n\n    graph.forEach(function (value, key) {\n      if (!visited.has(key)) {\n        components[count] = [];\n        var _currentNode = key;\n        queue.push(_currentNode);\n        visited.add(_currentNode);\n        components[count].push(_currentNode);\n\n        while (queue.length != 0) {\n          _currentNode = queue.shift();\n          var neighbors = graph.get(_currentNode);\n          neighbors.forEach(function (neighbor) {\n            if (!visited.has(neighbor.id)) {\n              queue.push(neighbor.id);\n              visited.add(neighbor.id);\n              components[count].push(neighbor.id);\n            }\n          });\n        }\n        count++;\n      }\n    });\n    return components;\n  };\n\n  // return undirected version of given dag\n  var dagToUndirected = function dagToUndirected(dag) {\n    var undirected = new Map();\n\n    dag.forEach(function (value, key) {\n      undirected.set(key, []);\n    });\n\n    dag.forEach(function (value, key) {\n      value.forEach(function (adjacent) {\n        undirected.get(key).push(adjacent);\n        undirected.get(adjacent.id).push({ id: key, gap: adjacent.gap, direction: adjacent.direction });\n      });\n    });\n\n    return undirected;\n  };\n\n  // return reversed (directions inverted) version of given dag\n  var dagToReversed = function dagToReversed(dag) {\n    var reversed = new Map();\n\n    dag.forEach(function (value, key) {\n      reversed.set(key, []);\n    });\n\n    dag.forEach(function (value, key) {\n      value.forEach(function (adjacent) {\n        reversed.get(adjacent.id).push({ id: key, gap: adjacent.gap, direction: adjacent.direction });\n      });\n    });\n\n    return reversed;\n  };\n\n  /****  apply transformation to the initial draft layout to better align with constrained nodes ****/\n  // solve the Orthogonal Procrustean Problem to rotate and/or reflect initial draft layout\n  // here we follow the solution in Chapter 20.2 of Borg, I. & Groenen, P. (2005) Modern Multidimensional Scaling: Theory and Applications \n\n  /* construct source and target configurations */\n\n  var targetMatrix = []; // A - target configuration\n  var sourceMatrix = []; // B - source configuration \n  var standardTransformation = false; // false for no transformation, true for standart (Procrustes) transformation (rotation and/or reflection)\n  var reflectionType = false; // false/true for reflection check, 'reflectOnX', 'reflectOnY' or 'reflectOnBoth' for reflection type if necessary\n  var fixedNodes = new Set();\n  var dag = new Map(); // adjacency list to keep directed acyclic graph (dag) that consists of relative placement constraints\n  var dagUndirected = new Map(); // undirected version of the dag\n  var components = []; // weakly connected components\n\n  // fill fixedNodes collection to use later\n  if (constraints.fixedNodeConstraint) {\n    constraints.fixedNodeConstraint.forEach(function (nodeData) {\n      fixedNodes.add(nodeData.nodeId);\n    });\n  }\n\n  // construct dag from relative placement constraints \n  if (constraints.relativePlacementConstraint) {\n    // construct both directed and undirected version of the dag\n    constraints.relativePlacementConstraint.forEach(function (constraint) {\n      if (constraint.left) {\n        if (dag.has(constraint.left)) {\n          dag.get(constraint.left).push({ id: constraint.right, gap: constraint.gap, direction: \"horizontal\" });\n        } else {\n          dag.set(constraint.left, [{ id: constraint.right, gap: constraint.gap, direction: \"horizontal\" }]);\n        }\n        if (!dag.has(constraint.right)) {\n          dag.set(constraint.right, []);\n        }\n      } else {\n        if (dag.has(constraint.top)) {\n          dag.get(constraint.top).push({ id: constraint.bottom, gap: constraint.gap, direction: \"vertical\" });\n        } else {\n          dag.set(constraint.top, [{ id: constraint.bottom, gap: constraint.gap, direction: \"vertical\" }]);\n        }\n        if (!dag.has(constraint.bottom)) {\n          dag.set(constraint.bottom, []);\n        }\n      }\n    });\n\n    dagUndirected = dagToUndirected(dag);\n    components = findComponents(dagUndirected);\n  }\n\n  if (CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING) {\n    // first check fixed node constraint\n    if (constraints.fixedNodeConstraint && constraints.fixedNodeConstraint.length > 1) {\n      constraints.fixedNodeConstraint.forEach(function (nodeData, i) {\n        targetMatrix[i] = [nodeData.position.x, nodeData.position.y];\n        sourceMatrix[i] = [xCoords[nodeIndexes.get(nodeData.nodeId)], yCoords[nodeIndexes.get(nodeData.nodeId)]];\n      });\n      standardTransformation = true;\n    } else if (constraints.alignmentConstraint) {\n      (function () {\n        // then check alignment constraint\n        var count = 0;\n        if (constraints.alignmentConstraint.vertical) {\n          var verticalAlign = constraints.alignmentConstraint.vertical;\n\n          var _loop2 = function _loop2(_i4) {\n            var alignmentSet = new Set();\n            verticalAlign[_i4].forEach(function (nodeId) {\n              alignmentSet.add(nodeId);\n            });\n            var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n              return fixedNodes.has(x);\n            }));\n            var xPos = void 0;\n            if (intersection.size > 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else xPos = calculateAvgPosition(alignmentSet).x;\n\n            verticalAlign[_i4].forEach(function (nodeId) {\n              targetMatrix[count] = [xPos, yCoords[nodeIndexes.get(nodeId)]];\n              sourceMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n              count++;\n            });\n          };\n\n          for (var _i4 = 0; _i4 < verticalAlign.length; _i4++) {\n            _loop2(_i4);\n          }\n          standardTransformation = true;\n        }\n        if (constraints.alignmentConstraint.horizontal) {\n          var horizontalAlign = constraints.alignmentConstraint.horizontal;\n\n          var _loop3 = function _loop3(_i5) {\n            var alignmentSet = new Set();\n            horizontalAlign[_i5].forEach(function (nodeId) {\n              alignmentSet.add(nodeId);\n            });\n            var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n              return fixedNodes.has(x);\n            }));\n            var yPos = void 0;\n            if (intersection.size > 0) yPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else yPos = calculateAvgPosition(alignmentSet).y;\n\n            horizontalAlign[_i5].forEach(function (nodeId) {\n              targetMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yPos];\n              sourceMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n              count++;\n            });\n          };\n\n          for (var _i5 = 0; _i5 < horizontalAlign.length; _i5++) {\n            _loop3(_i5);\n          }\n          standardTransformation = true;\n        }\n        if (constraints.relativePlacementConstraint) {\n          reflectionType = true;\n        }\n      })();\n    } else if (constraints.relativePlacementConstraint) {\n      // finally check relative placement constraint\n      // find largest component in dag\n      var largestComponentSize = 0;\n      var largestComponentIndex = 0;\n      for (var _i6 = 0; _i6 < components.length; _i6++) {\n        if (components[_i6].length > largestComponentSize) {\n          largestComponentSize = components[_i6].length;\n          largestComponentIndex = _i6;\n        }\n      }\n      // if largest component isn't dominant, then take the votes for reflection\n      if (largestComponentSize < dagUndirected.size / 2) {\n        applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);\n        standardTransformation = false;\n        reflectionType = false;\n      } else {\n        // use largest component for transformation\n        // construct horizontal and vertical subgraphs in the largest component\n        var subGraphOnHorizontal = new Map();\n        var subGraphOnVertical = new Map();\n        var constraintsInlargestComponent = [];\n\n        components[largestComponentIndex].forEach(function (nodeId) {\n          dag.get(nodeId).forEach(function (adjacent) {\n            if (adjacent.direction == \"horizontal\") {\n              if (subGraphOnHorizontal.has(nodeId)) {\n                subGraphOnHorizontal.get(nodeId).push(adjacent);\n              } else {\n                subGraphOnHorizontal.set(nodeId, [adjacent]);\n              }\n              if (!subGraphOnHorizontal.has(adjacent.id)) {\n                subGraphOnHorizontal.set(adjacent.id, []);\n              }\n              constraintsInlargestComponent.push({ left: nodeId, right: adjacent.id });\n            } else {\n              if (subGraphOnVertical.has(nodeId)) {\n                subGraphOnVertical.get(nodeId).push(adjacent);\n              } else {\n                subGraphOnVertical.set(nodeId, [adjacent]);\n              }\n              if (!subGraphOnVertical.has(adjacent.id)) {\n                subGraphOnVertical.set(adjacent.id, []);\n              }\n              constraintsInlargestComponent.push({ top: nodeId, bottom: adjacent.id });\n            }\n          });\n        });\n\n        applyReflectionForRelativePlacement(constraintsInlargestComponent);\n        reflectionType = false;\n\n        // calculate appropriate positioning for subgraphs\n        var positionMapHorizontal = findAppropriatePositionForRelativePlacement(subGraphOnHorizontal, \"horizontal\");\n        var positionMapVertical = findAppropriatePositionForRelativePlacement(subGraphOnVertical, \"vertical\");\n\n        // construct source and target configuration\n        components[largestComponentIndex].forEach(function (nodeId, i) {\n          sourceMatrix[i] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n          targetMatrix[i] = [];\n          if (positionMapHorizontal.has(nodeId)) {\n            targetMatrix[i][0] = positionMapHorizontal.get(nodeId);\n          } else {\n            targetMatrix[i][0] = xCoords[nodeIndexes.get(nodeId)];\n          }\n          if (positionMapVertical.has(nodeId)) {\n            targetMatrix[i][1] = positionMapVertical.get(nodeId);\n          } else {\n            targetMatrix[i][1] = yCoords[nodeIndexes.get(nodeId)];\n          }\n        });\n\n        standardTransformation = true;\n      }\n    }\n\n    // if transformation is required, then calculate and apply transformation matrix\n    if (standardTransformation) {\n      /* calculate transformation matrix */\n      var transformationMatrix = void 0;\n      var targetMatrixTranspose = Matrix.transpose(targetMatrix); // A'\n      var sourceMatrixTranspose = Matrix.transpose(sourceMatrix); // B'\n\n      // centralize transpose matrices\n      for (var _i7 = 0; _i7 < targetMatrixTranspose.length; _i7++) {\n        targetMatrixTranspose[_i7] = Matrix.multGamma(targetMatrixTranspose[_i7]);\n        sourceMatrixTranspose[_i7] = Matrix.multGamma(sourceMatrixTranspose[_i7]);\n      }\n\n      // do actual calculation for transformation matrix\n      var tempMatrix = Matrix.multMat(targetMatrixTranspose, Matrix.transpose(sourceMatrixTranspose)); // tempMatrix = A'B\n      var SVDResult = SVD.svd(tempMatrix); // SVD(A'B) = USV', svd function returns U, S and V \n      transformationMatrix = Matrix.multMat(SVDResult.V, Matrix.transpose(SVDResult.U)); // transformationMatrix = T = VU'\n\n      /* apply found transformation matrix to obtain final draft layout */\n      for (var _i8 = 0; _i8 < nodeIndexes.size; _i8++) {\n        var temp1 = [xCoords[_i8], yCoords[_i8]];\n        var temp2 = [transformationMatrix[0][0], transformationMatrix[1][0]];\n        var temp3 = [transformationMatrix[0][1], transformationMatrix[1][1]];\n        xCoords[_i8] = Matrix.dotProduct(temp1, temp2);\n        yCoords[_i8] = Matrix.dotProduct(temp1, temp3);\n      }\n\n      // applied only both alignment and rel. placement constraints exist\n      if (reflectionType) {\n        applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);\n      }\n    }\n  }\n\n  if (CoSEConstants.ENFORCE_CONSTRAINTS) {\n    /****  enforce constraints on the transformed draft layout ****/\n\n    /* first enforce fixed node constraint */\n\n    if (constraints.fixedNodeConstraint && constraints.fixedNodeConstraint.length > 0) {\n      var translationAmount = { x: 0, y: 0 };\n      constraints.fixedNodeConstraint.forEach(function (nodeData, i) {\n        var posInTheory = { x: xCoords[nodeIndexes.get(nodeData.nodeId)], y: yCoords[nodeIndexes.get(nodeData.nodeId)] };\n        var posDesired = nodeData.position;\n        var posDiff = calculatePositionDiff(posDesired, posInTheory);\n        translationAmount.x += posDiff.x;\n        translationAmount.y += posDiff.y;\n      });\n      translationAmount.x /= constraints.fixedNodeConstraint.length;\n      translationAmount.y /= constraints.fixedNodeConstraint.length;\n\n      xCoords.forEach(function (value, i) {\n        xCoords[i] += translationAmount.x;\n      });\n\n      yCoords.forEach(function (value, i) {\n        yCoords[i] += translationAmount.y;\n      });\n\n      constraints.fixedNodeConstraint.forEach(function (nodeData) {\n        xCoords[nodeIndexes.get(nodeData.nodeId)] = nodeData.position.x;\n        yCoords[nodeIndexes.get(nodeData.nodeId)] = nodeData.position.y;\n      });\n    }\n\n    /* then enforce alignment constraint */\n\n    if (constraints.alignmentConstraint) {\n      if (constraints.alignmentConstraint.vertical) {\n        var xAlign = constraints.alignmentConstraint.vertical;\n\n        var _loop4 = function _loop4(_i9) {\n          var alignmentSet = new Set();\n          xAlign[_i9].forEach(function (nodeId) {\n            alignmentSet.add(nodeId);\n          });\n          var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n            return fixedNodes.has(x);\n          }));\n          var xPos = void 0;\n          if (intersection.size > 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else xPos = calculateAvgPosition(alignmentSet).x;\n\n          alignmentSet.forEach(function (nodeId) {\n            if (!fixedNodes.has(nodeId)) xCoords[nodeIndexes.get(nodeId)] = xPos;\n          });\n        };\n\n        for (var _i9 = 0; _i9 < xAlign.length; _i9++) {\n          _loop4(_i9);\n        }\n      }\n      if (constraints.alignmentConstraint.horizontal) {\n        var yAlign = constraints.alignmentConstraint.horizontal;\n\n        var _loop5 = function _loop5(_i10) {\n          var alignmentSet = new Set();\n          yAlign[_i10].forEach(function (nodeId) {\n            alignmentSet.add(nodeId);\n          });\n          var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n            return fixedNodes.has(x);\n          }));\n          var yPos = void 0;\n          if (intersection.size > 0) yPos = yCoords[nodeIndexes.get(intersection.values().next().value)];else yPos = calculateAvgPosition(alignmentSet).y;\n\n          alignmentSet.forEach(function (nodeId) {\n            if (!fixedNodes.has(nodeId)) yCoords[nodeIndexes.get(nodeId)] = yPos;\n          });\n        };\n\n        for (var _i10 = 0; _i10 < yAlign.length; _i10++) {\n          _loop5(_i10);\n        }\n      }\n    }\n\n    /* finally enforce relative placement constraint */\n\n    if (constraints.relativePlacementConstraint) {\n      (function () {\n        var nodeToDummyForVerticalAlignment = new Map();\n        var nodeToDummyForHorizontalAlignment = new Map();\n        var dummyToNodeForVerticalAlignment = new Map();\n        var dummyToNodeForHorizontalAlignment = new Map();\n        var dummyPositionsForVerticalAlignment = new Map();\n        var dummyPositionsForHorizontalAlignment = new Map();\n        var fixedNodesOnHorizontal = new Set();\n        var fixedNodesOnVertical = new Set();\n\n        // fill maps and sets      \n        fixedNodes.forEach(function (nodeId) {\n          fixedNodesOnHorizontal.add(nodeId);\n          fixedNodesOnVertical.add(nodeId);\n        });\n\n        if (constraints.alignmentConstraint) {\n          if (constraints.alignmentConstraint.vertical) {\n            var verticalAlignment = constraints.alignmentConstraint.vertical;\n\n            var _loop6 = function _loop6(_i11) {\n              dummyToNodeForVerticalAlignment.set(\"dummy\" + _i11, []);\n              verticalAlignment[_i11].forEach(function (nodeId) {\n                nodeToDummyForVerticalAlignment.set(nodeId, \"dummy\" + _i11);\n                dummyToNodeForVerticalAlignment.get(\"dummy\" + _i11).push(nodeId);\n                if (fixedNodes.has(nodeId)) {\n                  fixedNodesOnHorizontal.add(\"dummy\" + _i11);\n                }\n              });\n              dummyPositionsForVerticalAlignment.set(\"dummy\" + _i11, xCoords[nodeIndexes.get(verticalAlignment[_i11][0])]);\n            };\n\n            for (var _i11 = 0; _i11 < verticalAlignment.length; _i11++) {\n              _loop6(_i11);\n            }\n          }\n          if (constraints.alignmentConstraint.horizontal) {\n            var horizontalAlignment = constraints.alignmentConstraint.horizontal;\n\n            var _loop7 = function _loop7(_i12) {\n              dummyToNodeForHorizontalAlignment.set(\"dummy\" + _i12, []);\n              horizontalAlignment[_i12].forEach(function (nodeId) {\n                nodeToDummyForHorizontalAlignment.set(nodeId, \"dummy\" + _i12);\n                dummyToNodeForHorizontalAlignment.get(\"dummy\" + _i12).push(nodeId);\n                if (fixedNodes.has(nodeId)) {\n                  fixedNodesOnVertical.add(\"dummy\" + _i12);\n                }\n              });\n              dummyPositionsForHorizontalAlignment.set(\"dummy\" + _i12, yCoords[nodeIndexes.get(horizontalAlignment[_i12][0])]);\n            };\n\n            for (var _i12 = 0; _i12 < horizontalAlignment.length; _i12++) {\n              _loop7(_i12);\n            }\n          }\n        }\n\n        // construct horizontal and vertical dags (subgraphs) from overall dag\n        var dagOnHorizontal = new Map();\n        var dagOnVertical = new Map();\n\n        var _loop8 = function _loop8(nodeId) {\n          dag.get(nodeId).forEach(function (adjacent) {\n            var sourceId = void 0;\n            var targetNode = void 0;\n            if (adjacent[\"direction\"] == \"horizontal\") {\n              sourceId = nodeToDummyForVerticalAlignment.get(nodeId) ? nodeToDummyForVerticalAlignment.get(nodeId) : nodeId;\n              if (nodeToDummyForVerticalAlignment.get(adjacent.id)) {\n                targetNode = { id: nodeToDummyForVerticalAlignment.get(adjacent.id), gap: adjacent.gap, direction: adjacent.direction };\n              } else {\n                targetNode = adjacent;\n              }\n              if (dagOnHorizontal.has(sourceId)) {\n                dagOnHorizontal.get(sourceId).push(targetNode);\n              } else {\n                dagOnHorizontal.set(sourceId, [targetNode]);\n              }\n              if (!dagOnHorizontal.has(targetNode.id)) {\n                dagOnHorizontal.set(targetNode.id, []);\n              }\n            } else {\n              sourceId = nodeToDummyForHorizontalAlignment.get(nodeId) ? nodeToDummyForHorizontalAlignment.get(nodeId) : nodeId;\n              if (nodeToDummyForHorizontalAlignment.get(adjacent.id)) {\n                targetNode = { id: nodeToDummyForHorizontalAlignment.get(adjacent.id), gap: adjacent.gap, direction: adjacent.direction };\n              } else {\n                targetNode = adjacent;\n              }\n              if (dagOnVertical.has(sourceId)) {\n                dagOnVertical.get(sourceId).push(targetNode);\n              } else {\n                dagOnVertical.set(sourceId, [targetNode]);\n              }\n              if (!dagOnVertical.has(targetNode.id)) {\n                dagOnVertical.set(targetNode.id, []);\n              }\n            }\n          });\n        };\n\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = dag.keys()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var nodeId = _step5.value;\n\n            _loop8(nodeId);\n          }\n\n          // find source nodes of each component in horizontal and vertical dags\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5.return) {\n              _iterator5.return();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n\n        var undirectedOnHorizontal = dagToUndirected(dagOnHorizontal);\n        var undirectedOnVertical = dagToUndirected(dagOnVertical);\n        var componentsOnHorizontal = findComponents(undirectedOnHorizontal);\n        var componentsOnVertical = findComponents(undirectedOnVertical);\n        var reversedDagOnHorizontal = dagToReversed(dagOnHorizontal);\n        var reversedDagOnVertical = dagToReversed(dagOnVertical);\n        var componentSourcesOnHorizontal = [];\n        var componentSourcesOnVertical = [];\n\n        componentsOnHorizontal.forEach(function (component, index) {\n          componentSourcesOnHorizontal[index] = [];\n          component.forEach(function (nodeId) {\n            if (reversedDagOnHorizontal.get(nodeId).length == 0) {\n              componentSourcesOnHorizontal[index].push(nodeId);\n            }\n          });\n        });\n\n        componentsOnVertical.forEach(function (component, index) {\n          componentSourcesOnVertical[index] = [];\n          component.forEach(function (nodeId) {\n            if (reversedDagOnVertical.get(nodeId).length == 0) {\n              componentSourcesOnVertical[index].push(nodeId);\n            }\n          });\n        });\n\n        // calculate appropriate positioning for subgraphs\n        var positionMapHorizontal = findAppropriatePositionForRelativePlacement(dagOnHorizontal, \"horizontal\", fixedNodesOnHorizontal, dummyPositionsForVerticalAlignment, componentSourcesOnHorizontal);\n        var positionMapVertical = findAppropriatePositionForRelativePlacement(dagOnVertical, \"vertical\", fixedNodesOnVertical, dummyPositionsForHorizontalAlignment, componentSourcesOnVertical);\n\n        // update positions of the nodes based on relative placement constraints\n\n        var _loop9 = function _loop9(key) {\n          if (dummyToNodeForVerticalAlignment.get(key)) {\n            dummyToNodeForVerticalAlignment.get(key).forEach(function (nodeId) {\n              xCoords[nodeIndexes.get(nodeId)] = positionMapHorizontal.get(key);\n            });\n          } else {\n            xCoords[nodeIndexes.get(key)] = positionMapHorizontal.get(key);\n          }\n        };\n\n        var _iteratorNormalCompletion6 = true;\n        var _didIteratorError6 = false;\n        var _iteratorError6 = undefined;\n\n        try {\n          for (var _iterator6 = positionMapHorizontal.keys()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n            var key = _step6.value;\n\n            _loop9(key);\n          }\n        } catch (err) {\n          _didIteratorError6 = true;\n          _iteratorError6 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion6 && _iterator6.return) {\n              _iterator6.return();\n            }\n          } finally {\n            if (_didIteratorError6) {\n              throw _iteratorError6;\n            }\n          }\n        }\n\n        var _loop10 = function _loop10(key) {\n          if (dummyToNodeForHorizontalAlignment.get(key)) {\n            dummyToNodeForHorizontalAlignment.get(key).forEach(function (nodeId) {\n              yCoords[nodeIndexes.get(nodeId)] = positionMapVertical.get(key);\n            });\n          } else {\n            yCoords[nodeIndexes.get(key)] = positionMapVertical.get(key);\n          }\n        };\n\n        var _iteratorNormalCompletion7 = true;\n        var _didIteratorError7 = false;\n        var _iteratorError7 = undefined;\n\n        try {\n          for (var _iterator7 = positionMapVertical.keys()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n            var key = _step7.value;\n\n            _loop10(key);\n          }\n        } catch (err) {\n          _didIteratorError7 = true;\n          _iteratorError7 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion7 && _iterator7.return) {\n              _iterator7.return();\n            }\n          } finally {\n            if (_didIteratorError7) {\n              throw _iteratorError7;\n            }\n          }\n        }\n      })();\n    }\n  }\n\n  // assign new coordinates to nodes after constraint handling\n  for (var _i13 = 0; _i13 < allNodes.length; _i13++) {\n    var _node = allNodes[_i13];\n    if (_node.getChild() == null) {\n      _node.setCenter(xCoords[nodeIndexes.get(_node.id)], yCoords[nodeIndexes.get(_node.id)]);\n    }\n  }\n};\n\nmodule.exports = ConstraintHandler;\n\n/***/ }),\n\n/***/ 551:\n/***/ ((module) => {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__551__;\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \tvar __webpack_exports__ = __webpack_require__(45);\n/******/ \t\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}