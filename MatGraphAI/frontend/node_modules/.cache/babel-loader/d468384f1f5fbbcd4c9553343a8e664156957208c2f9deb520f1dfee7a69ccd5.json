{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory(require(\"cose-base\"));else if (typeof define === 'function' && define.amd) define([\"cose-base\"], factory);else if (typeof exports === 'object') exports[\"cytoscapeFcose\"] = factory(require(\"cose-base\"));else root[\"cytoscapeFcose\"] = factory(root[\"coseBase\"]);\n})(this, function (__WEBPACK_EXTERNAL_MODULE__140__) {\n  return (/******/(() => {\n      // webpackBootstrap\n      /******/\n      \"use strict\";\n\n      /******/\n      var __webpack_modules__ = {\n        /***/658: /***/module => {\n          // Simple, internal Object.assign() polyfill for options objects etc.\n\n          module.exports = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {\n            for (var _len = arguments.length, srcs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n              srcs[_key - 1] = arguments[_key];\n            }\n            srcs.forEach(function (src) {\n              Object.keys(src).forEach(function (k) {\n                return tgt[k] = src[k];\n              });\n            });\n            return tgt;\n          };\n\n          /***/\n        },\n\n        /***/548: /***/(module, __unused_webpack_exports, __webpack_require__) => {\n          var _slicedToArray = function () {\n            function sliceIterator(arr, i) {\n              var _arr = [];\n              var _n = true;\n              var _d = false;\n              var _e = undefined;\n              try {\n                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n                  _arr.push(_s.value);\n                  if (i && _arr.length === i) break;\n                }\n              } catch (err) {\n                _d = true;\n                _e = err;\n              } finally {\n                try {\n                  if (!_n && _i[\"return\"]) _i[\"return\"]();\n                } finally {\n                  if (_d) throw _e;\n                }\n              }\n              return _arr;\n            }\n            return function (arr, i) {\n              if (Array.isArray(arr)) {\n                return arr;\n              } else if (Symbol.iterator in Object(arr)) {\n                return sliceIterator(arr, i);\n              } else {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n              }\n            };\n          }();\n\n          /*\n           * Auxiliary functions\n           */\n\n          var LinkedList = __webpack_require__(140).layoutBase.LinkedList;\n          var auxiliary = {};\n\n          // get the top most nodes\n          auxiliary.getTopMostNodes = function (nodes) {\n            var nodesMap = {};\n            for (var i = 0; i < nodes.length; i++) {\n              nodesMap[nodes[i].id()] = true;\n            }\n            var roots = nodes.filter(function (ele, i) {\n              if (typeof ele === \"number\") {\n                ele = i;\n              }\n              var parent = ele.parent()[0];\n              while (parent != null) {\n                if (nodesMap[parent.id()]) {\n                  return false;\n                }\n                parent = parent.parent()[0];\n              }\n              return true;\n            });\n            return roots;\n          };\n\n          // find disconnected components and create dummy nodes that connect them\n          auxiliary.connectComponents = function (cy, eles, topMostNodes, dummyNodes) {\n            var queue = new LinkedList();\n            var visited = new Set();\n            var visitedTopMostNodes = [];\n            var currentNeighbor = void 0;\n            var minDegreeNode = void 0;\n            var minDegree = void 0;\n            var isConnected = false;\n            var count = 1;\n            var nodesConnectedToDummy = [];\n            var components = [];\n            var _loop = function _loop() {\n              var cmpt = cy.collection();\n              components.push(cmpt);\n              var currentNode = topMostNodes[0];\n              var childrenOfCurrentNode = cy.collection();\n              childrenOfCurrentNode.merge(currentNode).merge(currentNode.descendants().intersection(eles));\n              visitedTopMostNodes.push(currentNode);\n              childrenOfCurrentNode.forEach(function (node) {\n                queue.push(node);\n                visited.add(node);\n                cmpt.merge(node);\n              });\n              var _loop2 = function _loop2() {\n                currentNode = queue.shift();\n\n                // Traverse all neighbors of this node\n                var neighborNodes = cy.collection();\n                currentNode.neighborhood().nodes().forEach(function (node) {\n                  if (eles.intersection(currentNode.edgesWith(node)).length > 0) {\n                    neighborNodes.merge(node);\n                  }\n                });\n                for (var i = 0; i < neighborNodes.length; i++) {\n                  var neighborNode = neighborNodes[i];\n                  currentNeighbor = topMostNodes.intersection(neighborNode.union(neighborNode.ancestors()));\n                  if (currentNeighbor != null && !visited.has(currentNeighbor[0])) {\n                    var childrenOfNeighbor = currentNeighbor.union(currentNeighbor.descendants());\n                    childrenOfNeighbor.forEach(function (node) {\n                      queue.push(node);\n                      visited.add(node);\n                      cmpt.merge(node);\n                      if (topMostNodes.has(node)) {\n                        visitedTopMostNodes.push(node);\n                      }\n                    });\n                  }\n                }\n              };\n              while (queue.length != 0) {\n                _loop2();\n              }\n              cmpt.forEach(function (node) {\n                eles.intersection(node.connectedEdges()).forEach(function (e) {\n                  // connectedEdges() usually cached\n                  if (cmpt.has(e.source()) && cmpt.has(e.target())) {\n                    // has() is cheap\n                    cmpt.merge(e);\n                  }\n                });\n              });\n              if (visitedTopMostNodes.length == topMostNodes.length) {\n                isConnected = true;\n              }\n              if (!isConnected || isConnected && count > 1) {\n                minDegreeNode = visitedTopMostNodes[0];\n                minDegree = minDegreeNode.connectedEdges().length;\n                visitedTopMostNodes.forEach(function (node) {\n                  if (node.connectedEdges().length < minDegree) {\n                    minDegree = node.connectedEdges().length;\n                    minDegreeNode = node;\n                  }\n                });\n                nodesConnectedToDummy.push(minDegreeNode.id());\n                // TO DO: Check efficiency of this part\n                var temp = cy.collection();\n                temp.merge(visitedTopMostNodes[0]);\n                visitedTopMostNodes.forEach(function (node) {\n                  temp.merge(node);\n                });\n                visitedTopMostNodes = [];\n                topMostNodes = topMostNodes.difference(temp);\n                count++;\n              }\n            };\n            do {\n              _loop();\n            } while (!isConnected);\n            if (dummyNodes) {\n              if (nodesConnectedToDummy.length > 0) {\n                dummyNodes.set('dummy' + (dummyNodes.size + 1), nodesConnectedToDummy);\n              }\n            }\n            return components;\n          };\n\n          // relocates componentResult to originalCenter if there is no fixedNodeConstraint\n          auxiliary.relocateComponent = function (originalCenter, componentResult, options) {\n            if (!options.fixedNodeConstraint) {\n              var minXCoord = Number.POSITIVE_INFINITY;\n              var maxXCoord = Number.NEGATIVE_INFINITY;\n              var minYCoord = Number.POSITIVE_INFINITY;\n              var maxYCoord = Number.NEGATIVE_INFINITY;\n              if (options.quality == \"draft\") {\n                // calculate current bounding box\n                var _iteratorNormalCompletion = true;\n                var _didIteratorError = false;\n                var _iteratorError = undefined;\n                try {\n                  for (var _iterator = componentResult.nodeIndexes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var _ref = _step.value;\n                    var _ref2 = _slicedToArray(_ref, 2);\n                    var key = _ref2[0];\n                    var value = _ref2[1];\n                    var cyNode = options.cy.getElementById(key);\n                    if (cyNode) {\n                      var nodeBB = cyNode.boundingBox();\n                      var leftX = componentResult.xCoords[value] - nodeBB.w / 2;\n                      var rightX = componentResult.xCoords[value] + nodeBB.w / 2;\n                      var topY = componentResult.yCoords[value] - nodeBB.h / 2;\n                      var bottomY = componentResult.yCoords[value] + nodeBB.h / 2;\n                      if (leftX < minXCoord) minXCoord = leftX;\n                      if (rightX > maxXCoord) maxXCoord = rightX;\n                      if (topY < minYCoord) minYCoord = topY;\n                      if (bottomY > maxYCoord) maxYCoord = bottomY;\n                    }\n                  }\n                  // find difference between current and original center\n                } catch (err) {\n                  _didIteratorError = true;\n                  _iteratorError = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                      _iterator.return();\n                    }\n                  } finally {\n                    if (_didIteratorError) {\n                      throw _iteratorError;\n                    }\n                  }\n                }\n                var diffOnX = originalCenter.x - (maxXCoord + minXCoord) / 2;\n                var diffOnY = originalCenter.y - (maxYCoord + minYCoord) / 2;\n                // move component to original center\n                componentResult.xCoords = componentResult.xCoords.map(function (x) {\n                  return x + diffOnX;\n                });\n                componentResult.yCoords = componentResult.yCoords.map(function (y) {\n                  return y + diffOnY;\n                });\n              } else {\n                // calculate current bounding box\n                Object.keys(componentResult).forEach(function (item) {\n                  var node = componentResult[item];\n                  var leftX = node.getRect().x;\n                  var rightX = node.getRect().x + node.getRect().width;\n                  var topY = node.getRect().y;\n                  var bottomY = node.getRect().y + node.getRect().height;\n                  if (leftX < minXCoord) minXCoord = leftX;\n                  if (rightX > maxXCoord) maxXCoord = rightX;\n                  if (topY < minYCoord) minYCoord = topY;\n                  if (bottomY > maxYCoord) maxYCoord = bottomY;\n                });\n                // find difference between current and original center\n                var _diffOnX = originalCenter.x - (maxXCoord + minXCoord) / 2;\n                var _diffOnY = originalCenter.y - (maxYCoord + minYCoord) / 2;\n                // move component to original center\n                Object.keys(componentResult).forEach(function (item) {\n                  var node = componentResult[item];\n                  node.setCenter(node.getCenterX() + _diffOnX, node.getCenterY() + _diffOnY);\n                });\n              }\n            }\n          };\n          auxiliary.calcBoundingBox = function (parentNode, xCoords, yCoords, nodeIndexes) {\n            // calculate bounds\n            var left = Number.MAX_SAFE_INTEGER;\n            var right = Number.MIN_SAFE_INTEGER;\n            var top = Number.MAX_SAFE_INTEGER;\n            var bottom = Number.MIN_SAFE_INTEGER;\n            var nodeLeft = void 0;\n            var nodeRight = void 0;\n            var nodeTop = void 0;\n            var nodeBottom = void 0;\n            var nodes = parentNode.descendants().not(\":parent\");\n            var s = nodes.length;\n            for (var i = 0; i < s; i++) {\n              var node = nodes[i];\n              nodeLeft = xCoords[nodeIndexes.get(node.id())] - node.width() / 2;\n              nodeRight = xCoords[nodeIndexes.get(node.id())] + node.width() / 2;\n              nodeTop = yCoords[nodeIndexes.get(node.id())] - node.height() / 2;\n              nodeBottom = yCoords[nodeIndexes.get(node.id())] + node.height() / 2;\n              if (left > nodeLeft) {\n                left = nodeLeft;\n              }\n              if (right < nodeRight) {\n                right = nodeRight;\n              }\n              if (top > nodeTop) {\n                top = nodeTop;\n              }\n              if (bottom < nodeBottom) {\n                bottom = nodeBottom;\n              }\n            }\n            var boundingBox = {};\n            boundingBox.topLeftX = left;\n            boundingBox.topLeftY = top;\n            boundingBox.width = right - left;\n            boundingBox.height = bottom - top;\n            return boundingBox;\n          };\n\n          // This function finds and returns parent nodes whose all children are hidden\n          auxiliary.calcParentsWithoutChildren = function (cy, eles) {\n            var parentsWithoutChildren = cy.collection();\n            eles.nodes(':parent').forEach(function (parent) {\n              var check = false;\n              parent.children().forEach(function (child) {\n                if (child.css('display') != 'none') {\n                  check = true;\n                }\n              });\n              if (!check) {\n                parentsWithoutChildren.merge(parent);\n              }\n            });\n            return parentsWithoutChildren;\n          };\n          module.exports = auxiliary;\n\n          /***/\n        },\n\n        /***/816: /***/(module, __unused_webpack_exports, __webpack_require__) => {\n          /**\n            The implementation of the postprocessing part that applies CoSE layout over the spectral layout\n          */\n\n          var aux = __webpack_require__(548);\n          var CoSELayout = __webpack_require__(140).CoSELayout;\n          var CoSENode = __webpack_require__(140).CoSENode;\n          var PointD = __webpack_require__(140).layoutBase.PointD;\n          var DimensionD = __webpack_require__(140).layoutBase.DimensionD;\n          var LayoutConstants = __webpack_require__(140).layoutBase.LayoutConstants;\n          var FDLayoutConstants = __webpack_require__(140).layoutBase.FDLayoutConstants;\n          var CoSEConstants = __webpack_require__(140).CoSEConstants;\n\n          // main function that cose layout is processed\n          var coseLayout = function coseLayout(options, spectralResult) {\n            var cy = options.cy;\n            var eles = options.eles;\n            var nodes = eles.nodes();\n            var edges = eles.edges();\n            var nodeIndexes = void 0;\n            var xCoords = void 0;\n            var yCoords = void 0;\n            var idToLNode = {};\n            if (options.randomize) {\n              nodeIndexes = spectralResult[\"nodeIndexes\"];\n              xCoords = spectralResult[\"xCoords\"];\n              yCoords = spectralResult[\"yCoords\"];\n            }\n            var isFn = function isFn(fn) {\n              return typeof fn === 'function';\n            };\n            var optFn = function optFn(opt, ele) {\n              if (isFn(opt)) {\n                return opt(ele);\n              } else {\n                return opt;\n              }\n            };\n\n            /**** Postprocessing functions ****/\n\n            var parentsWithoutChildren = aux.calcParentsWithoutChildren(cy, eles);\n\n            // transfer cytoscape nodes to cose nodes\n            var processChildrenList = function processChildrenList(parent, children, layout, options) {\n              var size = children.length;\n              for (var i = 0; i < size; i++) {\n                var theChild = children[i];\n                var children_of_children = null;\n                if (theChild.intersection(parentsWithoutChildren).length == 0) {\n                  children_of_children = theChild.children();\n                }\n                var theNode = void 0;\n                var dimensions = theChild.layoutDimensions({\n                  nodeDimensionsIncludeLabels: options.nodeDimensionsIncludeLabels\n                });\n                if (theChild.outerWidth() != null && theChild.outerHeight() != null) {\n                  if (options.randomize) {\n                    if (!theChild.isParent()) {\n                      theNode = parent.add(new CoSENode(layout.graphManager, new PointD(xCoords[nodeIndexes.get(theChild.id())] - dimensions.w / 2, yCoords[nodeIndexes.get(theChild.id())] - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n                    } else {\n                      var parentInfo = aux.calcBoundingBox(theChild, xCoords, yCoords, nodeIndexes);\n                      if (theChild.intersection(parentsWithoutChildren).length == 0) {\n                        theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parentInfo.width, parentInfo.height)));\n                      } else {\n                        // for the parentsWithoutChildren\n                        theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n                      }\n                    }\n                  } else {\n                    theNode = parent.add(new CoSENode(layout.graphManager, new PointD(theChild.position('x') - dimensions.w / 2, theChild.position('y') - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n                  }\n                } else {\n                  theNode = parent.add(new CoSENode(this.graphManager));\n                }\n                // Attach id to the layout node and repulsion value\n                theNode.id = theChild.data(\"id\");\n                theNode.nodeRepulsion = optFn(options.nodeRepulsion, theChild);\n                // Attach the paddings of cy node to layout node\n                theNode.paddingLeft = parseInt(theChild.css('padding'));\n                theNode.paddingTop = parseInt(theChild.css('padding'));\n                theNode.paddingRight = parseInt(theChild.css('padding'));\n                theNode.paddingBottom = parseInt(theChild.css('padding'));\n\n                //Attach the label properties to both compound and simple nodes if labels will be included in node dimensions\n                //These properties will be used while updating bounds of compounds during iterations or tiling\n                //and will be used for simple nodes while transferring final positions to cytoscape\n                if (options.nodeDimensionsIncludeLabels) {\n                  theNode.labelWidth = theChild.boundingBox({\n                    includeLabels: true,\n                    includeNodes: false,\n                    includeOverlays: false\n                  }).w;\n                  theNode.labelHeight = theChild.boundingBox({\n                    includeLabels: true,\n                    includeNodes: false,\n                    includeOverlays: false\n                  }).h;\n                  theNode.labelPosVertical = theChild.css(\"text-valign\");\n                  theNode.labelPosHorizontal = theChild.css(\"text-halign\");\n                }\n\n                // Map the layout node\n                idToLNode[theChild.data(\"id\")] = theNode;\n                if (isNaN(theNode.rect.x)) {\n                  theNode.rect.x = 0;\n                }\n                if (isNaN(theNode.rect.y)) {\n                  theNode.rect.y = 0;\n                }\n                if (children_of_children != null && children_of_children.length > 0) {\n                  var theNewGraph = void 0;\n                  theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);\n                  processChildrenList(theNewGraph, children_of_children, layout, options);\n                }\n              }\n            };\n\n            // transfer cytoscape edges to cose edges\n            var processEdges = function processEdges(layout, gm, edges) {\n              var idealLengthTotal = 0;\n              var edgeCount = 0;\n              for (var i = 0; i < edges.length; i++) {\n                var edge = edges[i];\n                var sourceNode = idToLNode[edge.data(\"source\")];\n                var targetNode = idToLNode[edge.data(\"target\")];\n                if (sourceNode && targetNode && sourceNode !== targetNode && sourceNode.getEdgesBetween(targetNode).length == 0) {\n                  var e1 = gm.add(layout.newEdge(), sourceNode, targetNode);\n                  e1.id = edge.id();\n                  e1.idealLength = optFn(options.idealEdgeLength, edge);\n                  e1.edgeElasticity = optFn(options.edgeElasticity, edge);\n                  idealLengthTotal += e1.idealLength;\n                  edgeCount++;\n                }\n              }\n              // we need to update the ideal edge length constant with the avg. ideal length value after processing edges\n              // in case there is no edge, use other options\n              if (options.idealEdgeLength != null) {\n                if (edgeCount > 0) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = idealLengthTotal / edgeCount;else if (!isFn(options.idealEdgeLength))\n                  // in case there is no edge, but option gives a value to use\n                  CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;else\n                  // in case there is no edge and we cannot get a value from option (because it's a function)\n                  CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\n                // we need to update these constant values based on the ideal edge length constant\n                CoSEConstants.MIN_REPULSION_DIST = FDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\n                CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n              }\n            };\n\n            // transfer cytoscape constraints to cose layout\n            var processConstraints = function processConstraints(layout, options) {\n              // get nodes to be fixed\n              if (options.fixedNodeConstraint) {\n                layout.constraints[\"fixedNodeConstraint\"] = options.fixedNodeConstraint;\n              }\n              // get nodes to be aligned\n              if (options.alignmentConstraint) {\n                layout.constraints[\"alignmentConstraint\"] = options.alignmentConstraint;\n              }\n              // get nodes to be relatively placed\n              if (options.relativePlacementConstraint) {\n                layout.constraints[\"relativePlacementConstraint\"] = options.relativePlacementConstraint;\n              }\n            };\n\n            /**** Apply postprocessing ****/\n            if (options.nestingFactor != null) CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;\n            if (options.gravity != null) CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;\n            if (options.numIter != null) CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;\n            if (options.gravityRange != null) CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;\n            if (options.gravityCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;\n            if (options.gravityRangeCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;\n            if (options.initialEnergyOnIncremental != null) CoSEConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = options.initialEnergyOnIncremental;\n            if (options.tilingCompareBy != null) CoSEConstants.TILING_COMPARE_BY = options.tilingCompareBy;\n            if (options.quality == 'proof') LayoutConstants.QUALITY = 2;else LayoutConstants.QUALITY = 0;\n            CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS = FDLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = options.nodeDimensionsIncludeLabels;\n            CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = !options.randomize;\n            CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = LayoutConstants.ANIMATE = options.animate;\n            CoSEConstants.TILE = options.tile;\n            CoSEConstants.TILING_PADDING_VERTICAL = typeof options.tilingPaddingVertical === 'function' ? options.tilingPaddingVertical.call() : options.tilingPaddingVertical;\n            CoSEConstants.TILING_PADDING_HORIZONTAL = typeof options.tilingPaddingHorizontal === 'function' ? options.tilingPaddingHorizontal.call() : options.tilingPaddingHorizontal;\n            CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = true;\n            CoSEConstants.PURE_INCREMENTAL = !options.randomize;\n            LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = options.uniformNodeDimensions;\n\n            // This part is for debug/demo purpose\n            if (options.step == \"transformed\") {\n              CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\n              CoSEConstants.ENFORCE_CONSTRAINTS = false;\n              CoSEConstants.APPLY_LAYOUT = false;\n            }\n            if (options.step == \"enforced\") {\n              CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n              CoSEConstants.ENFORCE_CONSTRAINTS = true;\n              CoSEConstants.APPLY_LAYOUT = false;\n            }\n            if (options.step == \"cose\") {\n              CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n              CoSEConstants.ENFORCE_CONSTRAINTS = false;\n              CoSEConstants.APPLY_LAYOUT = true;\n            }\n            if (options.step == \"all\") {\n              if (options.randomize) CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;else CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n              CoSEConstants.ENFORCE_CONSTRAINTS = true;\n              CoSEConstants.APPLY_LAYOUT = true;\n            }\n            if (options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint) {\n              CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false;\n            } else {\n              CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true;\n            }\n            var coseLayout = new CoSELayout();\n            var gm = coseLayout.newGraphManager();\n            processChildrenList(gm.addRoot(), aux.getTopMostNodes(nodes), coseLayout, options);\n            processEdges(coseLayout, gm, edges);\n            processConstraints(coseLayout, options);\n            coseLayout.runLayout();\n            return idToLNode;\n          };\n          module.exports = {\n            coseLayout: coseLayout\n          };\n\n          /***/\n        },\n\n        /***/212: /***/(module, __unused_webpack_exports, __webpack_require__) => {\n          var _createClass = function () {\n            function defineProperties(target, props) {\n              for (var i = 0; i < props.length; i++) {\n                var descriptor = props[i];\n                descriptor.enumerable = descriptor.enumerable || false;\n                descriptor.configurable = true;\n                if (\"value\" in descriptor) descriptor.writable = true;\n                Object.defineProperty(target, descriptor.key, descriptor);\n              }\n            }\n            return function (Constructor, protoProps, staticProps) {\n              if (protoProps) defineProperties(Constructor.prototype, protoProps);\n              if (staticProps) defineProperties(Constructor, staticProps);\n              return Constructor;\n            };\n          }();\n          function _classCallCheck(instance, Constructor) {\n            if (!(instance instanceof Constructor)) {\n              throw new TypeError(\"Cannot call a class as a function\");\n            }\n          }\n\n          /**\n            The implementation of the fcose layout algorithm\n          */\n\n          var assign = __webpack_require__(658);\n          var aux = __webpack_require__(548);\n          var _require = __webpack_require__(657),\n            spectralLayout = _require.spectralLayout;\n          var _require2 = __webpack_require__(816),\n            coseLayout = _require2.coseLayout;\n          var defaults = Object.freeze({\n            // 'draft', 'default' or 'proof' \n            // - 'draft' only applies spectral layout \n            // - 'default' improves the quality with subsequent CoSE layout (fast cooling rate)\n            // - 'proof' improves the quality with subsequent CoSE layout (slow cooling rate) \n            quality: \"default\",\n            // Use random node positions at beginning of layout\n            // if this is set to false, then quality option must be \"proof\"\n            randomize: true,\n            // Whether or not to animate the layout\n            animate: true,\n            // Duration of animation in ms, if enabled\n            animationDuration: 1000,\n            // Easing of animation, if enabled\n            animationEasing: undefined,\n            // Fit the viewport to the repositioned nodes\n            fit: true,\n            // Padding around layout\n            padding: 30,\n            // Whether to include labels in node dimensions. Valid in \"proof\" quality\n            nodeDimensionsIncludeLabels: false,\n            // Whether or not simple nodes (non-compound nodes) are of uniform dimensions\n            uniformNodeDimensions: false,\n            // Whether to pack disconnected components - valid only if randomize: true\n            packComponents: true,\n            // Layout step - all, transformed, enforced, cose - for debug purpose only\n            step: \"all\",\n            /* spectral layout options */\n\n            // False for random, true for greedy\n            samplingType: true,\n            // Sample size to construct distance matrix\n            sampleSize: 25,\n            // Separation amount between nodes\n            nodeSeparation: 75,\n            // Power iteration tolerance\n            piTol: 0.0000001,\n            /* CoSE layout options */\n\n            // Node repulsion (non overlapping) multiplier\n            nodeRepulsion: function nodeRepulsion(node) {\n              return 4500;\n            },\n            // Ideal edge (non nested) length\n            idealEdgeLength: function idealEdgeLength(edge) {\n              return 50;\n            },\n            // Divisor to compute edge forces\n            edgeElasticity: function edgeElasticity(edge) {\n              return 0.45;\n            },\n            // Nesting factor (multiplier) to compute ideal edge length for nested edges\n            nestingFactor: 0.1,\n            // Gravity force (constant)\n            gravity: 0.25,\n            // Maximum number of iterations to perform\n            numIter: 2500,\n            // For enabling tiling\n            tile: true,\n            // The function that specifies the criteria for comparing nodes while sorting them during tiling operation.\n            // Takes the node id as a parameter and the default tiling operation is perfomed when this option is not set.\n            tilingCompareBy: undefined,\n            // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)\n            tilingPaddingVertical: 10,\n            // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)\n            tilingPaddingHorizontal: 10,\n            // Gravity range (constant) for compounds\n            gravityRangeCompound: 1.5,\n            // Gravity force (constant) for compounds\n            gravityCompound: 1.0,\n            // Gravity range (constant)\n            gravityRange: 3.8,\n            // Initial cooling factor for incremental layout  \n            initialEnergyOnIncremental: 0.3,\n            /* constraint options */\n\n            // Fix required nodes to predefined positions\n            // [{nodeId: 'n1', position: {x: 100, y: 200}, {...}]\n            fixedNodeConstraint: undefined,\n            // Align required nodes in vertical/horizontal direction\n            // {vertical: [['n1', 'n2')], ['n3', 'n4']], horizontal: ['n2', 'n4']}\n            alignmentConstraint: undefined,\n            // Place two nodes relatively in vertical/horizontal direction \n            // [{top: 'n1', bottom: 'n2', gap: 100}, {left: 'n3', right: 'n4', gap: 75}]\n            relativePlacementConstraint: undefined,\n            /* layout event callbacks */\n            ready: function ready() {},\n            // on layoutready\n            stop: function stop() {} // on layoutstop\n          });\n\n          var Layout = function () {\n            function Layout(options) {\n              _classCallCheck(this, Layout);\n              this.options = assign({}, defaults, options);\n            }\n            _createClass(Layout, [{\n              key: 'run',\n              value: function run() {\n                var layout = this;\n                var options = this.options;\n                var cy = options.cy;\n                var eles = options.eles;\n                var spectralResult = [];\n                var xCoords = void 0;\n                var yCoords = void 0;\n                var coseResult = [];\n                var components = void 0;\n                var componentCenters = [];\n\n                // basic validity check for constraint inputs \n                if (options.fixedNodeConstraint && (!Array.isArray(options.fixedNodeConstraint) || options.fixedNodeConstraint.length == 0)) {\n                  options.fixedNodeConstraint = undefined;\n                }\n                if (options.alignmentConstraint) {\n                  if (options.alignmentConstraint.vertical && (!Array.isArray(options.alignmentConstraint.vertical) || options.alignmentConstraint.vertical.length == 0)) {\n                    options.alignmentConstraint.vertical = undefined;\n                  }\n                  if (options.alignmentConstraint.horizontal && (!Array.isArray(options.alignmentConstraint.horizontal) || options.alignmentConstraint.horizontal.length == 0)) {\n                    options.alignmentConstraint.horizontal = undefined;\n                  }\n                }\n                if (options.relativePlacementConstraint && (!Array.isArray(options.relativePlacementConstraint) || options.relativePlacementConstraint.length == 0)) {\n                  options.relativePlacementConstraint = undefined;\n                }\n\n                // if any constraint exists, set some options\n                var constraintExist = options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint;\n                if (constraintExist) {\n                  // constraints work with these options\n                  options.tile = false;\n                  options.packComponents = false;\n                }\n\n                // decide component packing is enabled or not\n                var layUtil = void 0;\n                var packingEnabled = false;\n                if (cy.layoutUtilities && options.packComponents) {\n                  layUtil = cy.layoutUtilities(\"get\");\n                  if (!layUtil) layUtil = cy.layoutUtilities();\n                  packingEnabled = true;\n                }\n                if (eles.nodes().length > 0) {\n                  // if packing is not enabled, perform layout on the whole graph\n                  if (!packingEnabled) {\n                    // store component center\n                    var boundingBox = options.eles.boundingBox();\n                    componentCenters.push({\n                      x: boundingBox.x1 + boundingBox.w / 2,\n                      y: boundingBox.y1 + boundingBox.h / 2\n                    });\n                    // apply spectral layout\n                    if (options.randomize) {\n                      var result = spectralLayout(options);\n                      spectralResult.push(result);\n                    }\n                    // apply cose layout as postprocessing\n                    if (options.quality == \"default\" || options.quality == \"proof\") {\n                      coseResult.push(coseLayout(options, spectralResult[0]));\n                      aux.relocateComponent(componentCenters[0], coseResult[0], options); // relocate center to original position\n                    } else {\n                      aux.relocateComponent(componentCenters[0], spectralResult[0], options); // relocate center to original position\n                    }\n                  } else {\n                    // packing is enabled\n                    var topMostNodes = aux.getTopMostNodes(options.eles.nodes());\n                    components = aux.connectComponents(cy, options.eles, topMostNodes);\n                    // store component centers\n                    components.forEach(function (component) {\n                      var boundingBox = component.boundingBox();\n                      componentCenters.push({\n                        x: boundingBox.x1 + boundingBox.w / 2,\n                        y: boundingBox.y1 + boundingBox.h / 2\n                      });\n                    });\n\n                    //send each component to spectral layout if randomized\n                    if (options.randomize) {\n                      components.forEach(function (component) {\n                        options.eles = component;\n                        spectralResult.push(spectralLayout(options));\n                      });\n                    }\n                    if (options.quality == \"default\" || options.quality == \"proof\") {\n                      var toBeTiledNodes = cy.collection();\n                      if (options.tile) {\n                        // behave nodes to be tiled as one component\n                        var nodeIndexes = new Map();\n                        var _xCoords = [];\n                        var _yCoords = [];\n                        var count = 0;\n                        var tempSpectralResult = {\n                          nodeIndexes: nodeIndexes,\n                          xCoords: _xCoords,\n                          yCoords: _yCoords\n                        };\n                        var indexesToBeDeleted = [];\n                        components.forEach(function (component, index) {\n                          if (component.edges().length == 0) {\n                            component.nodes().forEach(function (node, i) {\n                              toBeTiledNodes.merge(component.nodes()[i]);\n                              if (!node.isParent()) {\n                                tempSpectralResult.nodeIndexes.set(component.nodes()[i].id(), count++);\n                                tempSpectralResult.xCoords.push(component.nodes()[0].position().x);\n                                tempSpectralResult.yCoords.push(component.nodes()[0].position().y);\n                              }\n                            });\n                            indexesToBeDeleted.push(index);\n                          }\n                        });\n                        if (toBeTiledNodes.length > 1) {\n                          var _boundingBox = toBeTiledNodes.boundingBox();\n                          componentCenters.push({\n                            x: _boundingBox.x1 + _boundingBox.w / 2,\n                            y: _boundingBox.y1 + _boundingBox.h / 2\n                          });\n                          components.push(toBeTiledNodes);\n                          spectralResult.push(tempSpectralResult);\n                          for (var i = indexesToBeDeleted.length - 1; i >= 0; i--) {\n                            components.splice(indexesToBeDeleted[i], 1);\n                            spectralResult.splice(indexesToBeDeleted[i], 1);\n                            componentCenters.splice(indexesToBeDeleted[i], 1);\n                          }\n                          ;\n                        }\n                      }\n                      components.forEach(function (component, index) {\n                        // send each component to cose layout\n                        options.eles = component;\n                        coseResult.push(coseLayout(options, spectralResult[index]));\n                        aux.relocateComponent(componentCenters[index], coseResult[index], options); // relocate center to original position\n                      });\n                    } else {\n                      components.forEach(function (component, index) {\n                        aux.relocateComponent(componentCenters[index], spectralResult[index], options); // relocate center to original position\n                      });\n                    }\n\n                    // packing\n                    var componentsEvaluated = new Set();\n                    if (components.length > 1) {\n                      var subgraphs = [];\n                      var hiddenEles = eles.filter(function (ele) {\n                        return ele.css('display') == 'none';\n                      });\n                      components.forEach(function (component, index) {\n                        var nodeIndexes = void 0;\n                        if (options.quality == \"draft\") {\n                          nodeIndexes = spectralResult[index].nodeIndexes;\n                        }\n                        if (component.nodes().not(hiddenEles).length > 0) {\n                          var subgraph = {};\n                          subgraph.edges = [];\n                          subgraph.nodes = [];\n                          var nodeIndex = void 0;\n                          component.nodes().not(hiddenEles).forEach(function (node) {\n                            if (options.quality == \"draft\") {\n                              if (!node.isParent()) {\n                                nodeIndex = nodeIndexes.get(node.id());\n                                subgraph.nodes.push({\n                                  x: spectralResult[index].xCoords[nodeIndex] - node.boundingbox().w / 2,\n                                  y: spectralResult[index].yCoords[nodeIndex] - node.boundingbox().h / 2,\n                                  width: node.boundingbox().w,\n                                  height: node.boundingbox().h\n                                });\n                              } else {\n                                var parentInfo = aux.calcBoundingBox(node, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                                subgraph.nodes.push({\n                                  x: parentInfo.topLeftX,\n                                  y: parentInfo.topLeftY,\n                                  width: parentInfo.width,\n                                  height: parentInfo.height\n                                });\n                              }\n                            } else {\n                              if (coseResult[index][node.id()]) {\n                                subgraph.nodes.push({\n                                  x: coseResult[index][node.id()].getLeft(),\n                                  y: coseResult[index][node.id()].getTop(),\n                                  width: coseResult[index][node.id()].getWidth(),\n                                  height: coseResult[index][node.id()].getHeight()\n                                });\n                              }\n                            }\n                          });\n                          component.edges().forEach(function (edge) {\n                            var source = edge.source();\n                            var target = edge.target();\n                            if (source.css(\"display\") != \"none\" && target.css(\"display\") != \"none\") {\n                              if (options.quality == \"draft\") {\n                                var sourceNodeIndex = nodeIndexes.get(source.id());\n                                var targetNodeIndex = nodeIndexes.get(target.id());\n                                var sourceCenter = [];\n                                var targetCenter = [];\n                                if (source.isParent()) {\n                                  var parentInfo = aux.calcBoundingBox(source, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                                  sourceCenter.push(parentInfo.topLeftX + parentInfo.width / 2);\n                                  sourceCenter.push(parentInfo.topLeftY + parentInfo.height / 2);\n                                } else {\n                                  sourceCenter.push(spectralResult[index].xCoords[sourceNodeIndex]);\n                                  sourceCenter.push(spectralResult[index].yCoords[sourceNodeIndex]);\n                                }\n                                if (target.isParent()) {\n                                  var _parentInfo = aux.calcBoundingBox(target, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                                  targetCenter.push(_parentInfo.topLeftX + _parentInfo.width / 2);\n                                  targetCenter.push(_parentInfo.topLeftY + _parentInfo.height / 2);\n                                } else {\n                                  targetCenter.push(spectralResult[index].xCoords[targetNodeIndex]);\n                                  targetCenter.push(spectralResult[index].yCoords[targetNodeIndex]);\n                                }\n                                subgraph.edges.push({\n                                  startX: sourceCenter[0],\n                                  startY: sourceCenter[1],\n                                  endX: targetCenter[0],\n                                  endY: targetCenter[1]\n                                });\n                              } else {\n                                if (coseResult[index][source.id()] && coseResult[index][target.id()]) {\n                                  subgraph.edges.push({\n                                    startX: coseResult[index][source.id()].getCenterX(),\n                                    startY: coseResult[index][source.id()].getCenterY(),\n                                    endX: coseResult[index][target.id()].getCenterX(),\n                                    endY: coseResult[index][target.id()].getCenterY()\n                                  });\n                                }\n                              }\n                            }\n                          });\n                          if (subgraph.nodes.length > 0) {\n                            subgraphs.push(subgraph);\n                            componentsEvaluated.add(index);\n                          }\n                        }\n                      });\n                      var shiftResult = layUtil.packComponents(subgraphs, options.randomize).shifts;\n                      if (options.quality == \"draft\") {\n                        spectralResult.forEach(function (result, index) {\n                          var newXCoords = result.xCoords.map(function (x) {\n                            return x + shiftResult[index].dx;\n                          });\n                          var newYCoords = result.yCoords.map(function (y) {\n                            return y + shiftResult[index].dy;\n                          });\n                          result.xCoords = newXCoords;\n                          result.yCoords = newYCoords;\n                        });\n                      } else {\n                        var _count = 0;\n                        componentsEvaluated.forEach(function (index) {\n                          Object.keys(coseResult[index]).forEach(function (item) {\n                            var nodeRectangle = coseResult[index][item];\n                            nodeRectangle.setCenter(nodeRectangle.getCenterX() + shiftResult[_count].dx, nodeRectangle.getCenterY() + shiftResult[_count].dy);\n                          });\n                          _count++;\n                        });\n                      }\n                    }\n                  }\n                }\n\n                // get each element's calculated position\n                var getPositions = function getPositions(ele, i) {\n                  if (options.quality == \"default\" || options.quality == \"proof\") {\n                    if (typeof ele === \"number\") {\n                      ele = i;\n                    }\n                    var pos = void 0;\n                    var node = void 0;\n                    var theId = ele.data('id');\n                    coseResult.forEach(function (result) {\n                      if (theId in result) {\n                        pos = {\n                          x: result[theId].getRect().getCenterX(),\n                          y: result[theId].getRect().getCenterY()\n                        };\n                        node = result[theId];\n                      }\n                    });\n                    if (options.nodeDimensionsIncludeLabels) {\n                      if (node.labelWidth) {\n                        if (node.labelPosHorizontal == \"left\") {\n                          pos.x += node.labelWidth / 2;\n                        } else if (node.labelPosHorizontal == \"right\") {\n                          pos.x -= node.labelWidth / 2;\n                        }\n                      }\n                      if (node.labelHeight) {\n                        if (node.labelPosVertical == \"top\") {\n                          pos.y += node.labelHeight / 2;\n                        } else if (node.labelPosVertical == \"bottom\") {\n                          pos.y -= node.labelHeight / 2;\n                        }\n                      }\n                    }\n                    if (pos == undefined) pos = {\n                      x: ele.position(\"x\"),\n                      y: ele.position(\"y\")\n                    };\n                    return {\n                      x: pos.x,\n                      y: pos.y\n                    };\n                  } else {\n                    var _pos = void 0;\n                    spectralResult.forEach(function (result) {\n                      var index = result.nodeIndexes.get(ele.id());\n                      if (index != undefined) {\n                        _pos = {\n                          x: result.xCoords[index],\n                          y: result.yCoords[index]\n                        };\n                      }\n                    });\n                    if (_pos == undefined) _pos = {\n                      x: ele.position(\"x\"),\n                      y: ele.position(\"y\")\n                    };\n                    return {\n                      x: _pos.x,\n                      y: _pos.y\n                    };\n                  }\n                };\n\n                // quality = \"draft\" and randomize = false are contradictive so in that case positions don't change\n                if (options.quality == \"default\" || options.quality == \"proof\" || options.randomize) {\n                  // transfer calculated positions to nodes (positions of only simple nodes are evaluated, compounds are positioned automatically)\n                  var parentsWithoutChildren = aux.calcParentsWithoutChildren(cy, eles);\n                  var _hiddenEles = eles.filter(function (ele) {\n                    return ele.css('display') == 'none';\n                  });\n                  options.eles = eles.not(_hiddenEles);\n                  eles.nodes().not(\":parent\").not(_hiddenEles).layoutPositions(layout, options, getPositions);\n                  if (parentsWithoutChildren.length > 0) {\n                    parentsWithoutChildren.forEach(function (ele) {\n                      ele.position(getPositions(ele));\n                    });\n                  }\n                } else {\n                  console.log(\"If randomize option is set to false, then quality option must be 'default' or 'proof'.\");\n                }\n              }\n            }]);\n            return Layout;\n          }();\n          module.exports = Layout;\n\n          /***/\n        },\n\n        /***/657: /***/(module, __unused_webpack_exports, __webpack_require__) => {\n          /**\n            The implementation of the spectral layout that is the first part of the fcose layout algorithm\n          */\n\n          var aux = __webpack_require__(548);\n          var Matrix = __webpack_require__(140).layoutBase.Matrix;\n          var SVD = __webpack_require__(140).layoutBase.SVD;\n\n          // main function that spectral layout is processed\n          var spectralLayout = function spectralLayout(options) {\n            var cy = options.cy;\n            var eles = options.eles;\n            var nodes = eles.nodes();\n            var parentNodes = eles.nodes(\":parent\");\n            var dummyNodes = new Map(); // map to keep dummy nodes and their neighbors\n            var nodeIndexes = new Map(); // map to keep indexes to nodes\n            var parentChildMap = new Map(); // mapping btw. compound and its representative node \n            var allNodesNeighborhood = []; // array to keep neighborhood of all nodes\n            var xCoords = [];\n            var yCoords = [];\n            var samplesColumn = []; // sampled vertices\n            var minDistancesColumn = [];\n            var C = []; // column sampling matrix\n            var PHI = []; // intersection of column and row sampling matrices \n            var INV = []; // inverse of PHI \n\n            var firstSample = void 0; // the first sampled node\n            var nodeSize = void 0;\n            var infinity = 100000000;\n            var small = 0.000000001;\n            var piTol = options.piTol;\n            var samplingType = options.samplingType; // false for random, true for greedy\n            var nodeSeparation = options.nodeSeparation;\n            var sampleSize = void 0;\n\n            /**** Spectral-preprocessing functions ****/\n\n            /**** Spectral layout functions ****/\n\n            // determine which columns to be sampled\n            var randomSampleCR = function randomSampleCR() {\n              var sample = 0;\n              var count = 0;\n              var flag = false;\n              while (count < sampleSize) {\n                sample = Math.floor(Math.random() * nodeSize);\n                flag = false;\n                for (var i = 0; i < count; i++) {\n                  if (samplesColumn[i] == sample) {\n                    flag = true;\n                    break;\n                  }\n                }\n                if (!flag) {\n                  samplesColumn[count] = sample;\n                  count++;\n                } else {\n                  continue;\n                }\n              }\n            };\n\n            // takes the index of the node(pivot) to initiate BFS as a parameter\n            var BFS = function BFS(pivot, index, samplingMethod) {\n              var path = []; // the front of the path\n              var front = 0; // the back of the path\n              var back = 0;\n              var current = 0;\n              var temp = void 0;\n              var distance = [];\n              var max_dist = 0; // the furthest node to be returned\n              var max_ind = 1;\n              for (var i = 0; i < nodeSize; i++) {\n                distance[i] = infinity;\n              }\n              path[back] = pivot;\n              distance[pivot] = 0;\n              while (back >= front) {\n                current = path[front++];\n                var neighbors = allNodesNeighborhood[current];\n                for (var _i = 0; _i < neighbors.length; _i++) {\n                  temp = nodeIndexes.get(neighbors[_i]);\n                  if (distance[temp] == infinity) {\n                    distance[temp] = distance[current] + 1;\n                    path[++back] = temp;\n                  }\n                }\n                C[current][index] = distance[current] * nodeSeparation;\n              }\n              if (samplingMethod) {\n                for (var _i2 = 0; _i2 < nodeSize; _i2++) {\n                  if (C[_i2][index] < minDistancesColumn[_i2]) minDistancesColumn[_i2] = C[_i2][index];\n                }\n                for (var _i3 = 0; _i3 < nodeSize; _i3++) {\n                  if (minDistancesColumn[_i3] > max_dist) {\n                    max_dist = minDistancesColumn[_i3];\n                    max_ind = _i3;\n                  }\n                }\n              }\n              return max_ind;\n            };\n\n            // apply BFS to all nodes or selected samples\n            var allBFS = function allBFS(samplingMethod) {\n              var sample = void 0;\n              if (!samplingMethod) {\n                randomSampleCR();\n\n                // call BFS\n                for (var i = 0; i < sampleSize; i++) {\n                  BFS(samplesColumn[i], i, samplingMethod, false);\n                }\n              } else {\n                sample = Math.floor(Math.random() * nodeSize);\n                firstSample = sample;\n                for (var _i4 = 0; _i4 < nodeSize; _i4++) {\n                  minDistancesColumn[_i4] = infinity;\n                }\n                for (var _i5 = 0; _i5 < sampleSize; _i5++) {\n                  samplesColumn[_i5] = sample;\n                  sample = BFS(sample, _i5, samplingMethod);\n                }\n              }\n\n              // form the squared distances for C\n              for (var _i6 = 0; _i6 < nodeSize; _i6++) {\n                for (var j = 0; j < sampleSize; j++) {\n                  C[_i6][j] *= C[_i6][j];\n                }\n              }\n\n              // form PHI\n              for (var _i7 = 0; _i7 < sampleSize; _i7++) {\n                PHI[_i7] = [];\n              }\n              for (var _i8 = 0; _i8 < sampleSize; _i8++) {\n                for (var _j = 0; _j < sampleSize; _j++) {\n                  PHI[_i8][_j] = C[samplesColumn[_j]][_i8];\n                }\n              }\n            };\n\n            // perform the SVD algorithm and apply a regularization step\n            var sample = function sample() {\n              var SVDResult = SVD.svd(PHI);\n              var a_q = SVDResult.S;\n              var a_u = SVDResult.U;\n              var a_v = SVDResult.V;\n              var max_s = a_q[0] * a_q[0] * a_q[0];\n              var a_Sig = [];\n\n              //  regularization\n              for (var i = 0; i < sampleSize; i++) {\n                a_Sig[i] = [];\n                for (var j = 0; j < sampleSize; j++) {\n                  a_Sig[i][j] = 0;\n                  if (i == j) {\n                    a_Sig[i][j] = a_q[i] / (a_q[i] * a_q[i] + max_s / (a_q[i] * a_q[i]));\n                  }\n                }\n              }\n              INV = Matrix.multMat(Matrix.multMat(a_v, a_Sig), Matrix.transpose(a_u));\n            };\n\n            // calculate final coordinates \n            var powerIteration = function powerIteration() {\n              // two largest eigenvalues\n              var theta1 = void 0;\n              var theta2 = void 0;\n\n              // initial guesses for eigenvectors\n              var Y1 = [];\n              var Y2 = [];\n              var V1 = [];\n              var V2 = [];\n              for (var i = 0; i < nodeSize; i++) {\n                Y1[i] = Math.random();\n                Y2[i] = Math.random();\n              }\n              Y1 = Matrix.normalize(Y1);\n              Y2 = Matrix.normalize(Y2);\n              var count = 0;\n              // to keep track of the improvement ratio in power iteration\n              var current = small;\n              var previous = small;\n              var temp = void 0;\n              while (true) {\n                count++;\n                for (var _i9 = 0; _i9 < nodeSize; _i9++) {\n                  V1[_i9] = Y1[_i9];\n                }\n                Y1 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V1), C, INV));\n                theta1 = Matrix.dotProduct(V1, Y1);\n                Y1 = Matrix.normalize(Y1);\n                current = Matrix.dotProduct(V1, Y1);\n                temp = Math.abs(current / previous);\n                if (temp <= 1 + piTol && temp >= 1) {\n                  break;\n                }\n                previous = current;\n              }\n              for (var _i10 = 0; _i10 < nodeSize; _i10++) {\n                V1[_i10] = Y1[_i10];\n              }\n              count = 0;\n              previous = small;\n              while (true) {\n                count++;\n                for (var _i11 = 0; _i11 < nodeSize; _i11++) {\n                  V2[_i11] = Y2[_i11];\n                }\n                V2 = Matrix.minusOp(V2, Matrix.multCons(V1, Matrix.dotProduct(V1, V2)));\n                Y2 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V2), C, INV));\n                theta2 = Matrix.dotProduct(V2, Y2);\n                Y2 = Matrix.normalize(Y2);\n                current = Matrix.dotProduct(V2, Y2);\n                temp = Math.abs(current / previous);\n                if (temp <= 1 + piTol && temp >= 1) {\n                  break;\n                }\n                previous = current;\n              }\n              for (var _i12 = 0; _i12 < nodeSize; _i12++) {\n                V2[_i12] = Y2[_i12];\n              }\n\n              // theta1 now contains dominant eigenvalue\n              // theta2 now contains the second-largest eigenvalue\n              // V1 now contains theta1's eigenvector\n              // V2 now contains theta2's eigenvector\n\n              //populate the two vectors\n              xCoords = Matrix.multCons(V1, Math.sqrt(Math.abs(theta1)));\n              yCoords = Matrix.multCons(V2, Math.sqrt(Math.abs(theta2)));\n            };\n\n            /**** Preparation for spectral layout (Preprocessing) ****/\n\n            // connect disconnected components (first top level, then inside of each compound node)\n            aux.connectComponents(cy, eles, aux.getTopMostNodes(nodes), dummyNodes);\n            parentNodes.forEach(function (ele) {\n              aux.connectComponents(cy, eles, aux.getTopMostNodes(ele.descendants().intersection(eles)), dummyNodes);\n            });\n\n            // assign indexes to nodes (first real, then dummy nodes)\n            var index = 0;\n            for (var i = 0; i < nodes.length; i++) {\n              if (!nodes[i].isParent()) {\n                nodeIndexes.set(nodes[i].id(), index++);\n              }\n            }\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n            try {\n              for (var _iterator = dummyNodes.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var key = _step.value;\n                nodeIndexes.set(key, index++);\n              }\n\n              // instantiate the neighborhood matrix\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                  _iterator.return();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n            for (var _i13 = 0; _i13 < nodeIndexes.size; _i13++) {\n              allNodesNeighborhood[_i13] = [];\n            }\n\n            // form a parent-child map to keep representative node of each compound node  \n            parentNodes.forEach(function (ele) {\n              var children = ele.children().intersection(eles);\n\n              //      let random = 0;\n              while (children.nodes(\":childless\").length == 0) {\n                //        random = Math.floor(Math.random() * children.nodes().length); // if all children are compound then proceed randomly\n                children = children.nodes()[0].children().intersection(eles);\n              }\n              //  select the representative node - we can apply different methods here\n              //      random = Math.floor(Math.random() * children.nodes(\":childless\").length);\n              var index = 0;\n              var min = children.nodes(\":childless\")[0].connectedEdges().length;\n              children.nodes(\":childless\").forEach(function (ele2, i) {\n                if (ele2.connectedEdges().length < min) {\n                  min = ele2.connectedEdges().length;\n                  index = i;\n                }\n              });\n              parentChildMap.set(ele.id(), children.nodes(\":childless\")[index].id());\n            });\n\n            // add neighborhood relations (first real, then dummy nodes)\n            nodes.forEach(function (ele) {\n              var eleIndex = void 0;\n              if (ele.isParent()) eleIndex = nodeIndexes.get(parentChildMap.get(ele.id()));else eleIndex = nodeIndexes.get(ele.id());\n              ele.neighborhood().nodes().forEach(function (node) {\n                if (eles.intersection(ele.edgesWith(node)).length > 0) {\n                  if (node.isParent()) allNodesNeighborhood[eleIndex].push(parentChildMap.get(node.id()));else allNodesNeighborhood[eleIndex].push(node.id());\n                }\n              });\n            });\n            var _loop = function _loop(_key) {\n              var eleIndex = nodeIndexes.get(_key);\n              var disconnectedId = void 0;\n              dummyNodes.get(_key).forEach(function (id) {\n                if (cy.getElementById(id).isParent()) disconnectedId = parentChildMap.get(id);else disconnectedId = id;\n                allNodesNeighborhood[eleIndex].push(disconnectedId);\n                allNodesNeighborhood[nodeIndexes.get(disconnectedId)].push(_key);\n              });\n            };\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n            try {\n              for (var _iterator2 = dummyNodes.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var _key = _step2.value;\n                _loop(_key);\n              }\n\n              // nodeSize now only considers the size of transformed graph\n            } catch (err) {\n              _didIteratorError2 = true;\n              _iteratorError2 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                  _iterator2.return();\n                }\n              } finally {\n                if (_didIteratorError2) {\n                  throw _iteratorError2;\n                }\n              }\n            }\n            nodeSize = nodeIndexes.size;\n            var spectralResult = void 0;\n\n            // If number of nodes in transformed graph is 1 or 2, either SVD or powerIteration causes problem\n            // So skip spectral and layout the graph with cose\n            if (nodeSize > 2) {\n              // if # of nodes in transformed graph is smaller than sample size,\n              // then use # of nodes as sample size\n              sampleSize = nodeSize < options.sampleSize ? nodeSize : options.sampleSize;\n\n              // instantiates the partial matrices that will be used in spectral layout\n              for (var _i14 = 0; _i14 < nodeSize; _i14++) {\n                C[_i14] = [];\n              }\n              for (var _i15 = 0; _i15 < sampleSize; _i15++) {\n                INV[_i15] = [];\n              }\n\n              /**** Apply spectral layout ****/\n\n              if (options.quality == \"draft\" || options.step == \"all\") {\n                allBFS(samplingType);\n                sample();\n                powerIteration();\n                spectralResult = {\n                  nodeIndexes: nodeIndexes,\n                  xCoords: xCoords,\n                  yCoords: yCoords\n                };\n              } else {\n                nodeIndexes.forEach(function (value, key) {\n                  xCoords.push(cy.getElementById(key).position(\"x\"));\n                  yCoords.push(cy.getElementById(key).position(\"y\"));\n                });\n                spectralResult = {\n                  nodeIndexes: nodeIndexes,\n                  xCoords: xCoords,\n                  yCoords: yCoords\n                };\n              }\n              return spectralResult;\n            } else {\n              var iterator = nodeIndexes.keys();\n              var firstNode = cy.getElementById(iterator.next().value);\n              var firstNodePos = firstNode.position();\n              var firstNodeWidth = firstNode.outerWidth();\n              xCoords.push(firstNodePos.x);\n              yCoords.push(firstNodePos.y);\n              if (nodeSize == 2) {\n                var secondNode = cy.getElementById(iterator.next().value);\n                var secondNodeWidth = secondNode.outerWidth();\n                xCoords.push(firstNodePos.x + firstNodeWidth / 2 + secondNodeWidth / 2 + options.idealEdgeLength);\n                yCoords.push(firstNodePos.y);\n              }\n              spectralResult = {\n                nodeIndexes: nodeIndexes,\n                xCoords: xCoords,\n                yCoords: yCoords\n              };\n              return spectralResult;\n            }\n          };\n          module.exports = {\n            spectralLayout: spectralLayout\n          };\n\n          /***/\n        },\n\n        /***/579: /***/(module, __unused_webpack_exports, __webpack_require__) => {\n          var impl = __webpack_require__(212);\n\n          // registers the extension on a cytoscape lib ref\n          var register = function register(cytoscape) {\n            if (!cytoscape) {\n              return;\n            } // can't register if cytoscape unspecified\n\n            cytoscape('layout', 'fcose', impl); // register with cytoscape.js\n          };\n\n          if (typeof cytoscape !== 'undefined') {\n            // expose to global cytoscape (i.e. window.cytoscape)\n            register(cytoscape);\n          }\n          module.exports = register;\n\n          /***/\n        },\n\n        /***/140: /***/module => {\n          module.exports = __WEBPACK_EXTERNAL_MODULE__140__;\n\n          /***/\n        }\n\n        /******/\n      };\n      /************************************************************************/\n      /******/ // The module cache\n      /******/\n      var __webpack_module_cache__ = {};\n      /******/\n      /******/ // The require function\n      /******/\n      function __webpack_require__(moduleId) {\n        /******/ // Check if module is in cache\n        /******/var cachedModule = __webpack_module_cache__[moduleId];\n        /******/\n        if (cachedModule !== undefined) {\n          /******/return cachedModule.exports;\n          /******/\n        }\n        /******/ // Create a new module (and put it into the cache)\n        /******/\n        var module = __webpack_module_cache__[moduleId] = {\n          /******/ // no module.id needed\n          /******/ // no module.loaded needed\n          /******/exports: {}\n          /******/\n        };\n        /******/\n        /******/ // Execute the module function\n        /******/\n        __webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n        /******/\n        /******/ // Return the exports of the module\n        /******/\n        return module.exports;\n        /******/\n      }\n      /******/\n      /************************************************************************/\n      /******/\n      /******/ // startup\n      /******/ // Load entry module and return exports\n      /******/ // This entry module is referenced by other modules so it can't be inlined\n      /******/\n      var __webpack_exports__ = __webpack_require__(579);\n      /******/\n      /******/\n      return __webpack_exports__;\n      /******/\n    })()\n  );\n});","map":{"version":3,"names":["webpackUniversalModuleDefinition","root","factory","exports","module","require","define","amd","__WEBPACK_EXTERNAL_MODULE__140__","__webpack_modules__","Object","assign","bind","tgt","_len","arguments","length","srcs","Array","_key","forEach","src","keys","k","__unused_webpack_exports","__webpack_require__","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","err","isArray","TypeError","LinkedList","layoutBase","auxiliary","getTopMostNodes","nodes","nodesMap","id","roots","filter","ele","parent","connectComponents","cy","eles","topMostNodes","dummyNodes","queue","visited","Set","visitedTopMostNodes","currentNeighbor","minDegreeNode","minDegree","isConnected","count","nodesConnectedToDummy","components","_loop","cmpt","collection","currentNode","childrenOfCurrentNode","merge","descendants","intersection","node","add","_loop2","shift","neighborNodes","neighborhood","edgesWith","neighborNode","union","ancestors","has","childrenOfNeighbor","connectedEdges","e","source","target","temp","difference","set","size","relocateComponent","originalCenter","componentResult","options","fixedNodeConstraint","minXCoord","Number","POSITIVE_INFINITY","maxXCoord","NEGATIVE_INFINITY","minYCoord","maxYCoord","quality","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","nodeIndexes","_step","_ref","_ref2","key","cyNode","getElementById","nodeBB","boundingBox","leftX","xCoords","w","rightX","topY","yCoords","h","bottomY","return","diffOnX","x","diffOnY","y","map","item","getRect","width","height","_diffOnX","_diffOnY","setCenter","getCenterX","getCenterY","calcBoundingBox","parentNode","left","MAX_SAFE_INTEGER","right","MIN_SAFE_INTEGER","top","bottom","nodeLeft","nodeRight","nodeTop","nodeBottom","not","s","get","topLeftX","topLeftY","calcParentsWithoutChildren","parentsWithoutChildren","check","children","child","css","aux","CoSELayout","CoSENode","PointD","DimensionD","LayoutConstants","FDLayoutConstants","CoSEConstants","coseLayout","spectralResult","edges","idToLNode","randomize","isFn","fn","optFn","opt","processChildrenList","layout","theChild","children_of_children","theNode","dimensions","layoutDimensions","nodeDimensionsIncludeLabels","outerWidth","outerHeight","isParent","graphManager","parseFloat","parentInfo","position","data","nodeRepulsion","paddingLeft","parseInt","paddingTop","paddingRight","paddingBottom","labelWidth","includeLabels","includeNodes","includeOverlays","labelHeight","labelPosVertical","labelPosHorizontal","isNaN","rect","theNewGraph","getGraphManager","newGraph","processEdges","gm","idealLengthTotal","edgeCount","edge","sourceNode","targetNode","getEdgesBetween","e1","newEdge","idealLength","idealEdgeLength","edgeElasticity","DEFAULT_EDGE_LENGTH","MIN_REPULSION_DIST","DEFAULT_RADIAL_SEPARATION","processConstraints","constraints","alignmentConstraint","relativePlacementConstraint","nestingFactor","PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR","gravity","DEFAULT_GRAVITY_STRENGTH","numIter","MAX_ITERATIONS","gravityRange","DEFAULT_GRAVITY_RANGE_FACTOR","gravityCompound","DEFAULT_COMPOUND_GRAVITY_STRENGTH","gravityRangeCompound","DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR","initialEnergyOnIncremental","DEFAULT_COOLING_FACTOR_INCREMENTAL","tilingCompareBy","TILING_COMPARE_BY","QUALITY","NODE_DIMENSIONS_INCLUDE_LABELS","DEFAULT_INCREMENTAL","ANIMATE","animate","TILE","tile","TILING_PADDING_VERTICAL","tilingPaddingVertical","call","TILING_PADDING_HORIZONTAL","tilingPaddingHorizontal","PURE_INCREMENTAL","DEFAULT_UNIFORM_LEAF_NODE_SIZES","uniformNodeDimensions","step","TRANSFORM_ON_CONSTRAINT_HANDLING","ENFORCE_CONSTRAINTS","APPLY_LAYOUT","TREE_REDUCTION_ON_INCREMENTAL","newGraphManager","addRoot","runLayout","_createClass","defineProperties","props","descriptor","enumerable","configurable","writable","defineProperty","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","_require","spectralLayout","_require2","defaults","freeze","animationDuration","animationEasing","fit","padding","packComponents","samplingType","sampleSize","nodeSeparation","piTol","ready","stop","Layout","run","coseResult","componentCenters","vertical","horizontal","constraintExist","layUtil","packingEnabled","layoutUtilities","x1","y1","result","component","toBeTiledNodes","Map","_xCoords","_yCoords","tempSpectralResult","indexesToBeDeleted","index","_boundingBox","splice","componentsEvaluated","subgraphs","hiddenEles","subgraph","nodeIndex","boundingbox","getLeft","getTop","getWidth","getHeight","sourceNodeIndex","targetNodeIndex","sourceCenter","targetCenter","_parentInfo","startX","startY","endX","endY","shiftResult","shifts","newXCoords","dx","newYCoords","dy","_count","nodeRectangle","getPositions","pos","theId","_pos","_hiddenEles","layoutPositions","console","log","Matrix","SVD","parentNodes","parentChildMap","allNodesNeighborhood","samplesColumn","minDistancesColumn","C","PHI","INV","firstSample","nodeSize","infinity","small","randomSampleCR","sample","flag","Math","floor","random","BFS","pivot","samplingMethod","path","front","back","current","distance","max_dist","max_ind","neighbors","_i2","_i3","allBFS","_i4","_i5","_i6","j","_i7","_i8","_j","SVDResult","svd","a_q","S","a_u","U","a_v","V","max_s","a_Sig","multMat","transpose","powerIteration","theta1","theta2","Y1","Y2","V1","V2","normalize","previous","_i9","multGamma","multL","dotProduct","abs","_i10","_i11","minusOp","multCons","_i12","sqrt","_i13","min","ele2","eleIndex","disconnectedId","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","_i14","_i15","firstNode","firstNodePos","firstNodeWidth","secondNode","secondNodeWidth","impl","register","cytoscape","__webpack_module_cache__","moduleId","cachedModule","__webpack_exports__"],"sources":["/home/mdreger/Documents/MatGraphAI/MatGraphAI/frontend/node_modules/cytoscape-fcose/cytoscape-fcose.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"cose-base\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"cose-base\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cytoscapeFcose\"] = factory(require(\"cose-base\"));\n\telse\n\t\troot[\"cytoscapeFcose\"] = factory(root[\"coseBase\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__140__) {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 658:\n/***/ ((module) => {\n\n\n\n// Simple, internal Object.assign() polyfill for options objects etc.\n\nmodule.exports = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {\n  for (var _len = arguments.length, srcs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    srcs[_key - 1] = arguments[_key];\n  }\n\n  srcs.forEach(function (src) {\n    Object.keys(src).forEach(function (k) {\n      return tgt[k] = src[k];\n    });\n  });\n\n  return tgt;\n};\n\n/***/ }),\n\n/***/ 548:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n/*\n * Auxiliary functions\n */\n\nvar LinkedList = __webpack_require__(140).layoutBase.LinkedList;\n\nvar auxiliary = {};\n\n// get the top most nodes\nauxiliary.getTopMostNodes = function (nodes) {\n  var nodesMap = {};\n  for (var i = 0; i < nodes.length; i++) {\n    nodesMap[nodes[i].id()] = true;\n  }\n  var roots = nodes.filter(function (ele, i) {\n    if (typeof ele === \"number\") {\n      ele = i;\n    }\n    var parent = ele.parent()[0];\n    while (parent != null) {\n      if (nodesMap[parent.id()]) {\n        return false;\n      }\n      parent = parent.parent()[0];\n    }\n    return true;\n  });\n\n  return roots;\n};\n\n// find disconnected components and create dummy nodes that connect them\nauxiliary.connectComponents = function (cy, eles, topMostNodes, dummyNodes) {\n  var queue = new LinkedList();\n  var visited = new Set();\n  var visitedTopMostNodes = [];\n  var currentNeighbor = void 0;\n  var minDegreeNode = void 0;\n  var minDegree = void 0;\n\n  var isConnected = false;\n  var count = 1;\n  var nodesConnectedToDummy = [];\n  var components = [];\n\n  var _loop = function _loop() {\n    var cmpt = cy.collection();\n    components.push(cmpt);\n\n    var currentNode = topMostNodes[0];\n    var childrenOfCurrentNode = cy.collection();\n    childrenOfCurrentNode.merge(currentNode).merge(currentNode.descendants().intersection(eles));\n    visitedTopMostNodes.push(currentNode);\n\n    childrenOfCurrentNode.forEach(function (node) {\n      queue.push(node);\n      visited.add(node);\n      cmpt.merge(node);\n    });\n\n    var _loop2 = function _loop2() {\n      currentNode = queue.shift();\n\n      // Traverse all neighbors of this node\n      var neighborNodes = cy.collection();\n      currentNode.neighborhood().nodes().forEach(function (node) {\n        if (eles.intersection(currentNode.edgesWith(node)).length > 0) {\n          neighborNodes.merge(node);\n        }\n      });\n\n      for (var i = 0; i < neighborNodes.length; i++) {\n        var neighborNode = neighborNodes[i];\n        currentNeighbor = topMostNodes.intersection(neighborNode.union(neighborNode.ancestors()));\n        if (currentNeighbor != null && !visited.has(currentNeighbor[0])) {\n          var childrenOfNeighbor = currentNeighbor.union(currentNeighbor.descendants());\n\n          childrenOfNeighbor.forEach(function (node) {\n            queue.push(node);\n            visited.add(node);\n            cmpt.merge(node);\n            if (topMostNodes.has(node)) {\n              visitedTopMostNodes.push(node);\n            }\n          });\n        }\n      }\n    };\n\n    while (queue.length != 0) {\n      _loop2();\n    }\n\n    cmpt.forEach(function (node) {\n      eles.intersection(node.connectedEdges()).forEach(function (e) {\n        // connectedEdges() usually cached\n        if (cmpt.has(e.source()) && cmpt.has(e.target())) {\n          // has() is cheap\n          cmpt.merge(e);\n        }\n      });\n    });\n\n    if (visitedTopMostNodes.length == topMostNodes.length) {\n      isConnected = true;\n    }\n\n    if (!isConnected || isConnected && count > 1) {\n      minDegreeNode = visitedTopMostNodes[0];\n      minDegree = minDegreeNode.connectedEdges().length;\n      visitedTopMostNodes.forEach(function (node) {\n        if (node.connectedEdges().length < minDegree) {\n          minDegree = node.connectedEdges().length;\n          minDegreeNode = node;\n        }\n      });\n      nodesConnectedToDummy.push(minDegreeNode.id());\n      // TO DO: Check efficiency of this part\n      var temp = cy.collection();\n      temp.merge(visitedTopMostNodes[0]);\n      visitedTopMostNodes.forEach(function (node) {\n        temp.merge(node);\n      });\n      visitedTopMostNodes = [];\n      topMostNodes = topMostNodes.difference(temp);\n      count++;\n    }\n  };\n\n  do {\n    _loop();\n  } while (!isConnected);\n\n  if (dummyNodes) {\n    if (nodesConnectedToDummy.length > 0) {\n      dummyNodes.set('dummy' + (dummyNodes.size + 1), nodesConnectedToDummy);\n    }\n  }\n  return components;\n};\n\n// relocates componentResult to originalCenter if there is no fixedNodeConstraint\nauxiliary.relocateComponent = function (originalCenter, componentResult, options) {\n  if (!options.fixedNodeConstraint) {\n    var minXCoord = Number.POSITIVE_INFINITY;\n    var maxXCoord = Number.NEGATIVE_INFINITY;\n    var minYCoord = Number.POSITIVE_INFINITY;\n    var maxYCoord = Number.NEGATIVE_INFINITY;\n    if (options.quality == \"draft\") {\n      // calculate current bounding box\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = componentResult.nodeIndexes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _ref = _step.value;\n\n          var _ref2 = _slicedToArray(_ref, 2);\n\n          var key = _ref2[0];\n          var value = _ref2[1];\n\n          var cyNode = options.cy.getElementById(key);\n          if (cyNode) {\n            var nodeBB = cyNode.boundingBox();\n            var leftX = componentResult.xCoords[value] - nodeBB.w / 2;\n            var rightX = componentResult.xCoords[value] + nodeBB.w / 2;\n            var topY = componentResult.yCoords[value] - nodeBB.h / 2;\n            var bottomY = componentResult.yCoords[value] + nodeBB.h / 2;\n\n            if (leftX < minXCoord) minXCoord = leftX;\n            if (rightX > maxXCoord) maxXCoord = rightX;\n            if (topY < minYCoord) minYCoord = topY;\n            if (bottomY > maxYCoord) maxYCoord = bottomY;\n          }\n        }\n        // find difference between current and original center\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var diffOnX = originalCenter.x - (maxXCoord + minXCoord) / 2;\n      var diffOnY = originalCenter.y - (maxYCoord + minYCoord) / 2;\n      // move component to original center\n      componentResult.xCoords = componentResult.xCoords.map(function (x) {\n        return x + diffOnX;\n      });\n      componentResult.yCoords = componentResult.yCoords.map(function (y) {\n        return y + diffOnY;\n      });\n    } else {\n      // calculate current bounding box\n      Object.keys(componentResult).forEach(function (item) {\n        var node = componentResult[item];\n        var leftX = node.getRect().x;\n        var rightX = node.getRect().x + node.getRect().width;\n        var topY = node.getRect().y;\n        var bottomY = node.getRect().y + node.getRect().height;\n\n        if (leftX < minXCoord) minXCoord = leftX;\n        if (rightX > maxXCoord) maxXCoord = rightX;\n        if (topY < minYCoord) minYCoord = topY;\n        if (bottomY > maxYCoord) maxYCoord = bottomY;\n      });\n      // find difference between current and original center\n      var _diffOnX = originalCenter.x - (maxXCoord + minXCoord) / 2;\n      var _diffOnY = originalCenter.y - (maxYCoord + minYCoord) / 2;\n      // move component to original center\n      Object.keys(componentResult).forEach(function (item) {\n        var node = componentResult[item];\n        node.setCenter(node.getCenterX() + _diffOnX, node.getCenterY() + _diffOnY);\n      });\n    }\n  }\n};\n\nauxiliary.calcBoundingBox = function (parentNode, xCoords, yCoords, nodeIndexes) {\n  // calculate bounds\n  var left = Number.MAX_SAFE_INTEGER;\n  var right = Number.MIN_SAFE_INTEGER;\n  var top = Number.MAX_SAFE_INTEGER;\n  var bottom = Number.MIN_SAFE_INTEGER;\n  var nodeLeft = void 0;\n  var nodeRight = void 0;\n  var nodeTop = void 0;\n  var nodeBottom = void 0;\n\n  var nodes = parentNode.descendants().not(\":parent\");\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    var node = nodes[i];\n\n    nodeLeft = xCoords[nodeIndexes.get(node.id())] - node.width() / 2;\n    nodeRight = xCoords[nodeIndexes.get(node.id())] + node.width() / 2;\n    nodeTop = yCoords[nodeIndexes.get(node.id())] - node.height() / 2;\n    nodeBottom = yCoords[nodeIndexes.get(node.id())] + node.height() / 2;\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingBox = {};\n  boundingBox.topLeftX = left;\n  boundingBox.topLeftY = top;\n  boundingBox.width = right - left;\n  boundingBox.height = bottom - top;\n  return boundingBox;\n};\n\n// This function finds and returns parent nodes whose all children are hidden\nauxiliary.calcParentsWithoutChildren = function (cy, eles) {\n  var parentsWithoutChildren = cy.collection();\n  eles.nodes(':parent').forEach(function (parent) {\n    var check = false;\n    parent.children().forEach(function (child) {\n      if (child.css('display') != 'none') {\n        check = true;\n      }\n    });\n    if (!check) {\n      parentsWithoutChildren.merge(parent);\n    }\n  });\n\n  return parentsWithoutChildren;\n};\n\nmodule.exports = auxiliary;\n\n/***/ }),\n\n/***/ 816:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\n/**\n  The implementation of the postprocessing part that applies CoSE layout over the spectral layout\n*/\n\nvar aux = __webpack_require__(548);\nvar CoSELayout = __webpack_require__(140).CoSELayout;\nvar CoSENode = __webpack_require__(140).CoSENode;\nvar PointD = __webpack_require__(140).layoutBase.PointD;\nvar DimensionD = __webpack_require__(140).layoutBase.DimensionD;\nvar LayoutConstants = __webpack_require__(140).layoutBase.LayoutConstants;\nvar FDLayoutConstants = __webpack_require__(140).layoutBase.FDLayoutConstants;\nvar CoSEConstants = __webpack_require__(140).CoSEConstants;\n\n// main function that cose layout is processed\nvar coseLayout = function coseLayout(options, spectralResult) {\n\n  var cy = options.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes();\n  var edges = eles.edges();\n\n  var nodeIndexes = void 0;\n  var xCoords = void 0;\n  var yCoords = void 0;\n  var idToLNode = {};\n\n  if (options.randomize) {\n    nodeIndexes = spectralResult[\"nodeIndexes\"];\n    xCoords = spectralResult[\"xCoords\"];\n    yCoords = spectralResult[\"yCoords\"];\n  }\n\n  var isFn = function isFn(fn) {\n    return typeof fn === 'function';\n  };\n\n  var optFn = function optFn(opt, ele) {\n    if (isFn(opt)) {\n      return opt(ele);\n    } else {\n      return opt;\n    }\n  };\n\n  /**** Postprocessing functions ****/\n\n  var parentsWithoutChildren = aux.calcParentsWithoutChildren(cy, eles);\n\n  // transfer cytoscape nodes to cose nodes\n  var processChildrenList = function processChildrenList(parent, children, layout, options) {\n    var size = children.length;\n    for (var i = 0; i < size; i++) {\n      var theChild = children[i];\n      var children_of_children = null;\n      if (theChild.intersection(parentsWithoutChildren).length == 0) {\n        children_of_children = theChild.children();\n      }\n      var theNode = void 0;\n\n      var dimensions = theChild.layoutDimensions({\n        nodeDimensionsIncludeLabels: options.nodeDimensionsIncludeLabels\n      });\n\n      if (theChild.outerWidth() != null && theChild.outerHeight() != null) {\n        if (options.randomize) {\n          if (!theChild.isParent()) {\n            theNode = parent.add(new CoSENode(layout.graphManager, new PointD(xCoords[nodeIndexes.get(theChild.id())] - dimensions.w / 2, yCoords[nodeIndexes.get(theChild.id())] - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n          } else {\n            var parentInfo = aux.calcBoundingBox(theChild, xCoords, yCoords, nodeIndexes);\n            if (theChild.intersection(parentsWithoutChildren).length == 0) {\n              theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parentInfo.width, parentInfo.height)));\n            } else {\n              // for the parentsWithoutChildren\n              theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n            }\n          }\n        } else {\n          theNode = parent.add(new CoSENode(layout.graphManager, new PointD(theChild.position('x') - dimensions.w / 2, theChild.position('y') - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n        }\n      } else {\n        theNode = parent.add(new CoSENode(this.graphManager));\n      }\n      // Attach id to the layout node and repulsion value\n      theNode.id = theChild.data(\"id\");\n      theNode.nodeRepulsion = optFn(options.nodeRepulsion, theChild);\n      // Attach the paddings of cy node to layout node\n      theNode.paddingLeft = parseInt(theChild.css('padding'));\n      theNode.paddingTop = parseInt(theChild.css('padding'));\n      theNode.paddingRight = parseInt(theChild.css('padding'));\n      theNode.paddingBottom = parseInt(theChild.css('padding'));\n\n      //Attach the label properties to both compound and simple nodes if labels will be included in node dimensions\n      //These properties will be used while updating bounds of compounds during iterations or tiling\n      //and will be used for simple nodes while transferring final positions to cytoscape\n      if (options.nodeDimensionsIncludeLabels) {\n        theNode.labelWidth = theChild.boundingBox({ includeLabels: true, includeNodes: false, includeOverlays: false }).w;\n        theNode.labelHeight = theChild.boundingBox({ includeLabels: true, includeNodes: false, includeOverlays: false }).h;\n        theNode.labelPosVertical = theChild.css(\"text-valign\");\n        theNode.labelPosHorizontal = theChild.css(\"text-halign\");\n      }\n\n      // Map the layout node\n      idToLNode[theChild.data(\"id\")] = theNode;\n\n      if (isNaN(theNode.rect.x)) {\n        theNode.rect.x = 0;\n      }\n\n      if (isNaN(theNode.rect.y)) {\n        theNode.rect.y = 0;\n      }\n\n      if (children_of_children != null && children_of_children.length > 0) {\n        var theNewGraph = void 0;\n        theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);\n        processChildrenList(theNewGraph, children_of_children, layout, options);\n      }\n    }\n  };\n\n  // transfer cytoscape edges to cose edges\n  var processEdges = function processEdges(layout, gm, edges) {\n    var idealLengthTotal = 0;\n    var edgeCount = 0;\n    for (var i = 0; i < edges.length; i++) {\n      var edge = edges[i];\n      var sourceNode = idToLNode[edge.data(\"source\")];\n      var targetNode = idToLNode[edge.data(\"target\")];\n      if (sourceNode && targetNode && sourceNode !== targetNode && sourceNode.getEdgesBetween(targetNode).length == 0) {\n        var e1 = gm.add(layout.newEdge(), sourceNode, targetNode);\n        e1.id = edge.id();\n        e1.idealLength = optFn(options.idealEdgeLength, edge);\n        e1.edgeElasticity = optFn(options.edgeElasticity, edge);\n        idealLengthTotal += e1.idealLength;\n        edgeCount++;\n      }\n    }\n    // we need to update the ideal edge length constant with the avg. ideal length value after processing edges\n    // in case there is no edge, use other options\n    if (options.idealEdgeLength != null) {\n      if (edgeCount > 0) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = idealLengthTotal / edgeCount;else if (!isFn(options.idealEdgeLength)) // in case there is no edge, but option gives a value to use\n        CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;else // in case there is no edge and we cannot get a value from option (because it's a function)\n        CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\n      // we need to update these constant values based on the ideal edge length constant\n      CoSEConstants.MIN_REPULSION_DIST = FDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\n      CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n    }\n  };\n\n  // transfer cytoscape constraints to cose layout\n  var processConstraints = function processConstraints(layout, options) {\n    // get nodes to be fixed\n    if (options.fixedNodeConstraint) {\n      layout.constraints[\"fixedNodeConstraint\"] = options.fixedNodeConstraint;\n    }\n    // get nodes to be aligned\n    if (options.alignmentConstraint) {\n      layout.constraints[\"alignmentConstraint\"] = options.alignmentConstraint;\n    }\n    // get nodes to be relatively placed\n    if (options.relativePlacementConstraint) {\n      layout.constraints[\"relativePlacementConstraint\"] = options.relativePlacementConstraint;\n    }\n  };\n\n  /**** Apply postprocessing ****/\n  if (options.nestingFactor != null) CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;\n  if (options.gravity != null) CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;\n  if (options.numIter != null) CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;\n  if (options.gravityRange != null) CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;\n  if (options.gravityCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;\n  if (options.gravityRangeCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;\n  if (options.initialEnergyOnIncremental != null) CoSEConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = options.initialEnergyOnIncremental;\n\n  if (options.tilingCompareBy != null) CoSEConstants.TILING_COMPARE_BY = options.tilingCompareBy;\n\n  if (options.quality == 'proof') LayoutConstants.QUALITY = 2;else LayoutConstants.QUALITY = 0;\n\n  CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS = FDLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = options.nodeDimensionsIncludeLabels;\n  CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = !options.randomize;\n  CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = LayoutConstants.ANIMATE = options.animate;\n  CoSEConstants.TILE = options.tile;\n  CoSEConstants.TILING_PADDING_VERTICAL = typeof options.tilingPaddingVertical === 'function' ? options.tilingPaddingVertical.call() : options.tilingPaddingVertical;\n  CoSEConstants.TILING_PADDING_HORIZONTAL = typeof options.tilingPaddingHorizontal === 'function' ? options.tilingPaddingHorizontal.call() : options.tilingPaddingHorizontal;\n\n  CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = true;\n  CoSEConstants.PURE_INCREMENTAL = !options.randomize;\n  LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = options.uniformNodeDimensions;\n\n  // This part is for debug/demo purpose\n  if (options.step == \"transformed\") {\n    CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\n    CoSEConstants.ENFORCE_CONSTRAINTS = false;\n    CoSEConstants.APPLY_LAYOUT = false;\n  }\n  if (options.step == \"enforced\") {\n    CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n    CoSEConstants.ENFORCE_CONSTRAINTS = true;\n    CoSEConstants.APPLY_LAYOUT = false;\n  }\n  if (options.step == \"cose\") {\n    CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n    CoSEConstants.ENFORCE_CONSTRAINTS = false;\n    CoSEConstants.APPLY_LAYOUT = true;\n  }\n  if (options.step == \"all\") {\n    if (options.randomize) CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;else CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n    CoSEConstants.ENFORCE_CONSTRAINTS = true;\n    CoSEConstants.APPLY_LAYOUT = true;\n  }\n\n  if (options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint) {\n    CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false;\n  } else {\n    CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true;\n  }\n\n  var coseLayout = new CoSELayout();\n  var gm = coseLayout.newGraphManager();\n\n  processChildrenList(gm.addRoot(), aux.getTopMostNodes(nodes), coseLayout, options);\n  processEdges(coseLayout, gm, edges);\n  processConstraints(coseLayout, options);\n\n  coseLayout.runLayout();\n\n  return idToLNode;\n};\n\nmodule.exports = { coseLayout: coseLayout };\n\n/***/ }),\n\n/***/ 212:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n  The implementation of the fcose layout algorithm\n*/\n\nvar assign = __webpack_require__(658);\nvar aux = __webpack_require__(548);\n\nvar _require = __webpack_require__(657),\n    spectralLayout = _require.spectralLayout;\n\nvar _require2 = __webpack_require__(816),\n    coseLayout = _require2.coseLayout;\n\nvar defaults = Object.freeze({\n\n  // 'draft', 'default' or 'proof' \n  // - 'draft' only applies spectral layout \n  // - 'default' improves the quality with subsequent CoSE layout (fast cooling rate)\n  // - 'proof' improves the quality with subsequent CoSE layout (slow cooling rate) \n  quality: \"default\",\n  // Use random node positions at beginning of layout\n  // if this is set to false, then quality option must be \"proof\"\n  randomize: true,\n  // Whether or not to animate the layout\n  animate: true,\n  // Duration of animation in ms, if enabled\n  animationDuration: 1000,\n  // Easing of animation, if enabled\n  animationEasing: undefined,\n  // Fit the viewport to the repositioned nodes\n  fit: true,\n  // Padding around layout\n  padding: 30,\n  // Whether to include labels in node dimensions. Valid in \"proof\" quality\n  nodeDimensionsIncludeLabels: false,\n  // Whether or not simple nodes (non-compound nodes) are of uniform dimensions\n  uniformNodeDimensions: false,\n  // Whether to pack disconnected components - valid only if randomize: true\n  packComponents: true,\n  // Layout step - all, transformed, enforced, cose - for debug purpose only\n  step: \"all\",\n\n  /* spectral layout options */\n\n  // False for random, true for greedy\n  samplingType: true,\n  // Sample size to construct distance matrix\n  sampleSize: 25,\n  // Separation amount between nodes\n  nodeSeparation: 75,\n  // Power iteration tolerance\n  piTol: 0.0000001,\n\n  /* CoSE layout options */\n\n  // Node repulsion (non overlapping) multiplier\n  nodeRepulsion: function nodeRepulsion(node) {\n    return 4500;\n  },\n  // Ideal edge (non nested) length\n  idealEdgeLength: function idealEdgeLength(edge) {\n    return 50;\n  },\n  // Divisor to compute edge forces\n  edgeElasticity: function edgeElasticity(edge) {\n    return 0.45;\n  },\n  // Nesting factor (multiplier) to compute ideal edge length for nested edges\n  nestingFactor: 0.1,\n  // Gravity force (constant)\n  gravity: 0.25,\n  // Maximum number of iterations to perform\n  numIter: 2500,\n  // For enabling tiling\n  tile: true,\n  // The function that specifies the criteria for comparing nodes while sorting them during tiling operation.\n  // Takes the node id as a parameter and the default tiling operation is perfomed when this option is not set.\n  tilingCompareBy: undefined,\n  // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)\n  tilingPaddingVertical: 10,\n  // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)\n  tilingPaddingHorizontal: 10,\n  // Gravity range (constant) for compounds\n  gravityRangeCompound: 1.5,\n  // Gravity force (constant) for compounds\n  gravityCompound: 1.0,\n  // Gravity range (constant)\n  gravityRange: 3.8,\n  // Initial cooling factor for incremental layout  \n  initialEnergyOnIncremental: 0.3,\n\n  /* constraint options */\n\n  // Fix required nodes to predefined positions\n  // [{nodeId: 'n1', position: {x: 100, y: 200}, {...}]\n  fixedNodeConstraint: undefined,\n  // Align required nodes in vertical/horizontal direction\n  // {vertical: [['n1', 'n2')], ['n3', 'n4']], horizontal: ['n2', 'n4']}\n  alignmentConstraint: undefined,\n  // Place two nodes relatively in vertical/horizontal direction \n  // [{top: 'n1', bottom: 'n2', gap: 100}, {left: 'n3', right: 'n4', gap: 75}]\n  relativePlacementConstraint: undefined,\n\n  /* layout event callbacks */\n  ready: function ready() {}, // on layoutready\n  stop: function stop() {} // on layoutstop\n});\n\nvar Layout = function () {\n  function Layout(options) {\n    _classCallCheck(this, Layout);\n\n    this.options = assign({}, defaults, options);\n  }\n\n  _createClass(Layout, [{\n    key: 'run',\n    value: function run() {\n      var layout = this;\n      var options = this.options;\n      var cy = options.cy;\n      var eles = options.eles;\n\n      var spectralResult = [];\n      var xCoords = void 0;\n      var yCoords = void 0;\n      var coseResult = [];\n      var components = void 0;\n      var componentCenters = [];\n\n      // basic validity check for constraint inputs \n      if (options.fixedNodeConstraint && (!Array.isArray(options.fixedNodeConstraint) || options.fixedNodeConstraint.length == 0)) {\n        options.fixedNodeConstraint = undefined;\n      }\n\n      if (options.alignmentConstraint) {\n        if (options.alignmentConstraint.vertical && (!Array.isArray(options.alignmentConstraint.vertical) || options.alignmentConstraint.vertical.length == 0)) {\n          options.alignmentConstraint.vertical = undefined;\n        }\n        if (options.alignmentConstraint.horizontal && (!Array.isArray(options.alignmentConstraint.horizontal) || options.alignmentConstraint.horizontal.length == 0)) {\n          options.alignmentConstraint.horizontal = undefined;\n        }\n      }\n\n      if (options.relativePlacementConstraint && (!Array.isArray(options.relativePlacementConstraint) || options.relativePlacementConstraint.length == 0)) {\n        options.relativePlacementConstraint = undefined;\n      }\n\n      // if any constraint exists, set some options\n      var constraintExist = options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint;\n      if (constraintExist) {\n        // constraints work with these options\n        options.tile = false;\n        options.packComponents = false;\n      }\n\n      // decide component packing is enabled or not\n      var layUtil = void 0;\n      var packingEnabled = false;\n      if (cy.layoutUtilities && options.packComponents) {\n        layUtil = cy.layoutUtilities(\"get\");\n        if (!layUtil) layUtil = cy.layoutUtilities();\n        packingEnabled = true;\n      }\n\n      if (eles.nodes().length > 0) {\n        // if packing is not enabled, perform layout on the whole graph\n        if (!packingEnabled) {\n          // store component center\n          var boundingBox = options.eles.boundingBox();\n          componentCenters.push({ x: boundingBox.x1 + boundingBox.w / 2, y: boundingBox.y1 + boundingBox.h / 2 });\n          // apply spectral layout\n          if (options.randomize) {\n            var result = spectralLayout(options);\n            spectralResult.push(result);\n          }\n          // apply cose layout as postprocessing\n          if (options.quality == \"default\" || options.quality == \"proof\") {\n            coseResult.push(coseLayout(options, spectralResult[0]));\n            aux.relocateComponent(componentCenters[0], coseResult[0], options); // relocate center to original position\n          } else {\n            aux.relocateComponent(componentCenters[0], spectralResult[0], options); // relocate center to original position\n          }\n        } else {\n          // packing is enabled\n          var topMostNodes = aux.getTopMostNodes(options.eles.nodes());\n          components = aux.connectComponents(cy, options.eles, topMostNodes);\n          // store component centers\n          components.forEach(function (component) {\n            var boundingBox = component.boundingBox();\n            componentCenters.push({ x: boundingBox.x1 + boundingBox.w / 2, y: boundingBox.y1 + boundingBox.h / 2 });\n          });\n\n          //send each component to spectral layout if randomized\n          if (options.randomize) {\n            components.forEach(function (component) {\n              options.eles = component;\n              spectralResult.push(spectralLayout(options));\n            });\n          }\n\n          if (options.quality == \"default\" || options.quality == \"proof\") {\n            var toBeTiledNodes = cy.collection();\n            if (options.tile) {\n              // behave nodes to be tiled as one component\n              var nodeIndexes = new Map();\n              var _xCoords = [];\n              var _yCoords = [];\n              var count = 0;\n              var tempSpectralResult = { nodeIndexes: nodeIndexes, xCoords: _xCoords, yCoords: _yCoords };\n              var indexesToBeDeleted = [];\n              components.forEach(function (component, index) {\n                if (component.edges().length == 0) {\n                  component.nodes().forEach(function (node, i) {\n                    toBeTiledNodes.merge(component.nodes()[i]);\n                    if (!node.isParent()) {\n                      tempSpectralResult.nodeIndexes.set(component.nodes()[i].id(), count++);\n                      tempSpectralResult.xCoords.push(component.nodes()[0].position().x);\n                      tempSpectralResult.yCoords.push(component.nodes()[0].position().y);\n                    }\n                  });\n                  indexesToBeDeleted.push(index);\n                }\n              });\n              if (toBeTiledNodes.length > 1) {\n                var _boundingBox = toBeTiledNodes.boundingBox();\n                componentCenters.push({ x: _boundingBox.x1 + _boundingBox.w / 2, y: _boundingBox.y1 + _boundingBox.h / 2 });\n                components.push(toBeTiledNodes);\n                spectralResult.push(tempSpectralResult);\n                for (var i = indexesToBeDeleted.length - 1; i >= 0; i--) {\n                  components.splice(indexesToBeDeleted[i], 1);\n                  spectralResult.splice(indexesToBeDeleted[i], 1);\n                  componentCenters.splice(indexesToBeDeleted[i], 1);\n                };\n              }\n            }\n            components.forEach(function (component, index) {\n              // send each component to cose layout\n              options.eles = component;\n              coseResult.push(coseLayout(options, spectralResult[index]));\n              aux.relocateComponent(componentCenters[index], coseResult[index], options); // relocate center to original position\n            });\n          } else {\n            components.forEach(function (component, index) {\n              aux.relocateComponent(componentCenters[index], spectralResult[index], options); // relocate center to original position\n            });\n          }\n\n          // packing\n          var componentsEvaluated = new Set();\n          if (components.length > 1) {\n            var subgraphs = [];\n            var hiddenEles = eles.filter(function (ele) {\n              return ele.css('display') == 'none';\n            });\n            components.forEach(function (component, index) {\n              var nodeIndexes = void 0;\n              if (options.quality == \"draft\") {\n                nodeIndexes = spectralResult[index].nodeIndexes;\n              }\n\n              if (component.nodes().not(hiddenEles).length > 0) {\n                var subgraph = {};\n                subgraph.edges = [];\n                subgraph.nodes = [];\n                var nodeIndex = void 0;\n                component.nodes().not(hiddenEles).forEach(function (node) {\n                  if (options.quality == \"draft\") {\n                    if (!node.isParent()) {\n                      nodeIndex = nodeIndexes.get(node.id());\n                      subgraph.nodes.push({ x: spectralResult[index].xCoords[nodeIndex] - node.boundingbox().w / 2, y: spectralResult[index].yCoords[nodeIndex] - node.boundingbox().h / 2, width: node.boundingbox().w, height: node.boundingbox().h });\n                    } else {\n                      var parentInfo = aux.calcBoundingBox(node, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                      subgraph.nodes.push({ x: parentInfo.topLeftX, y: parentInfo.topLeftY, width: parentInfo.width, height: parentInfo.height });\n                    }\n                  } else {\n                    if (coseResult[index][node.id()]) {\n                      subgraph.nodes.push({ x: coseResult[index][node.id()].getLeft(), y: coseResult[index][node.id()].getTop(), width: coseResult[index][node.id()].getWidth(), height: coseResult[index][node.id()].getHeight() });\n                    }\n                  }\n                });\n                component.edges().forEach(function (edge) {\n                  var source = edge.source();\n                  var target = edge.target();\n                  if (source.css(\"display\") != \"none\" && target.css(\"display\") != \"none\") {\n                    if (options.quality == \"draft\") {\n                      var sourceNodeIndex = nodeIndexes.get(source.id());\n                      var targetNodeIndex = nodeIndexes.get(target.id());\n                      var sourceCenter = [];\n                      var targetCenter = [];\n                      if (source.isParent()) {\n                        var parentInfo = aux.calcBoundingBox(source, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                        sourceCenter.push(parentInfo.topLeftX + parentInfo.width / 2);\n                        sourceCenter.push(parentInfo.topLeftY + parentInfo.height / 2);\n                      } else {\n                        sourceCenter.push(spectralResult[index].xCoords[sourceNodeIndex]);\n                        sourceCenter.push(spectralResult[index].yCoords[sourceNodeIndex]);\n                      }\n                      if (target.isParent()) {\n                        var _parentInfo = aux.calcBoundingBox(target, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                        targetCenter.push(_parentInfo.topLeftX + _parentInfo.width / 2);\n                        targetCenter.push(_parentInfo.topLeftY + _parentInfo.height / 2);\n                      } else {\n                        targetCenter.push(spectralResult[index].xCoords[targetNodeIndex]);\n                        targetCenter.push(spectralResult[index].yCoords[targetNodeIndex]);\n                      }\n                      subgraph.edges.push({ startX: sourceCenter[0], startY: sourceCenter[1], endX: targetCenter[0], endY: targetCenter[1] });\n                    } else {\n                      if (coseResult[index][source.id()] && coseResult[index][target.id()]) {\n                        subgraph.edges.push({ startX: coseResult[index][source.id()].getCenterX(), startY: coseResult[index][source.id()].getCenterY(), endX: coseResult[index][target.id()].getCenterX(), endY: coseResult[index][target.id()].getCenterY() });\n                      }\n                    }\n                  }\n                });\n                if (subgraph.nodes.length > 0) {\n                  subgraphs.push(subgraph);\n                  componentsEvaluated.add(index);\n                }\n              }\n            });\n            var shiftResult = layUtil.packComponents(subgraphs, options.randomize).shifts;\n            if (options.quality == \"draft\") {\n              spectralResult.forEach(function (result, index) {\n                var newXCoords = result.xCoords.map(function (x) {\n                  return x + shiftResult[index].dx;\n                });\n                var newYCoords = result.yCoords.map(function (y) {\n                  return y + shiftResult[index].dy;\n                });\n                result.xCoords = newXCoords;\n                result.yCoords = newYCoords;\n              });\n            } else {\n              var _count = 0;\n              componentsEvaluated.forEach(function (index) {\n                Object.keys(coseResult[index]).forEach(function (item) {\n                  var nodeRectangle = coseResult[index][item];\n                  nodeRectangle.setCenter(nodeRectangle.getCenterX() + shiftResult[_count].dx, nodeRectangle.getCenterY() + shiftResult[_count].dy);\n                });\n                _count++;\n              });\n            }\n          }\n        }\n      }\n\n      // get each element's calculated position\n      var getPositions = function getPositions(ele, i) {\n        if (options.quality == \"default\" || options.quality == \"proof\") {\n          if (typeof ele === \"number\") {\n            ele = i;\n          }\n          var pos = void 0;\n          var node = void 0;\n          var theId = ele.data('id');\n          coseResult.forEach(function (result) {\n            if (theId in result) {\n              pos = { x: result[theId].getRect().getCenterX(), y: result[theId].getRect().getCenterY() };\n              node = result[theId];\n            }\n          });\n          if (options.nodeDimensionsIncludeLabels) {\n            if (node.labelWidth) {\n              if (node.labelPosHorizontal == \"left\") {\n                pos.x += node.labelWidth / 2;\n              } else if (node.labelPosHorizontal == \"right\") {\n                pos.x -= node.labelWidth / 2;\n              }\n            }\n            if (node.labelHeight) {\n              if (node.labelPosVertical == \"top\") {\n                pos.y += node.labelHeight / 2;\n              } else if (node.labelPosVertical == \"bottom\") {\n                pos.y -= node.labelHeight / 2;\n              }\n            }\n          }\n          if (pos == undefined) pos = { x: ele.position(\"x\"), y: ele.position(\"y\") };\n          return {\n            x: pos.x,\n            y: pos.y\n          };\n        } else {\n          var _pos = void 0;\n          spectralResult.forEach(function (result) {\n            var index = result.nodeIndexes.get(ele.id());\n            if (index != undefined) {\n              _pos = { x: result.xCoords[index], y: result.yCoords[index] };\n            }\n          });\n          if (_pos == undefined) _pos = { x: ele.position(\"x\"), y: ele.position(\"y\") };\n          return {\n            x: _pos.x,\n            y: _pos.y\n          };\n        }\n      };\n\n      // quality = \"draft\" and randomize = false are contradictive so in that case positions don't change\n      if (options.quality == \"default\" || options.quality == \"proof\" || options.randomize) {\n        // transfer calculated positions to nodes (positions of only simple nodes are evaluated, compounds are positioned automatically)\n        var parentsWithoutChildren = aux.calcParentsWithoutChildren(cy, eles);\n        var _hiddenEles = eles.filter(function (ele) {\n          return ele.css('display') == 'none';\n        });\n        options.eles = eles.not(_hiddenEles);\n\n        eles.nodes().not(\":parent\").not(_hiddenEles).layoutPositions(layout, options, getPositions);\n\n        if (parentsWithoutChildren.length > 0) {\n          parentsWithoutChildren.forEach(function (ele) {\n            ele.position(getPositions(ele));\n          });\n        }\n      } else {\n        console.log(\"If randomize option is set to false, then quality option must be 'default' or 'proof'.\");\n      }\n    }\n  }]);\n\n  return Layout;\n}();\n\nmodule.exports = Layout;\n\n/***/ }),\n\n/***/ 657:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\n/**\n  The implementation of the spectral layout that is the first part of the fcose layout algorithm\n*/\n\nvar aux = __webpack_require__(548);\nvar Matrix = __webpack_require__(140).layoutBase.Matrix;\nvar SVD = __webpack_require__(140).layoutBase.SVD;\n\n// main function that spectral layout is processed\nvar spectralLayout = function spectralLayout(options) {\n\n  var cy = options.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes();\n  var parentNodes = eles.nodes(\":parent\");\n\n  var dummyNodes = new Map(); // map to keep dummy nodes and their neighbors\n  var nodeIndexes = new Map(); // map to keep indexes to nodes\n  var parentChildMap = new Map(); // mapping btw. compound and its representative node \n  var allNodesNeighborhood = []; // array to keep neighborhood of all nodes\n  var xCoords = [];\n  var yCoords = [];\n\n  var samplesColumn = []; // sampled vertices\n  var minDistancesColumn = [];\n  var C = []; // column sampling matrix\n  var PHI = []; // intersection of column and row sampling matrices \n  var INV = []; // inverse of PHI \n\n  var firstSample = void 0; // the first sampled node\n  var nodeSize = void 0;\n\n  var infinity = 100000000;\n  var small = 0.000000001;\n\n  var piTol = options.piTol;\n  var samplingType = options.samplingType; // false for random, true for greedy\n  var nodeSeparation = options.nodeSeparation;\n  var sampleSize = void 0;\n\n  /**** Spectral-preprocessing functions ****/\n\n  /**** Spectral layout functions ****/\n\n  // determine which columns to be sampled\n  var randomSampleCR = function randomSampleCR() {\n    var sample = 0;\n    var count = 0;\n    var flag = false;\n\n    while (count < sampleSize) {\n      sample = Math.floor(Math.random() * nodeSize);\n\n      flag = false;\n      for (var i = 0; i < count; i++) {\n        if (samplesColumn[i] == sample) {\n          flag = true;\n          break;\n        }\n      }\n\n      if (!flag) {\n        samplesColumn[count] = sample;\n        count++;\n      } else {\n        continue;\n      }\n    }\n  };\n\n  // takes the index of the node(pivot) to initiate BFS as a parameter\n  var BFS = function BFS(pivot, index, samplingMethod) {\n    var path = []; // the front of the path\n    var front = 0; // the back of the path\n    var back = 0;\n    var current = 0;\n    var temp = void 0;\n    var distance = [];\n\n    var max_dist = 0; // the furthest node to be returned\n    var max_ind = 1;\n\n    for (var i = 0; i < nodeSize; i++) {\n      distance[i] = infinity;\n    }\n\n    path[back] = pivot;\n    distance[pivot] = 0;\n\n    while (back >= front) {\n      current = path[front++];\n      var neighbors = allNodesNeighborhood[current];\n      for (var _i = 0; _i < neighbors.length; _i++) {\n        temp = nodeIndexes.get(neighbors[_i]);\n        if (distance[temp] == infinity) {\n          distance[temp] = distance[current] + 1;\n          path[++back] = temp;\n        }\n      }\n      C[current][index] = distance[current] * nodeSeparation;\n    }\n\n    if (samplingMethod) {\n      for (var _i2 = 0; _i2 < nodeSize; _i2++) {\n        if (C[_i2][index] < minDistancesColumn[_i2]) minDistancesColumn[_i2] = C[_i2][index];\n      }\n\n      for (var _i3 = 0; _i3 < nodeSize; _i3++) {\n        if (minDistancesColumn[_i3] > max_dist) {\n          max_dist = minDistancesColumn[_i3];\n          max_ind = _i3;\n        }\n      }\n    }\n    return max_ind;\n  };\n\n  // apply BFS to all nodes or selected samples\n  var allBFS = function allBFS(samplingMethod) {\n\n    var sample = void 0;\n\n    if (!samplingMethod) {\n      randomSampleCR();\n\n      // call BFS\n      for (var i = 0; i < sampleSize; i++) {\n        BFS(samplesColumn[i], i, samplingMethod, false);\n      }\n    } else {\n      sample = Math.floor(Math.random() * nodeSize);\n      firstSample = sample;\n\n      for (var _i4 = 0; _i4 < nodeSize; _i4++) {\n        minDistancesColumn[_i4] = infinity;\n      }\n\n      for (var _i5 = 0; _i5 < sampleSize; _i5++) {\n        samplesColumn[_i5] = sample;\n        sample = BFS(sample, _i5, samplingMethod);\n      }\n    }\n\n    // form the squared distances for C\n    for (var _i6 = 0; _i6 < nodeSize; _i6++) {\n      for (var j = 0; j < sampleSize; j++) {\n        C[_i6][j] *= C[_i6][j];\n      }\n    }\n\n    // form PHI\n    for (var _i7 = 0; _i7 < sampleSize; _i7++) {\n      PHI[_i7] = [];\n    }\n\n    for (var _i8 = 0; _i8 < sampleSize; _i8++) {\n      for (var _j = 0; _j < sampleSize; _j++) {\n        PHI[_i8][_j] = C[samplesColumn[_j]][_i8];\n      }\n    }\n  };\n\n  // perform the SVD algorithm and apply a regularization step\n  var sample = function sample() {\n\n    var SVDResult = SVD.svd(PHI);\n\n    var a_q = SVDResult.S;\n    var a_u = SVDResult.U;\n    var a_v = SVDResult.V;\n\n    var max_s = a_q[0] * a_q[0] * a_q[0];\n\n    var a_Sig = [];\n\n    //  regularization\n    for (var i = 0; i < sampleSize; i++) {\n      a_Sig[i] = [];\n      for (var j = 0; j < sampleSize; j++) {\n        a_Sig[i][j] = 0;\n        if (i == j) {\n          a_Sig[i][j] = a_q[i] / (a_q[i] * a_q[i] + max_s / (a_q[i] * a_q[i]));\n        }\n      }\n    }\n\n    INV = Matrix.multMat(Matrix.multMat(a_v, a_Sig), Matrix.transpose(a_u));\n  };\n\n  // calculate final coordinates \n  var powerIteration = function powerIteration() {\n    // two largest eigenvalues\n    var theta1 = void 0;\n    var theta2 = void 0;\n\n    // initial guesses for eigenvectors\n    var Y1 = [];\n    var Y2 = [];\n\n    var V1 = [];\n    var V2 = [];\n\n    for (var i = 0; i < nodeSize; i++) {\n      Y1[i] = Math.random();\n      Y2[i] = Math.random();\n    }\n\n    Y1 = Matrix.normalize(Y1);\n    Y2 = Matrix.normalize(Y2);\n\n    var count = 0;\n    // to keep track of the improvement ratio in power iteration\n    var current = small;\n    var previous = small;\n\n    var temp = void 0;\n\n    while (true) {\n      count++;\n\n      for (var _i9 = 0; _i9 < nodeSize; _i9++) {\n        V1[_i9] = Y1[_i9];\n      }\n\n      Y1 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V1), C, INV));\n      theta1 = Matrix.dotProduct(V1, Y1);\n      Y1 = Matrix.normalize(Y1);\n\n      current = Matrix.dotProduct(V1, Y1);\n\n      temp = Math.abs(current / previous);\n\n      if (temp <= 1 + piTol && temp >= 1) {\n        break;\n      }\n\n      previous = current;\n    }\n\n    for (var _i10 = 0; _i10 < nodeSize; _i10++) {\n      V1[_i10] = Y1[_i10];\n    }\n\n    count = 0;\n    previous = small;\n    while (true) {\n      count++;\n\n      for (var _i11 = 0; _i11 < nodeSize; _i11++) {\n        V2[_i11] = Y2[_i11];\n      }\n\n      V2 = Matrix.minusOp(V2, Matrix.multCons(V1, Matrix.dotProduct(V1, V2)));\n      Y2 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V2), C, INV));\n      theta2 = Matrix.dotProduct(V2, Y2);\n      Y2 = Matrix.normalize(Y2);\n\n      current = Matrix.dotProduct(V2, Y2);\n\n      temp = Math.abs(current / previous);\n\n      if (temp <= 1 + piTol && temp >= 1) {\n        break;\n      }\n\n      previous = current;\n    }\n\n    for (var _i12 = 0; _i12 < nodeSize; _i12++) {\n      V2[_i12] = Y2[_i12];\n    }\n\n    // theta1 now contains dominant eigenvalue\n    // theta2 now contains the second-largest eigenvalue\n    // V1 now contains theta1's eigenvector\n    // V2 now contains theta2's eigenvector\n\n    //populate the two vectors\n    xCoords = Matrix.multCons(V1, Math.sqrt(Math.abs(theta1)));\n    yCoords = Matrix.multCons(V2, Math.sqrt(Math.abs(theta2)));\n  };\n\n  /**** Preparation for spectral layout (Preprocessing) ****/\n\n  // connect disconnected components (first top level, then inside of each compound node)\n  aux.connectComponents(cy, eles, aux.getTopMostNodes(nodes), dummyNodes);\n\n  parentNodes.forEach(function (ele) {\n    aux.connectComponents(cy, eles, aux.getTopMostNodes(ele.descendants().intersection(eles)), dummyNodes);\n  });\n\n  // assign indexes to nodes (first real, then dummy nodes)\n  var index = 0;\n  for (var i = 0; i < nodes.length; i++) {\n    if (!nodes[i].isParent()) {\n      nodeIndexes.set(nodes[i].id(), index++);\n    }\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = dummyNodes.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var key = _step.value;\n\n      nodeIndexes.set(key, index++);\n    }\n\n    // instantiate the neighborhood matrix\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  for (var _i13 = 0; _i13 < nodeIndexes.size; _i13++) {\n    allNodesNeighborhood[_i13] = [];\n  }\n\n  // form a parent-child map to keep representative node of each compound node  \n  parentNodes.forEach(function (ele) {\n    var children = ele.children().intersection(eles);\n\n    //      let random = 0;\n    while (children.nodes(\":childless\").length == 0) {\n      //        random = Math.floor(Math.random() * children.nodes().length); // if all children are compound then proceed randomly\n      children = children.nodes()[0].children().intersection(eles);\n    }\n    //  select the representative node - we can apply different methods here\n    //      random = Math.floor(Math.random() * children.nodes(\":childless\").length);\n    var index = 0;\n    var min = children.nodes(\":childless\")[0].connectedEdges().length;\n    children.nodes(\":childless\").forEach(function (ele2, i) {\n      if (ele2.connectedEdges().length < min) {\n        min = ele2.connectedEdges().length;\n        index = i;\n      }\n    });\n    parentChildMap.set(ele.id(), children.nodes(\":childless\")[index].id());\n  });\n\n  // add neighborhood relations (first real, then dummy nodes)\n  nodes.forEach(function (ele) {\n    var eleIndex = void 0;\n\n    if (ele.isParent()) eleIndex = nodeIndexes.get(parentChildMap.get(ele.id()));else eleIndex = nodeIndexes.get(ele.id());\n\n    ele.neighborhood().nodes().forEach(function (node) {\n      if (eles.intersection(ele.edgesWith(node)).length > 0) {\n        if (node.isParent()) allNodesNeighborhood[eleIndex].push(parentChildMap.get(node.id()));else allNodesNeighborhood[eleIndex].push(node.id());\n      }\n    });\n  });\n\n  var _loop = function _loop(_key) {\n    var eleIndex = nodeIndexes.get(_key);\n    var disconnectedId = void 0;\n    dummyNodes.get(_key).forEach(function (id) {\n      if (cy.getElementById(id).isParent()) disconnectedId = parentChildMap.get(id);else disconnectedId = id;\n\n      allNodesNeighborhood[eleIndex].push(disconnectedId);\n      allNodesNeighborhood[nodeIndexes.get(disconnectedId)].push(_key);\n    });\n  };\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = dummyNodes.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _key = _step2.value;\n\n      _loop(_key);\n    }\n\n    // nodeSize now only considers the size of transformed graph\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  nodeSize = nodeIndexes.size;\n\n  var spectralResult = void 0;\n\n  // If number of nodes in transformed graph is 1 or 2, either SVD or powerIteration causes problem\n  // So skip spectral and layout the graph with cose\n  if (nodeSize > 2) {\n    // if # of nodes in transformed graph is smaller than sample size,\n    // then use # of nodes as sample size\n    sampleSize = nodeSize < options.sampleSize ? nodeSize : options.sampleSize;\n\n    // instantiates the partial matrices that will be used in spectral layout\n    for (var _i14 = 0; _i14 < nodeSize; _i14++) {\n      C[_i14] = [];\n    }\n    for (var _i15 = 0; _i15 < sampleSize; _i15++) {\n      INV[_i15] = [];\n    }\n\n    /**** Apply spectral layout ****/\n\n    if (options.quality == \"draft\" || options.step == \"all\") {\n      allBFS(samplingType);\n      sample();\n      powerIteration();\n\n      spectralResult = { nodeIndexes: nodeIndexes, xCoords: xCoords, yCoords: yCoords };\n    } else {\n      nodeIndexes.forEach(function (value, key) {\n        xCoords.push(cy.getElementById(key).position(\"x\"));\n        yCoords.push(cy.getElementById(key).position(\"y\"));\n      });\n      spectralResult = { nodeIndexes: nodeIndexes, xCoords: xCoords, yCoords: yCoords };\n    }\n    return spectralResult;\n  } else {\n    var iterator = nodeIndexes.keys();\n    var firstNode = cy.getElementById(iterator.next().value);\n    var firstNodePos = firstNode.position();\n    var firstNodeWidth = firstNode.outerWidth();\n    xCoords.push(firstNodePos.x);\n    yCoords.push(firstNodePos.y);\n    if (nodeSize == 2) {\n      var secondNode = cy.getElementById(iterator.next().value);\n      var secondNodeWidth = secondNode.outerWidth();\n      xCoords.push(firstNodePos.x + firstNodeWidth / 2 + secondNodeWidth / 2 + options.idealEdgeLength);\n      yCoords.push(firstNodePos.y);\n    }\n\n    spectralResult = { nodeIndexes: nodeIndexes, xCoords: xCoords, yCoords: yCoords };\n    return spectralResult;\n  }\n};\n\nmodule.exports = { spectralLayout: spectralLayout };\n\n/***/ }),\n\n/***/ 579:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\nvar impl = __webpack_require__(212);\n\n// registers the extension on a cytoscape lib ref\nvar register = function register(cytoscape) {\n  if (!cytoscape) {\n    return;\n  } // can't register if cytoscape unspecified\n\n  cytoscape('layout', 'fcose', impl); // register with cytoscape.js\n};\n\nif (typeof cytoscape !== 'undefined') {\n  // expose to global cytoscape (i.e. window.cytoscape)\n  register(cytoscape);\n}\n\nmodule.exports = register;\n\n/***/ }),\n\n/***/ 140:\n/***/ ((module) => {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__140__;\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \tvar __webpack_exports__ = __webpack_require__(579);\n/******/ \t\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}